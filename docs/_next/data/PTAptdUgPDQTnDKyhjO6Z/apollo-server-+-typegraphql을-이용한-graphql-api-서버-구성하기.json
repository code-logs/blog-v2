{"pageProps":{"post":{"title":"Apollo Server + TypeGraphQL을 이용한 GraphQL API 서버 구성하기","fileName":"grapql-with-apollo-server-typegraphql.md","description":"Apollo Server와 TypeGraphQL을 사용한 Node.JS GraphQL API 서버 구성하기","category":"nodejs","published":true,"publishedAt":"2022-03-10","tags":["graphql","apollo","apollo-server","node.js","typescript","typegraphql","api","api server"],"thumbnailName":"grapqhl-apollo-typegrapql.png","references":[{"title":"Apollo Server","url":"https://www.apollographql.com"},{"title":"TypeGraphQL","url":"https://typegraphql.com"},{"title":"GraphQL","url":"https://graphql.org"},{"title":"DataLoader - GitHub Repository","url":"https://github.com/graphql/dataloader"}]},"content":"<h2 id=\"table-of-contents\">Table of contents</h2>\n<ol>\n<li><a href=\"#graphql\">GraphQL</a></li>\n<li><a href=\"#typescript%EC%99%80-%EC%B0%B0%EB%96%A1-%EA%B6%81%ED%95%A9\">Typescript와 찰떡 궁합</a></li>\n<li><a href=\"#apollo-server\">Apollo Server</a></li>\n<li><a href=\"#apollo-server-%EA%B5%AC%EC%84%B1%ED%95%98%EA%B8%B0\">Apollo Server 구성하기</a><ol>\n<li><a href=\"#schema---%EA%B0%9D%EC%B2%B4-%ED%98%95%ED%83%9C-%EC%A0%95%EC%9D%98%ED%95%98%EA%B8%B0\">Schema - 객체 형태 정의하기</a></li>\n<li><a href=\"#schema---query-%EC%A0%95%EC%9D%98%ED%95%98%EA%B8%B0\">Schema - Query 정의하기</a></li>\n<li><a href=\"#schema---mutation-%EC%A0%95%EC%9D%98%ED%95%98%EA%B8%B0\">Schema - Mutation 정의하기</a></li>\n<li><a href=\"#resolver---%EC%8B%A4%EC%A0%9C-%EC%9E%91%EC%97%85%EC%9D%B4-%EC%9D%BC%EC%96%B4%EB%82%98%EB%8A%94-%EA%B3%B3\">Resolver - 실제 작업이 일어나는 곳</a></li>\n<li><a href=\"#query-%EC%9E%91%EC%84%B1%ED%95%98%EA%B8%B0\">Query 작성하기</a></li>\n<li><a href=\"#mutation-%EC%9E%91%EC%84%B1%ED%95%98%EA%B8%B0\">Mutation 작성하기</a></li>\n<li><a href=\"#apollo-server-%EC%8B%A4%ED%96%89%ED%95%98%EA%B8%B0\">Apollo Server 실행하기</a></li>\n</ol>\n</li>\n<li><a href=\"#field-resolver%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-%ED%85%8C%EC%9D%B4%EB%B8%94-join\">Field resolver를 이용한 테이블 Join</a></li>\n<li><a href=\"#typegraphql\">TypeGraphQL</a><ol>\n<li><a href=\"#%EB%94%94%ED%8E%9C%EB%8D%98%EC%8B%9C-%EC%84%A4%EC%B9%98\">디펜던시 설치</a></li>\n<li><a href=\"#tsconfig-configuration\">tsconfig configuration</a></li>\n<li><a href=\"#class-%EC%A0%95%EC%9D%98\">Class 정의</a></li>\n<li><a href=\"#resolver-%EC%A0%95%EC%9D%98\">Resolver 정의</a></li>\n<li><a href=\"#schema-%EC%83%9D%EC%84%B1%ED%95%98%EA%B8%B0\">Schema 생성하기</a></li>\n<li><a href=\"#%EA%B7%B8-%EB%B0%96%EC%9D%98-%EC%84%A4%EC%A0%95%EB%93%A4\">그 밖의 설정들</a></li>\n</ol>\n</li>\n</ol>\n<h2 id=\"graphql\">GraphQL</h2>\n<blockquote>\n<p>GraphQL은 2012년 부터 페이스북에 의해 개발되었으며 2015년에 공식적으로 발표되었다.\nRESTful API로 대표되는 클라이언트와 서버의 통신 아키텍쳐중 하나이다. 단일 Resource를 대상으로하는 RESTful API와 다르게 Graph 구조, 즉 노드간의 상관관계를 통해 클라이언트에서 반환 받고자 하는 데이터의 형식을 결정 할 수 있는 것이 특징이다.\n이를 통해 불필요한 데이터의 fetching을 방지 할 수 있다는 것과 클라이언트 소스의 수정만으로 기대되는 API의 Return type을 조정 할 수 있다는 장점을 가지고 있다.</p>\n</blockquote>\n<h2 id=\"typescript와-찰떡-궁합\">Typescript와 찰떡 궁합</h2>\n<p>GraphQL은 ‘강한 타입’ 제약을 가지는 것이 특징이다. GraphQL 아키텍쳐로 구성된 서버는 클라이언트에서 요구하는 데이터 유형과 정확히 일치하는 데이터 유형을 반환해야 하기 때문이다.</p>\n<h2 id=\"apollo-server\">Apollo Server</h2>\n<p>GraphQL 환경의 클라이언트와 통신하기 위한 Node.js 서버를 구성할 수 있는 패키지다. Apollo Server는 GrpahQL 아키텍쳐의 간단한 서버를 구성하는 것을 목적으로 하기 때문에 조금더 복잡한 구조의 Node.js 서버 구성을 위해서는 <code>apollo-server-express</code> 또는 <code>apollo-server-koa</code> 와 같은 디펜던시를 <code>Express</code> , <code>Koa</code> 와 같은 프레임워크에 엮어서 사용해아 한다.</p>\n<h2 id=\"apollo-server-구성하기\">Apollo Server 구성하기</h2>\n<p>node 프로젝트를 초기화하고 필요한 디펜던시를 설치한다.</p>\n<pre><code class=\"language-bash\">$ npm init -y\n$ npm i graphql apollo-server\n</code></pre>\n<h3 id=\"schema---객체-형태-정의하기\">Schema - 객체 형태 정의하기</h3>\n<p>GraphQL은 <code>강한 타입 제약</code> 을 가지고 있고 이것을 정의하는 역할을 하게 되는 것이 바로 <code>Schema</code>이다. 스키마의 아래 예제를 통해 <code>User</code> schema를 정의한다.</p>\n<pre><code class=\"language-typescript\">// typeDefs.ts\n\nimport { gql } from &#39;apollo-server&#39;\n\nconst typeDefs = gql`\n  type User {\n    id: Int\n    name: String\n    age: Int\n  }\n\n  input NewUser {\n    name: String!\n    age: Int!\n  }\n`\n</code></pre>\n<p>User라는 명칭의 schema는 String 타입의 <code>name</code> 필드와 Int 타입의 <code>age</code> 필드를 가지고 있다.</p>\n<blockquote>\n<p><code>User</code> 유형의 schema는 데이터를 반환할 때 사용하는 형태다 (객체 타입)\n<code>input</code> 유형의 schema는 클라이언트에서 서버로 데이터를 전달 할 때 사용하는 형태다</p>\n</blockquote>\n<blockquote>\n<p><code>GraphQL</code>의 schema 타입을 정의할 때 <code>javascript</code>의 원시 타입 (number, string, boolean 등)을 사용하는 것이 아닌 <code>GraphQL</code>의 자체 타입을 사용한다. - <a href=\"https://graphql.org/learn/schema/\">참조</a></p>\n</blockquote>\n<h3 id=\"schema---query-정의하기\">Schema - Query 정의하기</h3>\n<p>클라이언트와 서버가 통신하기 위한 입/출력(<code>type/input</code>) schema를 정의 했으니 이제 RESTful API의 endpoint와 유사한 <code>Query</code> schema를 정의한다.</p>\n<pre><code class=\"language-typescript\">// typeDefs.ts\n\nimport { gql } from &#39;apollo-server&#39;\n\nconst typeDefs = gql`\n    ...\n\n    type Query {\n        user(name: String!): User\n        users: [User]\n    }\n`\n</code></pre>\n<p><code>Query</code> 타입의 schema는 말 그대로 데이터를 조회하기 위해 사용되는 schema에 대한 정보다.</p>\n<p>두가지 Query 유형의 schema가 정의되었고 <code>User</code> 를 리턴하는 <code>user</code> query와 <code>[User]</code> 를 리턴하는 <code>users</code> query다.</p>\n<h3 id=\"schema---mutation-정의하기\">Schema - Mutation 정의하기</h3>\n<p>Query를 정의 했으니 이제 <code>Mutation</code>을 정의한다. <code>Mutation</code>은 말그대로 데이터의 변이를 발생시키는 스키마를 의미한다.</p>\n<pre><code class=\"language-typescript\">// typeDefs.ts\n\nimport { gql } from &#39;apollo-server&#39;\n\nconst typeDefs = gql`\n    ...\n\n    type Mutation {\n        addUser(user: NewUser!): User\n        deleteUser(id: String!): Boolean\n    }\n`\n</code></pre>\n<p>새로운 사용자를 추가할 때 사용할 <code>addUser</code> schema와 <code>ID</code> 를 통해 사용자를 삭제할 때 사용할 <code>deleteUser</code> 스키마를 정의 했다.</p>\n<blockquote>\n<p>Mutation 스키마의 파라미터로 사용되는 스키마는 반드시 <code>input</code> 타입 스키마를 사용하며\nQuery의 반환결과로 사용되는 스키마는 반드시 객체 타입의 스키마를 사용한다.</p>\n</blockquote>\n<blockquote>\n<p>두 스키마는 각각 <code>User</code> 와 <code>Boolean</code> 을 리턴 타입으로 갖고 있는데 GraphQL에서는 <code>void</code> 유형이 없는 것 또한 특징이다. <code>void</code> 를 사용해야 할 때 리턴 타입을 Boolean으로 선언한다.</p>\n</blockquote>\n<h3 id=\"resolver---실제-작업이-일어나는-곳\">Resolver - 실제 작업이 일어나는 곳</h3>\n<p>지금까지 작성한 Schema는</p>\n<p><code>User</code>, <code>New User</code>, <code>Query - user</code>, <code>Query - users</code>, <code>Mutation - addUser</code>, <code>Mutation - deleteUser</code> 로 사용자를 조회하고 생성하고 삭제하기 위한 필요한 타입 정의는 끝났으니 이제 실제 데이터를 가공하는 로직을 작성해야 한다.</p>\n<p>이렇게 정의된 schema를 통해 클라이언트로 부터 데이터를 전달 받고 처리하는 것을 <code>resolver</code>라 한다.</p>\n<p>우선 본격적으로 resolver를 정의하기 전에 테스트로 사용할 더미 데이터와 인터페이스를 만든다.</p>\n<pre><code class=\"language-typescript\">// resolvers.ts\n\ninterface User {\n  id: number\n  name: string\n  age: number\n}\n\nlet dummyUsers = Array.from({ length: 20 }, (_, idx) =&gt; {\n  return {\n    id: idx + 1,\n    name: `Sample User ${idx + 1}`,\n    age: Math.floor(Math.random() * 20),\n  }\n})\n</code></pre>\n<p>이제 조회 <code>user</code>, <code>users</code> 처리를 위한 <code>resolver</code>를 정의한다.</p>\n<h3 id=\"query-작성하기\">Query 작성하기</h3>\n<p><code>Query</code> 는 데이터 조회를 위한 <code>resolver</code> 에 해당한다. <code>name</code> 을 parameter로 전달 받아 동일한 <code>name</code> 을 가진 사용자를 반환하는 <code>user</code> resolver와 <code>user</code> 전체 리스트를 반환하는 <code>users</code> resolver를 작성한다.</p>\n<pre><code class=\"language-typescript\">// resolvers.ts\n\n...\n\nconst resolvers = {\n    Query: {\n        user: (_: unknown, { name }: { name: string}) =&gt; {\n            return dummyUsers.find((user) =&gt; user.name === name)\n        },\n\n        users: () =&gt; {\n            return dummyUsers\n        }\n    }\n}\n</code></pre>\n<h3 id=\"mutation-작성하기\">Mutation 작성하기</h3>\n<p><code>Mutation</code> 은 데이터의 변이가 일어나는 <code>resolver</code> 에 해당한다. <code>user</code> 객체를 parameter로 전달 받아 새로운 <code>user</code> 데이터를 생성하는 <code>addUser</code> resolver와 사용자이 <code>id</code> 를 전달받아 일치하는 사용자 데이터를 삭제하는 <code>deleteUser</code> resolver를 작성한다.</p>\n<pre><code class=\"language-typescript\">// resolvers.ts\n\nconst resolvers = {\n\n  ...\n\n  Mutation: {\n    addUser: (_: unknown, { user }: { user: User }) =&gt; {\n      const newUser = {\n        ...user,\n        id: dummyUsers[dummyUsers.length - 1].id + 1,\n      }\n      dummyUsers.push(newUser)\n      return newUser\n    },\n    deleteUser: (_: unknown, { id }: { id: number }) =&gt; {\n      dummyUsers = dummyUsers.filter((user) =&gt; user.id !== id)\n    },\n  },\n}\n</code></pre>\n<blockquote>\n<p>Resolver의 parameter들</p>\n<p>resolver는 <code>parent</code>, <code>args</code>, <code>context</code>, <code>info</code> 네개의 parameter를 전달 받는다\n각 parameter의 역할은 아래와 같다.</p>\n<p><code>parent</code> - <code>field resolver</code>를 통해 현재 resolver가 호출 될 경우 부모 resolver에 의해 반환된 객체 (Resolver chaining)</p>\n<p><code>args</code> - resolver를 호출할 때 전달한 인자</p>\n<p><code>context</code> - 모든 resolver에 공통적으로 전달되는 <code>context</code> 객체로 일반적으로 미들웨어를 통해 기록된 값이 담겨있다.</p>\n<p><code>info</code> - schema 정보와 field 정보 등을 담은 객체</p>\n</blockquote>\n<h3 id=\"apollo-server-실행하기\">Apollo Server 실행하기</h3>\n<p>Apollo Server를 실행하기 위한 type과 resolver가 모두 정의 되었으니 <code>apollo server</code> 를 실행하고 테스트 해본다.</p>\n<pre><code class=\"language-typescript\">import { ApolloServer } from &#39;apollo-server&#39;\nimport typeDefs from &#39;./typeDefs&#39;\nimport resolvers from &#39;./resolvers&#39;\n\nconst server = new ApolloServer({ typeDefs, resolvers })\n\nserver.listen(8080).then(() =&gt; {\n  console.log(&#39;Apollo Server is running on 8080&#39;)\n})\n</code></pre>\n<p>Apollo Server를 실행하면 <code>Apollo Studio</code> 를 통해 작성한 GraphQL 서버로 요청을 보낼 수 있다.</p>\n<h2 id=\"field-resolver를-이용한-테이블-join\">Field resolver를 이용한 테이블 Join</h2>\n<p>GraphQL은 반환하는 <code>Object type</code>의 모든 필드의 값이 <code>resolver</code> 에 의해 채워진다. 어떤 필드에 특정한 resolver가 정의되어 있지 않다면 일반적으로 <code>object.field</code> 와 같은 형태로 값을 채우게 된다. (default resolver)</p>\n<p>만약 특정 필드가 또 다른 테이블 (객체)을 통해 값이 결정 된다면 <code>field resolver</code> 를 정의하여 쉽게 값을 채울 수 있다.</p>\n<p>사용자가 <code>Company</code> 라는 테이블과 relation을 가지고 있다면 아래와 같이 field resolver를 정의 할 수 있다.</p>\n<pre><code class=\"language-typescript\">// resolvers.ts\n\nconst resolvers = {\n    ...\n\n    User: {\n        company: (parent: User) =&gt; {\n            return dummyCompanies.find((company) =&gt; company.id === parent.companyId)\n        }\n    }\n}\n</code></pre>\n<p>field resolver를 이용할 경우 resolver chain을 통해 해당 필드에 대한 접근을 시도할 때에만 대상 객체에 접근하도록 구성 할 수 있고 가상 필드와 같은 효과를 손쉽게 구현 할 수 있다는 장점이 있다. 반면에 리스트 데이터를 조회할 때 유사한 결과를 리턴하는 레코드가 많이 포함되어 있다면 같은 로직을 여러차례 반복하게 되는 단점도 있다. (N + 1 problem)</p>\n<blockquote>\n<p><strong>N + 1 problem</strong></p>\n<p>사용자 레코드를 조회 할 때 사용자를 조회하기 위한 쿼리 1회 + 사용자와 관계를 맺고 있는 회사 레코드를 조회하는 쿼리 N 회가 발생하는 문제로 동일한 쿼리일 가능성이 높은 N회의 쿼리가 반복적으로 발생하는 문제</p>\n<p><a href=\"https://github.com/graphql/dataloader\">DataLoader</a>와 같은 라이브러리를 이용해 caching, 또는 batch 처리 등의 방법으로 N + 1 problem으로 인해 발생하는 비효율성을 개선하기도 한다.</p>\n</blockquote>\n<h2 id=\"typegraphql\">TypeGraphQL</h2>\n<p>GraphQL을 이용한 프로젝트를 구성하다 보면 type 정의, resolver 정의 그리고 entity, interface 등 상당히 많은 파일들을 생성해내야 한다.</p>\n<p>프로젝트 구조가 복잡해지거니와 유사한 형태의 파일들을 반복적으로 작성해야하는 것은 번거로운 일이다.</p>\n<p>TypeGraphQL은 이런 번거로움을 해결하기 위한 라이브러리로 class를 정의하는 것을 통해 entity와 GraphQL type의 정의를 동시에 처리 할 수 있도록 돕는다.</p>\n<h3 id=\"디펜던시-설치\">디펜던시 설치</h3>\n<p>TypeGraphQL을 사용하기 위해 필요한 디펜던시를 설치한다.</p>\n<pre><code class=\"language-bash\">$ npm i graphql class-validator type-graphql\n</code></pre>\n<h3 id=\"tsconfig-configuration\">tsconfig configuration</h3>\n<pre><code class=\"language-json\">{\n  &quot;target&quot;: &quot;es2018&quot;, // type-graphql이 es2018 spec에 의존하고 있다\n  &quot;emitDecoratorMetadata&quot;: true, // decorator를 사용하기 위해 true로 설정\n  &quot;experimentalDecorators&quot;: true // decorator를 사용하기 위해 true로 설정\n}\n</code></pre>\n<h3 id=\"class-정의\">Class 정의</h3>\n<p>class 정의를 통해 GraphQL의 type과 typescript의 interface 역할을 수행할 객체를 정의 할 수 있다.</p>\n<pre><code class=\"language-typescript\">// entities/User.ts\n\nimport { Field, ID, ObjectType } from &#39;type-graphql&#39;\n\n@ObjectType()\nexport class User {\n  @Field((type) =&gt; ID)\n  id!: number\n\n  @Field()\n  name!: string\n\n  @Field()\n  age!: number\n}\n</code></pre>\n<h3 id=\"resolver-정의\">Resolver 정의</h3>\n<p>resolver 또한 class 형식으로 정의 할 수 있다.</p>\n<pre><code class=\"language-typescript\">import { Arg, Query, Resolver } from &#39;type-graphql&#39;\nimport { User } from &#39;../entities/User&#39;\n\nlet dummyUsers = Array.from({ length: 20 }, (_, idx) =&gt; {\n  return {\n    id: idx + 1,\n    name: `Sample User ${idx + 1}`,\n    age: Math.floor(Math.random() * 20),\n    companyId: (idx % 3) + 1,\n  }\n}) as User[]\n\n@Resolver()\nexport class UserResolver {\n  @Query((returns) =&gt; User)\n  user(@Arg(&#39;name&#39;) name: string) {\n    const foundUser = dummyUsers.find((user) =&gt; user.name === name) || null\n    if (!foundUser) throw new Error(&#39;No user found&#39;)\n\n    return foundUser\n  }\n\n  @Query((returns) =&gt; [User])\n  users() {\n    return dummyUsers\n  }\n}\n</code></pre>\n<blockquote>\n<p>TypeGraphQL을 통해 resolver를 정의할 경우 반환 타입에 대한 validation이 더 엄격해진다. <code>null</code> 을 반환 할 수 없는 <code>Query</code> 의 경우 반환할 결과물이 없을 경우 <code>null</code> 또는 <code>undefined</code> 를 리턴하지 않도록 에러 처리를 해줘야한다.</p>\n</blockquote>\n<h3 id=\"schema-생성하기\">Schema 생성하기</h3>\n<p>이렇게 정의한 <code>resolver</code>를 통해 schema를 생성해야 한다. 생성된 schema는 Apollo Server를 실행할 때 전달되는 <code>config</code> 로 사용 된다.</p>\n<pre><code class=\"language-typescript\">// app.ts\n\nimport { ApolloServer } from &#39;apollo-server&#39;\nimport &#39;reflect-metadata&#39;\nimport { buildSchema } from &#39;type-graphql&#39;\nimport { UserResolver } from &#39;./resolvers/User&#39;\n\nbuildSchema({\n  resolvers: [UserResolver],\n}).then((schema) =&gt; {\n  const server = new ApolloServer({ schema })\n\n  server.listen(8080).then(() =&gt; {\n    console.log(&#39;Apollo Server is running on 8080&#39;)\n  })\n})\n</code></pre>\n<blockquote>\n<p><code>&#39;reflect-metadata&#39;</code> 를 import 해야한다. schema 생성시 해당 모듈에 의존하기 때문이다.</p>\n</blockquote>\n<h3 id=\"그-밖의-설정들\">그 밖의 설정들</h3>\n<p>그 밖의 설정들은 <a href=\"https://typegraphql.com/docs/introduction.html\">공식 문서를</a> 참조한다.</p>\n","postsByCategory":[]},"__N_SSG":true}