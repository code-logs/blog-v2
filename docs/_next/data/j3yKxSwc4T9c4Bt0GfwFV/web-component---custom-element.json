{"pageProps":{"post":{"title":"Web component - custom element","description":"웹 컴포넌트로 만드는 나만의 custom element","fileName":"web-component-web-component---custom-element.md","category":"web-component","published":true,"publishedAt":"2022-07-31","thumbnailName":"1b85d15d3e19b99e3d6350d8b69cc39a","tags":["Shadow DOM","shadow"],"references":[{"title":"Custom element naming convention","url":"https://html.spec.whatwg.org/#valid-custom-element-name"},{"title":"WebComponent org","url":"https://www.webcomponents.org/"},{"title":"https://web.dev/custom-elements-v1/#custom-element-reactions","url":"https://web.dev/custom-elements-v1/#custom-element-reactions"}],"series":{"nextPostTitle":"Web component - Shadow DOM"},"order":18},"content":"<h2 id=\"table-of-contents\">Table of contents</h2>\n<ol>\n<li><a href=\"#%EC%9B%B9-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8\">웹 컴포넌트</a><ol>\n<li><a href=\"#why-webcomponent\">Why webcomponent?</a></li>\n</ol>\n</li>\n<li><a href=\"#%EC%BB%A4%EC%8A%A4%ED%85%80-%EC%97%98%EB%A6%AC%EB%A8%BC%ED%8A%B8\">커스텀 엘리먼트</a><ol>\n<li><a href=\"#%EC%BB%A4%EC%8A%A4%ED%85%80-%EC%97%98%EB%A6%AC%EB%A8%BC%ED%8A%B8-%EB%93%B1%EB%A1%9D%ED%95%98%EA%B8%B0\">커스텀 엘리먼트 등록하기</a></li>\n<li><a href=\"#%EC%83%9D%EB%AA%85%EC%A3%BC%EA%B8%B0\">생명주기</a></li>\n</ol>\n</li>\n<li><a href=\"#custom-form\">custom-form</a><ol>\n<li><a href=\"#custom-form-%EB%93%B1%EB%A1%9D%ED%95%98%EA%B8%B0\">custom-form 등록하기</a></li>\n<li><a href=\"#custom-form-%EB%82%B4%EB%B6%80-%EB%A9%94%EC%84%9C%EB%93%9C-%EC%A0%95%EC%9D%98%ED%95%98%EA%B8%B0\">custom-form 내부 메서드 정의하기</a></li>\n<li><a href=\"#custom-form-HTML%EC%97%90%EC%84%9C-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0\">custom-form HTML에서 사용하기</a></li>\n</ol>\n</li>\n<li><a href=\"#counter-button\">counter-button</a><ol>\n<li><a href=\"#counter-button-%EB%93%B1%EB%A1%9D%ED%95%98%EA%B8%B0\">counter-button 등록하기</a></li>\n<li><a href=\"#counter-button-%EB%82%B4%EB%B6%80-%EB%A9%94%EC%84%9C%EB%93%9C-%EC%A0%95%EC%9D%98%ED%95%98%EA%B8%B0\">counter-button 내부 메서드 정의하기</a></li>\n<li><a href=\"#counter-button-property%EB%A5%BC-%ED%86%B5%ED%95%B4-%EC%BB%A4%EC%8A%A4%ED%85%80-%EC%97%98%EB%A6%AC%EB%A8%BC%ED%8A%B8-%EA%B0%92-%EB%B3%80%EA%B2%BD%ED%95%98%EA%B8%B0\">counter-button Property를 통해 커스텀 엘리먼트 값 변경하기</a></li>\n<li><a href=\"#counter-button-html%EC%97%90%EC%84%9C-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0\">counter-button HTML에서 사용하기</a></li>\n</ol>\n</li>\n<li><a href=\"#%EB%A7%88%EC%B9%98%EB%A9%B0\">마치며</a></li>\n</ol>\n<h2 id=\"웹-컴포넌트\">웹 컴포넌트</h2>\n<p>웹 컴포넌트는 존재하는 HTML <code>태그를 확장</code>하여 새로운 기능을 추가하고 <code>캡슐화</code>를 통해 외부 요소로 부터 독립적인 커스텀 엘리먼트를 제작하기 위한 웹 API의 모음이다.</p>\n<p>웹 컴포넌트는 <code>웹 표준</code>을 따르기 때문에 대부분의 모던 브라우저에서 문제 없이 동작한다. 지금도 꾸준히 표준을 잡아가고 있으며 브라우저 <code>spec</code>이 계속해서 정립되고 있다.</p>\n<h3 id=\"why-webcomponent\">Why Webcomponent?</h3>\n<ul>\n<li>웹 컴포넌트는 <code>캡슐화</code>를 통해 기본적으로 외부 요소와 독립적으로 존재한다.</li>\n</ul>\n<p>웹 컴포넌트 API를 통해 정의된 커스텀 엘리먼트는 캡슐화되어 존재하기 때문에 외부에서 주입되는 <code>style sheet</code>의 영향을 받지 않는다.\n컴포넌트가 <code>부품</code>으로서의 가치를 갖기 위해서는 어떠한 환경에서 사용 되더라도 동일한 기능과 형태를 유지해야 한다. 이런 관점에서 웹 컴포넌트로 생성된 커스텀 엘리먼트는 <code>shadow root</code>라는 영역에 독립적으로 존재하며 외부의 <code>style sheet</code>에 의해 형태가 변형되지 않는다.</p>\n<blockquote>\n<p>물론 필요에 따라 외부의 style sheet의 영향을 받도록 설정할 수 있다.</p>\n</blockquote>\n<p>더불어 커스텀 엘리먼트 내부에서 발생하는 이벤트의 버블링은 기본적으로 <code>shadow root</code>를 벗어 날 수 없다. 이는 이벤트 버블링에 의해 야기될 수 있는 사이드 이펙트를 방지 할 수 있도록 돕는다.</p>\n<ul>\n<li>표준 API를 사용해 어떤 라이브러리 또는 프레임워크를 통해 구성된 웹 앱에서도 동작 할 수 있다.</li>\n</ul>\n<p>웹 표준 API를 통해 구현되는 커스텀 엘리먼트는 사용자의 브라우저 환경이 이를 지원한다면 (대부분의 모던 브라우저가 지원하고 있다.) 별도의 라이브러리에 의존하지 않는다. 다시말해 <code>React</code>로 구성 되었건 <code>Vue</code>로 구성 되었건 화면의 일부 요소는 얼마든지 <code>custom element</code>로 구현 할 수 있다.\n<code>어떤 환경에서도 사용 할 수 있는 것</code> 또한 컴포넌트로서의 가치를 증가 시킬수 있는 요소다.</p>\n<h2 id=\"커스텀-엘리먼트\">커스텀 엘리먼트</h2>\n<p>커스텀 엘리먼트는 <code>CustomElementRegistry</code> 객체를 통해 제어 할 수 있다. <code>CustomElementRegistry</code> 객체의 <code>define</code> 메서드를 통해 새로운 커스텀 엘리먼트를 등록하게 된다.</p>\n<p>커스텀 엘리먼트는 반드시 <code>kebab-case</code> 형식의 명칭을 사용해야 하는데 이는 미래에 추가될 <code>html</code> 네이티브 태그와 구분하기 위함이다. (새롭게 추가될 html 태그는 절대 <code>-</code>을 포함하지 않을 것이기 때문에) - <a href=\"https://html.spec.whatwg.org/#valid-custom-element-name\">Custom element naming convention</a></p>\n<h3 id=\"커스텀-엘리먼트-등록하기\">커스텀 엘리먼트 등록하기</h3>\n<pre><code class=\"language-javascript\">window.customElements.define(&#39;custom-element&#39;, CustomElement)\n\n// or\n\nwindow.customElements.define(&#39;custom-element&#39;, CustomElement, { extends: &#39;form&#39; })\n</code></pre>\n<p><code>define</code> 메서드는 다음 세가지의 매개변수를 전달 받을 수 있다.</p>\n<ul>\n<li>DOMString: 커스텀 엘리먼트의 이름</li>\n<li>class 객체: 커스텀 엘리먼트의 동작을 정의한 <code>class</code> 객체</li>\n<li><code>optional</code> extends 속성: 현재 커스텀 엘리먼트가 상속 받는 대상 태그</li>\n</ul>\n<h3 id=\"생명주기\">생명주기</h3>\n<p>커스텀 엘리먼트를 등록하기 위해 동작에 대한 정의를 담고 있는 class 객체를 생성해야한다.\nclass 객체는 생명주기를 갖고 있으며 생명주기에 따라 적절한 동작을 정의해야한다.</p>\n<ul>\n<li>constructor: 커스텀 엘리먼트의 인스턴스가 생성될 때마다 호출됨</li>\n<li>connectedCallback: 커스텀 엘리먼트가 <code>document</code>에 추가될 때마다 호출됨</li>\n<li>disconnectedCallback: 커스텀 엘리먼트가 <code>document</code>에서 제거 될 때마다 호출됨</li>\n<li>adoptedCallback: 커스텀 엘리먼트가 새로운 <code>document</code>로 이동할 때마다 호출됨</li>\n<li>attributeChangedCallback: 커스텀 엘리먼트의 attribute가 변화할 때 마다 호출됨</li>\n</ul>\n<p>이런 생명주기를 통해 이벤트 리스너를 등록/제거 하거나 특정 속성의 변화에 따른 동작을 구현할 수 있고 데이터 패칭과 같이 컴포넌트 초기화 시점에 필요한 상태들을 설정할 때 사용할 수 있다. - <a href=\"https://web.dev/custom-elements-v1/#custom-element-reactions\">https://web.dev/custom-elements-v1/#custom-element-reactions</a></p>\n<blockquote>\n<p>attributeChangedCallback(attrName, oldVal, newVal)</p>\n<p><code>attributeChangedCallback</code>은 상기와 같은 매개변수를 전달 받는다. 이렇게 attributeChangedCallback을 통해 관리 돼야하는 <code>attribute</code>는 반드시 객체 내부의 <code>observedAttributes</code> 배열로 작성되어야 한다.</p>\n</blockquote>\n<h2 id=\"custom-form\">custom-form</h2>\n<p>앞서 살펴본 커스텀 엘리먼트의 기본적인 요소들을 바탕으로 <code>custom-form</code>을 작성한다.\n<code>custom-form</code>은 기존 <code>form</code> 태그를 상속 받아 <code>serialize</code>라는 내부 메서드를 갖는다.</p>\n<p><code>serialize</code> 메서드는 <code>form</code> 내부에 정의된 입력 요소들 (<code>input</code>, <code>select</code>, <code>textarea</code> 와 같은)의 값을 추출하고 입력된 <code>type</code>에 따라 값을 변형하여 return하는 역할을 하게 된다.</p>\n<h3 id=\"custom-form-등록하기\">custom-form 등록하기</h3>\n<pre><code class=\"language-javascript\">class CustomForm extends HTMLFormElement {}\n\nwindow.customElements.define(&#39;custom-form&#39;, CustomForm, { extends: &#39;form&#39; })\n</code></pre>\n<h3 id=\"custom-form-내부-메서드-정의하기\">custom-form 내부 메서드 정의하기</h3>\n<pre><code class=\"language-javascript\">class CustomForm extends HTMLFormElement {\n  serialize() {\n    const elements = Array.from(this.querySelectorAll(&#39;input,select,textarea&#39;))\n    if (elements.some((element) =&gt; !element.name)) {\n      throw new Error(&#39;Failed to find field name&#39;)\n    }\n\n    let result = {}\n\n    elements.forEach(({ name, type, value, checked }) =&gt; {\n      switch (type) {\n        case &#39;number&#39;:\n          result[name] = Number(value)\n          break\n\n        case &#39;checkbox&#39;:\n          result[name] = checked\n          break\n\n        default:\n          result[name] = value\n      }\n    })\n\n    return result\n  }\n}\n\nwindow.customElements.define(&#39;custom-form&#39;, CustomForm, { extends: &#39;form&#39; })\n</code></pre>\n<p><code>CustomForm</code> class 내부에 <code>serialize</code>라는 명칭의 메서드를 정의한다. <code>form</code> 내부에 존재하는 입력 요소들을 찾아 필드 명칭을 확인하고 데이터 유형에 따라 변형한 값을 객체에 담아 반환한다.</p>\n<h3 id=\"custom-form-html에서-사용하기\">custom-form HTML에서 사용하기</h3>\n<pre><code class=\"language-html\">...\n\n&lt;script defer src=&quot;./custom-form.js&quot;&gt;&lt;/script&gt;\n\n...\n\n&lt;form id=&quot;custom-form&quot; is=&quot;custom-form&quot;&gt;\n  &lt;input type=&quot;text&quot; name=&quot;text&quot; /&gt;\n  &lt;input type=&quot;number&quot; name=&quot;number&quot; /&gt;\n  &lt;input type=&quot;date&quot; name=&quot;date&quot; /&gt;\n  &lt;input type=&quot;checkbox&quot; name=&quot;checkbox&quot; /&gt;\n  &lt;textarea name=&quot;textarea&quot;&gt;&lt;/textarea&gt;\n  &lt;select name=&quot;option&quot;&gt;\n    &lt;option&gt;Option 1&lt;/option&gt;\n    &lt;option&gt;Option 2&lt;/option&gt;\n    &lt;option&gt;Option 3&lt;/option&gt;\n  &lt;/select&gt;\n&lt;/form&gt;\n\n...\n\n&lt;script&gt;\n  const formData = document.querySelector(&#39;#custom-form&#39;).serialize()\n  console.log(formData)\n&lt;/script&gt;\n</code></pre>\n<p>예제에서 처럼 기존의 HTML 태그를 상속 받아 사용할 경우 <code>is</code> 속성을 통해 사용하고자 하는 커스텀 엘리먼트의 명칭을 입력한다.</p>\n<h2 id=\"counter-button\">counter-button</h2>\n<p>버튼을 클릭하면 숫자가 올라가는 간단한 커스텀 엘리먼트를 작성한다. 기존에 존재하는 태그의 기능을 상속 받지 않는 완전히 새로운 형태의 커스텀 엘리먼트다.</p>\n<h3 id=\"counter-button-등록하기\">counter-button 등록하기</h3>\n<pre><code class=\"language-javascript\">class CounterButton extends HTMLElement {}\n\nwindow.customElements.define(&#39;counter-button&#39;, CounterButton)\n</code></pre>\n<h3 id=\"counter-button-내부-메서드-정의하기\">counter-button 내부 메서드 정의하기</h3>\n<p><code>constructor</code>가 호출되는 시점에 <code>counter-button</code>의 shadowRoot 생성하고 shadowRoot 아래에 캡슐화된 UI 요소들을 삽입한다.</p>\n<pre><code class=\"language-javascript\">class CounterButton extends HTMLElement {\n  constructor() {\n    super()\n    this.attachShadow({ mode: &#39;open&#39; })\n    this.shadowRoot.innerHTML = `\n      &lt;style&gt;\n        span {\n          font-size: 20px;\n        }\n      &lt;/style&gt;\n\n      &lt;span id=&quot;display&quot;&gt;&lt;/span&gt;\n      &lt;button id=&quot;button&quot;&gt;+&lt;/button&gt;\n    `\n  }\n}\n\nwindow.customElements.define(&#39;counter-button&#39;, CounterButton)\n</code></pre>\n<p><code>connectedCallback</code> 라이프 사이클을 통해 버튼 엘리먼트에 이벤트 리스너를 등록한다.\n<code>getter</code>를 정의해서 커스텀 엘리먼트 내부의 요소에 쉽게 접근 할 수 있도록 한다.</p>\n<pre><code class=\"language-javascript\">class CounterButton extends HTMLElement {\n  constructor() {\n    super()\n    this.attachShadow({ mode: &#39;open&#39; })\n    this.shadowRoot.innerHTML = `\n      &lt;style&gt;\n        span {\n          font-size: 20px;\n        }\n      &lt;/style&gt;\n\n      &lt;span id=&quot;display&quot;&gt;&lt;/span&gt;\n      &lt;button id=&quot;button&quot;&gt;+&lt;/button&gt;\n    `\n  }\n\n  get display() {\n    return this.shadowRoot.querySelector(&#39;#display&#39;)\n  }\n\n  get button() {\n    return this.shadowRoot.querySelector(&#39;#button&#39;)\n  }\n\n  connectedCallback() {\n    if (this.isConnected) {\n      this.button.addEventListener(&#39;click&#39;, () =&gt; {\n        this.buttonClickHandler()\n      })\n    }\n  }\n\n  buttonClickHandler() {\n    const currentNumber = this.display.textContent ? Number(this.display.textContent) : 0\n    this.display.textContent = currentNumber + 1\n  }\n}\n\nwindow.customElements.define(&#39;counter-button&#39;, CounterButton)\n</code></pre>\n<h3 id=\"counter-button-property를-통해-커스텀-엘리먼트-값-변경하기\">counter-button Property를 통해 커스텀 엘리먼트 값 변경하기</h3>\n<pre><code class=\"language-javascript\">class CounterButton extends HTMLElement {\n  constructor() {\n    super()\n    this.attachShadow({ mode: &#39;open&#39; })\n    this.shadowRoot.innerHTML = `\n      &lt;style&gt;\n        span {\n          font-size: 20px;\n        }\n      &lt;/style&gt;\n\n      &lt;span id=&quot;display&quot;&gt;&lt;/span&gt;\n      &lt;button id=&quot;button&quot;&gt;+&lt;/button&gt;\n    `\n  }\n\n  get display() {\n    return this.shadowRoot.querySelector(&#39;#display&#39;)\n  }\n\n  get button() {\n    return this.shadowRoot.querySelector(&#39;#button&#39;)\n  }\n\n  connectedCallback() {\n    if (this.isConnected) {\n      this.button.addEventListener(&#39;click&#39;, () =&gt; {\n        this.buttonClickHandler()\n      })\n    }\n  }\n\n  attributeChangedCallback(props, oldValue, newValue) {\n    if (props === &#39;count&#39;) {\n      this.countChangeHandler(newValue)\n    }\n  }\n\n  static get observedAttributes() {\n    return [&#39;count&#39;]\n  }\n\n  buttonClickHandler() {\n    const currentNumber = this.display.textContent ? Number(this.display.textContent) : 0\n    this.display.textContent = currentNumber + 1\n  }\n\n  countChangeHandler(newValue) {\n    this.display.textContent = newValue\n  }\n}\n\nwindow.customElements.define(&#39;counter-button&#39;, CounterButton)\n</code></pre>\n<p><code>attributeChangedCallback</code>과 <code>observedAttributes</code> 메서드를 구현하여 커스텀 엘리먼트의 <code>attribute</code>의 변화를 감지하고 값을 반영 할 수 있도록 한다.</p>\n<h3 id=\"counter-button-html에서-사용하기\">counter-button HTML에서 사용하기</h3>\n<pre><code class=\"language-html\">...\n\n&lt;script defer src=&quot;./counter-button.js&quot;&gt;&lt;/script&gt;\n\n...\n\n&lt;counter-button&gt;&lt;/counter-button&gt;\n\n&lt;!-- or --&gt;\n\n&lt;counter-button count=&quot;20&quot;&gt;&lt;/counter-button&gt;\n\n...\n</code></pre>\n<h2 id=\"마치며\">마치며</h2>\n<p>커스텀 엘리먼트를 만드는 방법에 대해 간단하게 정리했다. Web Component의 주요 개념을 이해하기 위해서는 <code>shadow dom</code>에 대한 이해도 필요하다고 생각한다.\n다른 포스팅을 통해 <code>shadow dom</code>에 대해 정리해야겠다.</p>\n","postsByCategory":[{"title":"Web component - slot","description":"<slot> 태그를 이용해 커스텀 엘리먼트에 자식 엘리먼트를 주입할 수 있는 방법을 소개 합니다.\n<slot> 태그를 이용해 조금더 유연한 형태의 dialog 커스텀 엘리먼트를 만들기\n","fileName":"web-component-web-component---slot.md","category":"web-component","published":true,"publishedAt":"2022-08-18","thumbnailName":"c96f4eff2512178b9b4e02d5aad66827","tags":["custom dialog","custom element","dialog","slot","web component","웹 컴포넌트","커스텀 엘리먼트"],"references":[{"title":"MDN - Using templates and slots","url":"https://developer.mozilla.org/en-US/docs/Web/Web_Components/Using_templates_and_slots"},{"title":"MDN - slot","url":"https://developer.mozilla.org/ko/docs/Web/HTML/Element/slot"},{"title":"MDN - pseudo-elements","url":"https://developer.mozilla.org/en-US/docs/Web/CSS/Pseudo-elements"}],"series":{"prevPostTitle":"Web component - Shadow DOM"},"order":23},{"title":"Web component - Shadow DOM","description":"Web component의 핵심인 encapsulation은 어떻게 이루어질까?\nShadow DOM의 이해","fileName":"web-component-web-component---shadow-dom.md","category":"web-component","published":true,"publishedAt":"2022-08-10","thumbnailName":"752fbf06b172dc96f8f10c87b1d91872","tags":["Shadow DOM","custom element","encapsulation","shadow","shadow tree","web component","쉐도우","쉐도우 돔","쉐도우 트리","웹 컴포넌트","은닉화","커스텀 엘리먼트"],"references":[{"title":"MDN - Composed","url":"https://developer.mozilla.org/en-US/docs/Web/API/Event/composed"},{"title":"MDN - Using shadow DOM","url":"https://developer.mozilla.org/ko/docs/Web/Web_Components/Using_shadow_DOM"}],"series":{"prevPostTitle":"Web component - custom element","nextPostTitle":"Web component - slot"},"order":22}],"enableContentExplorer":true},"__N_SSG":true}