{"pageProps":{"post":{"title":"Nx build system 맛보기","fileName":"monorepo-with-nx.md","description":"Nx build system을 이용한 Monorepo 구성하기","category":"infrastructure","published":true,"publishedAt":"2022-02-12","tags":["nx","build","build system","monorepo","빌드","빌드 시스템","모노리포"],"thumbnailName":"monorepo-with-nx.png"},"content":"<h2 id=\"table-of-contents\">Table of contents</h2>\n<ol>\n<li><a href=\"#monorepo\">Monorepo</a></li>\n<li><a href=\"#nx\">Nx</a></li>\n<li><a href=\"#nx-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-%EA%B5%AC%EC%84%B1%ED%95%98%EA%B8%B0\">Nx 프로젝트 구성하기</a><ol>\n<li><a href=\"#%EC%83%88%EB%A1%9C%EC%9A%B4-workspace-%EC%83%9D%EC%84%B1\">새로운 Workspace 생성</a></li>\n<li><a href=\"#npm-package-%EC%83%9D%EC%84%B1\">NPM Package 생성</a></li>\n<li><a href=\"#package-%EB%82%B4%EB%B6%80-script-%EC%8B%A4%ED%96%89\">Package 내부 script 실행</a></li>\n<li><a href=\"#%EC%97%AC%EB%9F%AC-package-%EB%82%B4%EB%B6%80-script-%EC%8B%A4%ED%96%89\">여러 Package 내부 script 실행</a></li>\n<li><a href=\"#package%EA%B0%84-%EC%B0%B8%EC%A1%B0-%EC%84%A4%EC%A0%95\">Package간 참조 설정</a></li>\n<li><a href=\"#nx-graph\">NX Graph</a></li>\n</ol>\n</li>\n<li><a href=\"#generator\">Generator</a><ol>\n<li><a href=\"#typescript-library-generator\">Typescript Library Generator</a></li>\n<li><a href=\"#react-library-generator\">React Library Generator</a></li>\n</ol>\n</li>\n<li><a href=\"#%EB%A7%88%EC%B9%98%EB%A9%B0\">마치며</a></li>\n</ol>\n<h2 id=\"monorepo\">Monorepo</h2>\n<p><code>Monorepo</code>는 방대한 양의 프로젝트 코드를 단일 Repository에서 관리하는 전략이다. 개인적으로 4년 전쯤 (2022년 기준) 처음 도입해서 사용했는데, 프론트엔드 개발자로서 컴퍼넌트 개발을 많이했고 각 컴퍼넌트들이 분산된 저장소에서 관리됨으로 발생하는 문제점들을 획기적으로 개선하는 경험을 했다.</p>\n<p>그 이후 라이브러리 성향의 프로젝트를 구성할 경우에는 <code>Monorepo</code>를 필수적으로 체택하게 되었다.</p>\n<p>처음 <code>Monorepo</code>를 도입한 뒤 감동은 말 그대로 <code>신세계</code>를 보는 듯 했으나 이것도 사실 20년도 <a href=\"https://en.wikipedia.org/wiki/Monorepo\">&quot;As of 2017, this software engineering practice was over two decades old&quot; - wiki</a> 훌쩍 넘긴 것이라 하니 여전히 공부해야 할 것들이 넘쳐난다는 생각이 든다</p>\n<h2 id=\"nx\">Nx</h2>\n<p>나에게 익숙한 <code>Monorepo</code> 구성은 <code>lerna</code>를 이용한 구성이였는데\n이번 포스팅에서는 <code>Monorepo</code> 구성뿐 아니라 프로젝트 빌드의 전반적인 프로세스를 돕는 <code>Nx</code> 빌드 시스템을 살펴본다.</p>\n<div style=text-align:center><a href=https://nx.dev target=_blank>Nx 홈페이지 바로가기</a></div>\n\n<p><code>Nx</code>는 <code>Nrwl (Narwhal Technologies Inc)</code>에 의해 만들어진 시스템이다.</p>\n<p><code>Nrwl</code>은 Google의 Angular 팀 멤버에 의해 만들어진 법인으로 세계 여러 국가의 IT 컨설팅 외 다수의 작업을 하는 것으로 보인다. <a href=\"https://nrwl.io/\">Nrwl</a></p>\n<h2 id=\"nx-프로젝트-구성하기\">Nx 프로젝트 구성하기</h2>\n<h3 id=\"새로운-workspace-생성\">새로운 Workspace 생성</h3>\n<p>아래의 커맨드를 통해 새로운 workspace를 생성한다</p>\n<pre><code class=\"language-sh\">npx create-nx-workspace@latest --preset=core\n</code></pre>\n<blockquote>\n<p><code>--preset=core</code> 옵션은 npm 패키지를 위한 빈 (yarn workspace와 유사한) 워크스페이스를 생성한다.</p>\n<p>상기 옵션 없이 커맨드를 실행 할 경우 몇가지 옵션을 선택 할 수 있고 구성하려는 프로젝트의 성향에 맞게 preset을 선택 할 수 있다.</p>\n</blockquote>\n<p>커맨드를 실행하면 디렉토리를 생성하고 필요한 설정이 담긴 파일들이 만들어진다.</p>\n<p>생성된 파일중 <code>nx.json</code> 파일을 통해 <code>nx</code>의 설정을 진행 할 수 있다.</p>\n<h3 id=\"npm-package-생성\">NPM Package 생성</h3>\n<p>아래의 커맨드를 통해 새로운 패키지(sample)를 workspace에 추가 할 수 있다.</p>\n<pre><code class=\"language-sh\">nx g npm-package sample\n</code></pre>\n<p>이렇게 생성된 패키지의 <code>package.json</code> 파일을 열어 보면</p>\n<pre><code class=\"language-json\">{\n  &quot;name&quot;: &quot;@nx-sample-workspace/sample&quot;,\n  &quot;version&quot;: &quot;0.0.0&quot;,\n  &quot;scripts&quot;: {\n    &quot;test&quot;: &quot;node index.js&quot;\n  }\n}\n</code></pre>\n<p>패키지의 명칭이 @nx-sample-worspace로 설정되어 있다. 처음 Workspace를 생성할 때 입력이 organization으로 결정되니 Workspace 생성 시점에 이를 고려해야한다.</p>\n<h3 id=\"package-내부-script-실행\">Package 내부 script 실행</h3>\n<p>패키지 내부에 정의된 script를 실행하기 위해 아래의 커맨드를 입력한다.</p>\n<pre><code class=\"language-sh\">nx ${script} ${package}\n</code></pre>\n<blockquote>\n<p><code>yarn</code>과 <code>lerna</code>로 구성한 monorepo에서는</p>\n<p><code>yarn workspace ${package} ${script}</code></p>\n<p>형식으로 스크립트를 실행 할 수 있는데 <code>${package}</code>를 <code>@nx-sample-workspace/sample</code>과 같이 패키지의 이름 전체를 입력해야 한다.</p>\n</blockquote>\n<h3 id=\"여러-package-내부-script-실행\">여러 Package 내부 script 실행</h3>\n<p>빌드를 실행하거나 테스트 커맨드를 실행하는 등 전체 또는 복수의 package를 대상으로 script를 실행하려면 아래의 커맨드를 입력한다.</p>\n<pre><code class=\"language-sh\">nx run-many --target=${script} --all\n</code></pre>\n<blockquote>\n<p>특정 패키지를 대상으로 스크립트를 실행하려면 <code>--all</code> 옵션 대신 <code>--projects=package1,package2</code> 옵션을 추가한다.</p>\n</blockquote>\n<p>이렇게 실행한 scripts는 비동기적으로 평행하게 수행된다.</p>\n<h3 id=\"package간-참조-설정\">Package간 참조 설정</h3>\n<p><code>Monorepo</code> 구성 내부에서 컴퍼넌트를 개발하다 보면 종종 컴퍼넌트간의 참조가 발생한다. <code>Monorepo</code>의 도입을 통해 얻을 수 있는 장점중 하나가 참조하고 있는 컴퍼넌트의 완전한 <code>publishing</code> 없이 변경 사항을 적용하고 테스트 할 수 있다는 것이기도 하다.</p>\n<blockquote>\n<p>만약 A 모듈이 B 모듈을 참조하고 있을때 이 둘이 각기 별도의 Repository로 구성되어 있을 경우 A 모듈을 수정하던중 B 모듈의 문제점을 발견하게 되면</p>\n<p><code>B 모듈을 수정 -&gt; B 모듈 Publishing -&gt; A 모듈의 디펜던시 최신화 -&gt; A 모듈 작업 재개</code>의 순으로 작업을 하게 되는데 (<code>yarn link</code>를 사용하는 방법도 있지만) <code>monorepo</code> 내부에서 패키지간의 참조는 별도의 publishing 없이도 최신화된 로컬 소스를 참조 할 수 있다.</p>\n</blockquote>\n<p>패키지간의 참조 설정을 위해 또 다른 패키지를 생성한다.</p>\n<pre><code class=\"language-sh\">nx g npm-package rely-on-sample\n</code></pre>\n<p><code>packages/rely-on-sample/index.js</code>를 열어 <code>sample</code> 패키지를 참조하도록 아래와 같이 수정한다.</p>\n<pre><code class=\"language-js\">// index.js\nimport &#39;@nx-sample-workspace/sample&#39;\n\nconsole.log(&#39;Hello World&#39;)\n</code></pre>\n<p>참조 대상을 불러오기 위해 <code>rely-on-sample</code> 패키지의 <code>package.json</code>에 디펜던시를 추가한다.</p>\n<blockquote>\n<p><code>@nx-sample-worspace/sample</code> 패키지는 아직 publishing 되지 않은 상태이기 때문에 커맨드를 통해 추가 할 수 없다.</p>\n<p>직접 <code>package.json</code> 파일을 수정한 뒤 <code>yarn install</code> 또는 <code>npm install</code>을 통해 패키지를 최신화해야 한다.</p>\n</blockquote>\n<h2 id=\"nx-graph\">NX Graph</h2>\n<p>아래의 커맨드를 실행하면 헌재 Workspace에 존재하는 패키지간의 상관관계를 볼 수 있는 dashboard를 실행 할 수 있다.</p>\n<pre><code class=\"language-sh\">nx graph\n</code></pre>\n<h2 id=\"generator\">Generator</h2>\n<p><code>Nx</code>는 Generator를 이용해서 다양한 환경의 라이브러리/애플리케이션을 스카폴딩 할 수 있도록 돕는다.\n몇가지 유용한 Generator를 살펴본다.</p>\n<h3 id=\"typescript-library-generator\">Typescript Library Generator</h3>\n<p>타입스크립트 기반의 라이브러리 패키지를 생성하기 위해 사용 할 수 있는 <code>Generator</code>로 <code>jest</code>, <code>lint</code>와 빌드환경을 모두 갖춘 패키지를 생성한다.</p>\n<p><code>devDependency</code>로 <code>@nrwl/js</code> 패키지를 설치한다.</p>\n<p>설치가 완료되면 아래 커맨드를 통해 타입스크립트 기반의 라이브러리를 생성한다.</p>\n<pre><code class=\"language-sh\">nx g @nrwl/js:library ${library name}\n</code></pre>\n<blockquote>\n<p>Typescript 기반의 라이브러리를 생성하는데 <code>@nrwl/js</code>라는 패키지를 설치하는 것은 nx의 generator가 기본적으로 ts를 사용하도록 설정되어 있기 때문이다.</p>\n<p>실제 <code>@nrwl/js</code> 패키지는 타입스크립트 기반의 라이브러를 생성하는 것이 아닌 라이브러리 성향의 패키지 그 자체를 의미하며 <code>--js=false</code> 옵션이 default 값으로 설정되어 있다.</p>\n<p>다시 말해 Javascript 베이스의 라이브러리를 생성하고 싶다면 아래의 커맨드를 입력해야 한다.</p>\n<p>`nx g @nrwl/js:library --js=false</p>\n</blockquote>\n<blockquote>\n<p><code>--buildable 옵션</code></p>\n<p>상기 커맨드를 통해 생성된 라이브러리는 기본적으로 <code>빌드 할 수 없는</code> 형태이다.</p>\n<p><code>--buildable=true</code> 옵션을 추가하는 것을 통해 <code>빌드 할 수 있는</code> 형태의 패키지를 생성할 수 있다..</p>\n</blockquote>\n<p>그 외에도 라이브러리를 생성하며 전달할 수 있는 옵션들이 다수 있으니 공식 문서를 참조하면 조금 더 다채로운 형태의 라이브러리를 생성 할 수 있다.</p>\n<blockquote>\n<p><code>--compiler 옵션</code></p>\n<p>타입스크립트 라이브러리를 생성하며 <code>--compiler=swc</code> 옵션을 추가하면 <code>tsc</code> 대신 <code>swc</code>를 컴파일러로 설정 할 수 있다.</p>\n</blockquote>\n<blockquote>\n<p>SWC (standard for Speedy Web Compiler)</p>\n<p><code>Rust</code> 기반의 웹컴파일러로 기존의 <code>babel</code>과 같은 transpiler에 비해 월등한 성능을 보임.</p>\n<p><code>SWC</code>는 다른 트랜스파일러와 유사하게 <code>typescript</code>의 type checking을 수행하지 않기 때문에 사용하더라도 <code>tsc</code>를 통해 타입체크를 별도로 수행해야한다. 특히 라이브러리 프로젝트의 경우 다른 프로젝트에서 라이브러리의 타입 정보를 체크하기 위해 <code>tsc</code>를 통해 타입선언을 해주는 것이 좋겠다.</p>\n</blockquote>\n<h3 id=\"react-library-generator\">React Library Generator</h3>\n<p>리액트 라이브러리 패키지를 생성하기 위해 <code>@nrwl/react</code> 디펜던시를 설치한다. 패키지 생성 명령은 앞서 살펴본 타입스크립트의 경우와 동일한 형식을 갖는다.</p>\n<pre><code class=\"language-sh\">nx g @nrwl/react:library\n</code></pre>\n<p>타입스크립트 생성과 유사한 <code>linting</code>, <code>testing</code> 환경이 갖춰진 패키지를 생성해낸다.\nReact Library도 기본적으로 타입스크립트 베이스로 생성되며 만약 자바스크립트 베이스의 React 라이브러리를 생성하고자 한다면 <code>--js=false</code> 옵션을 추가해야 한다.</p>\n<h2 id=\"마치며\">마치며</h2>\n<p><code>nx</code>는 패키지를 개발과정의 <code>workflow</code>를 관리하는 툴에 가깝다. <code>lerna</code>와 유사한 기능을 제공할거라고 기대한 (물론 대부분의 기능을 nx도 제공하지만 module publishing이나 versioning은 lerna가 나에게는 더 수월하다는 생각이든다.) 것과는 약간 다른 성격을 가지고 있었다.</p>\n<p>다양한 코드베이스의 프로젝트들을 한군데에서 관리하고 일하는 것 자체의 효율을 높이기 위한 툴이라는 생각이 들었다 (프론트엔드 백엔드를 넘나드는 Scaffolding과 필요한 대부분의 툴이 inject 된 상태의 디렉토리 구조등)</p>\n<p><a href=\"https://stackoverflow.com/questions/67000436/the-difference-between-nx-and-lerna-monorepos\">직접 느꼈으나 말로 표현 할 수 없던 이야기</a>를 누군가 아주 잘 정리해준 글이 있어 첨부한다.</p>\n"},"__N_SSG":true}