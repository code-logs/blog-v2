{"pageProps":{"post":{"title":"Scroll sequence animation","fileName":"scroll-sequence-animation.md","description":"Apple 제품 페이지 같은 애니메이션을 구현해보자 - Scroll sequence animation","category":"UI and UX","published":true,"publishedAt":"2021-10-31","tags":["scroll sequence","scroll sequence animation","ui","ux"],"thumbnailName":"scroll-sequence.png"},"content":"<h2 id=\"table-of-contents\">Table of contents</h2>\n<ol>\n<li><p><a href=\"#scroll-sequence-animation\">Scroll Sequence Animation</a></p>\n</li>\n<li><p><a href=\"#how-to-implement\">How to implement</a></p>\n<ol>\n<li><a href=\"#dom-%EA%B5%AC%EC%A1%B0\">DOM 구조</a></li>\n<li><a href=\"#canvas-element-%EC%83%9D%EC%84%B1\">Canvas element 생성</a></li>\n<li><a href=\"#canvas-api%EB%A5%BC-%ED%86%B5%ED%95%9C-%EC%9D%B4%EB%AF%B8%EC%A7%80-%EA%B7%B8%EB%A6%AC%EA%B8%B0\">Canvas API를 통한 이미지 그리기</a></li>\n<li><a href=\"#scroll-%EC%9D%B4%EB%B2%A4%ED%8A%B8-%EB%93%B1%EB%A1%9D-%EB%B0%8F-%ED%98%84%EC%9E%AC-%ED%94%84%EB%A0%88%EC%9E%84-%EA%B3%84%EC%82%B0\">Scroll 이벤트 등록 및 현재 프레임 계산</a></li>\n<li><a href=\"#%EC%9D%B4%EB%AF%B8%EC%A7%80-%EB%B6%88%EB%9F%AC%EC%98%A4%EA%B8%B0%EC%99%80-%EC%B5%9C%EC%A0%81%ED%99%94\">이미지 불러오기와 최적화</a></li>\n<li><a href=\"#%EC%B4%88%EA%B8%B0-%EC%9D%B4%EB%AF%B8%EC%A7%80-%EA%B7%B8%EB%A6%AC%EA%B8%B0\">초기 이미지 그리기</a></li>\n<li><a href=\"#%EA%B7%B8-%EB%B0%96%EC%9D%98-%EC%B5%9C%EC%A0%81%ED%99%94\">그 밖의 최적화</a></li>\n</ol>\n</li>\n</ol>\n<h2 id=\"scroll-sequence-animation\">Scroll Sequence Animation</h2>\n<div align=center>\n\n<p><a href=\"/examples/scroll-sequence-animation/index.html\">Sample Page</a></p>\n</div>\n\n<p>요즘 많은 사이트에서 <code>Scroll Sequence Animation</code>을 이용한 화면들을 접할 수 있다. 나도 처음 이런 애니메이션 기법을 봤을 때 &#39;오...&#39;라며 감탄했던 기억이 있다.</p>\n<p>처음으로 이 애니메이션을 접한 사이트는 apple의 제품 소개 페이지였던 것으로 기억하는데 그 이후로 종종 다른 사이트에서도 볼 수 있었다.</p>\n<p>동일한 화면을 구현할 일이 없어 &#39;나중에 필요할 때 해보지 뭐&#39;라며 넘겼었는데 며칠 전 문득 포스팅을 하면서 한번 뜯어 봐야겠다는 생각이 들었다.</p>\n<p>대부분의 Apple 제품 소개 페이지에서 볼 수 있는 애니메이션으로 특별히 샘플 이미지나 영상을 첨부하지 않아도 어떤 것인지 기억 할 수 있으리라 생각한다.</p>\n<p>간단히 말로 풀어 정리하면... 사용자가 스크롤을 내리거나 올리는 것을 통해 이미지의 프레임을 앞/뒤로 넘기고 프레임이 넘어감에 따라 이어지는 영상과 같은 효과를 내는 것이 <code>Scroll Sequence Animation</code>이다.</p>\n<h2 id=\"how-to-implement\">How to implement</h2>\n<p>그럼 내친김에 한번 만들어 봐야겠다.</p>\n<p>우선 <code>Scroll Sequence Animation</code>을 구현하기 위해 메커니즘을 정리하고 시작한다.</p>\n<ol>\n<li>고정된 포지션에 이미지가 노출된다.</li>\n<li>노출된 이미지는 스크롤을 움직이더라도 처음 포지션을 그대로 유지한다.</li>\n<li>스크롤이 내려가거나 올라감에 따라 노출된 이미지가 변경된다.<ul>\n<li>스크롤 가능한 영역의 높이와 전체 이미지수를 통해 스크롤 대비 프레임 인덱스를 계산하고 이를 기준으로 이미지를 변경한다</li>\n</ul>\n</li>\n<li>스크롤 가능한 범위를 넘어설 경우 이미지는 더이상 고정되지 않고 화면에서 사라진다<ul>\n<li>이렇게 하지 않을 경우 페이지의 다음 내용을 출력할 수 없을 것이다.</li>\n</ul>\n</li>\n</ol>\n<p>이제 하나씩 순서대로 구현해 보자.</p>\n<h3 id=\"dom-구조\">DOM 구조</h3>\n<pre><code class=\"language-html\">&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;ko&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot; /&gt;\n    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt;\n    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;\n    &lt;title&gt;Scroll Sequence Animation&lt;/title&gt;\n\n    &lt;style&gt;\n      html,\n      body {\n        margin: 0px;\n        width: 100%;\n        height: 100%;\n      }\n\n      main {\n        height: 100%;\n        overflow: auto;\n      }\n\n      .boundary {\n        margin: 0px auto;\n        height: 2400px;\n      }\n\n      .boundary.begin {\n        background: rgb(2, 0, 36);\n        background: linear-gradient(\n          180deg,\n          rgba(2, 0, 36, 1) 0%,\n          rgba(250, 32, 74, 1) 50%,\n          rgba(250, 32, 74, 1) 100%\n        );\n      }\n\n      .boundary.end {\n        background: rgb(2, 0, 36);\n        background: linear-gradient(\n          180deg,\n          rgba(250, 32, 74, 1) 0%,\n          rgba(250, 32, 74, 1) 50%,\n          rgba(2, 0, 36, 1) 100%\n        );\n      }\n\n      #wrapper {\n        margin: 0px auto;\n        height: 3600px;\n        background-color: rgba(250, 32, 74, 1);\n      }\n    &lt;/style&gt;\n\n    &lt;script defer src=&quot;./scroll-sequence.js&quot;&gt;&lt;/script&gt;\n  &lt;/head&gt;\n\n  &lt;body&gt;\n    &lt;main&gt;\n      &lt;div class=&quot;boundary begin&quot;&gt;&lt;/div&gt;\n      &lt;div id=&quot;wrapper&quot;&gt;&lt;/div&gt;\n      &lt;div class=&quot;boundary end&quot;&gt;&lt;/div&gt;\n    &lt;/main&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<ul>\n<li><code>&lt;main&gt;</code> 스크롤이 가능한 전체 영역</li>\n<li><code>&lt;div class=&quot;boundary begin&quot;&gt;&lt;/div&gt;</code> 이미지에 앞서 나타나는 컨텐츠 영역</li>\n<li><code>&lt;div id=&quot;wrapper&quot;&gt;&lt;/div&gt;</code> 이미지가 출력되는 영역으로 해당 영역 내부에서 <code>&lt;canvas&gt;</code>가 생성됨</li>\n<li><code>&lt;div class=&quot;boundary end&quot;&gt;&lt;/div&gt;</code> 이미지에 이어 나타나는 컨텐츠 영역</li>\n</ul>\n<h3 id=\"canvas-element-생성\">Canvas element 생성</h3>\n<p>이제 <code>JavaScript</code> 파일 (<code>scroll-sequence.js</code>)을 생성한다.\n<code>&lt;div id=&quot;wrapper&quot;&gt;&lt;/div&gt;</code> 아래에 <code>canvas</code> 엘리먼트를 생성해서 <code>append</code> 한다.\n<code>canvas</code>의 너비와 높이는 <code>css</code>를 통해 설정하지 않고 <code>canvas</code> tag의 프로퍼티를 통해 결정한다.</p>\n<blockquote>\n<p><code>css</code>를 통해 너비와 높이를 설정 할 경우 이미지의 해상도가 깨지기 때문에 반드시 프로퍼티를 통해 설정해야함</p>\n</blockquote>\n<p><code>&lt;script&gt;&lt;/script&gt;</code> 태그에 <code>defer</code> 어트리뷰트를 설정 했기 때문에 <code>&lt;div id=&quot;wrapper&quot;&gt;&lt;/div&gt;</code>의 너비와 높이를 추출 할 수 있을 때 <code>script</code>가 실행된다.</p>\n<blockquote>\n<p><code>async</code> &amp; <code>defer</code></p>\n<p>async</p>\n<p>async 어트리뷰트를 가지고 있는 script 태그는 DOM parsing을 블록하지 않고 스크립트를 다운로드 받게된다.</p>\n<p>스크립트의 다운로드가 완료되는 즉시 실행된다.</p>\n<p>defer</p>\n<p>defer 어트리뷰트를 가지고 있는 script 태그 또한 DOM parsing을 블록하지 않고 스크립트를 다운받는다.</p>\n<p>defer script는 DOMContentLoaded 이벤트 이후에 실행되게 된다.</p>\n</blockquote>\n<p><code>&lt;div id=&quot;wrapper&quot;&gt;&lt;/div&gt;</code>의 현재 너비를 추출하여 <code>canvas</code>를 생성한다.</p>\n<pre><code class=\"language-javascript\">const wrapper = document.querySelector(&#39;#wrapper&#39;)\nconst canvas = document.createElement(&#39;canvas&#39;)\nconst context = canvas.getContext(&#39;2d&#39;) // get 2D context\ncanvas.width = wrapper.offsetWidth\ncanvas.height = (canvas.width / 3) * 2 // 예제에서 사용할 이미지가 3:2 비율을 갖고 있기 때문에 `canvas`의 높이를 이와 같이 계산함\n\ncanvas.style.position = &#39;sticky&#39; // wrapper 영역 내에서 상대 위치를 유지하기 위한 position\ncanvas.style.top = &#39;50%&#39; // 이미지가 정중앙에 표시되도록 하기 위한 style\ncanvas.style.transform = &#39;translateY(-50%)&#39; // 이미지가 정중앙에 표시되도록 하기 위한 style\n\nwrapper.append(canvas)\n</code></pre>\n<h3 id=\"canvas-api를-통한-이미지-그리기\">Canvas API를 통한 이미지 그리기</h3>\n<p><code>Canvas API</code>는 <code>JavaScript</code>와 <code>HTML canvas</code> 엘리먼트를 통해 브라우저 상에서 그래픽을 그리기 위한 수단으로 제공된다. 자세한 내용은 <a href=\"https://developer.mozilla.org/ko/docs/Web/API/Canvas_API\">이곳의 문서</a>를 통해 확인 할 수 있다.</p>\n<p>이번에 사용할 <code>canvas api</code>는 2D 컨텍스트의 <code>canvas</code>에 그림을 그려 넣는 <code>(drawImage)</code> 것으로 충분하다.</p>\n<pre><code class=\"language-javascript\">const img = new Image()\n\nimg.onload = () =&gt; {\n  context.drawImage(img, 0, 0, canvas.width, canvas.height)\n}\n\nimg.src = &#39;PATH/TO/IMAGE.img&#39;\n</code></pre>\n<p>위의 <code>syntax</code>를 통해 이미지를 로드하고 <code>canvas</code> 엘리먼트의 컨택스트를 통해 내부에 이미지를 그려낼 수 있다.</p>\n<h3 id=\"scroll-이벤트-등록-및-현재-프레임-계산\">Scroll 이벤트 등록 및 현재 프레임 계산</h3>\n<p>스크롤 가능한 영역 <code>&lt;main&gt;</code> 엘리먼트에 <code>scroll</code> 이벤트 리스너를 등록한다.</p>\n<pre><code class=\"language-javascript\">const main = document.querySelector(&#39;main&#39;)\nmain.onscroll = onScrollHandler\n</code></pre>\n<p><code>onScrollHandler</code> 함수에서는 <code>&lt;main&gt;</code> 엘리먼트의 <code>scrollTop</code>과 <code>startScrollY</code> 그리고 <code>standardHeight</code>를 통해 현재 출력돼야 하는 이미지의 index를 계산한다.</p>\n<blockquote>\n<p>startScrollY</p>\n<p>스크롤에 의해 이미지 프레임을 증가/감소시킬 최소한의 y축 높이를 갖고 있는 변수</p>\n<p>standardHeight</p>\n<p>프레임을 1 증가/감소시키기 위한 최소 scroll 높이로 canvas의 높이를 총 프레임수 (이미지 수)로 나눈 것과 같다</p>\n</blockquote>\n<pre><code class=\"language-javascript\">const computeStartScrollY = () =&gt; {\n  let prevElementSibling = wrapper.previousElementSibling\n  let height = 0\n  while (prevElementSibling) {\n    height += prevElementSibling.offsetHeight\n    prevElementSibling = prevElementSibling.previousElementSibling\n  }\n\n  return height\n}\n\nconst startScrollY = computeStartScrollY()\nconst standardHeight = canvas.height / imageSources.length\n\nconst currentFrameIndex = () =&gt; {\n  const index = Math.floor((main.scrollTop - startScrollY) / standardHeight)\n  if (index &lt; 0) return 0 // index가 음수일 경우 스크롤이 아직 startScrollY에 도달하지 못한 경우 =&gt; 첫번째 인덱스를 리턴\n  if (!imageSources[index]) return imageSources.length - 1 // index를 통해 imageSource를 찾지 못하는경우 =&gt; 마지막 인덱스를 리턴\n\n  return index\n}\n\nconst render = () =&gt; {\n  const frameIndex = currentFrameIndex()\n  const image = new Image()\n  image.src = imageSources[frameIndex]\n  context.drawImage(image, 0, 0, canvas.width, canvas.height)\n}\n\nconst onScrollHandler = () =&gt; {\n  requestAnimationFrame(render)\n}\n</code></pre>\n<blockquote>\n<p><code>requestAnimationFrame</code></p>\n<p><code>requestAnimationFrame</code>의 콜백으로 등록된 함수는 Browser가 리페인트를 수행하기전에 호출된다.\n<code>requestAnimationFrame</code>에 콜백을 등록하는 것을 통해 <code>canvas</code>의 이미지를 안정적으로 갱신 할 수 있다</p>\n<p><code>requestAnimationFrame</code>은 성능 및 베터리 수명을 고려하여 <code>hidden</code> 엘리먼트 또는 background 탭에서는 실행이 중단된다.</p>\n</blockquote>\n<h3 id=\"이미지-불러오기와-최적화\">이미지 불러오기와 최적화</h3>\n<p>이미지는 <code>imagesSources</code>라는 배열에 이미지를 참조하기 위한 경로를 저장하도록 한다.</p>\n<pre><code class=\"language-javascript\">const imageSources = Array(121)\n  .fill(&#39;&#39;)\n  .map((_, idx) =&gt; `./images/${String(idx + 1).padStart(3, &#39;0&#39;)}.png`)\n</code></pre>\n<blockquote>\n<p>각 프레임에 해당하는 이미지는 일종의 규칙을 갖게 하여 코드를 통해 경로를 저장하도록 함</p>\n<p>예제에서는 [001 ~ 121].png 까지 이미지 파일을 각 프레임으로 사용</p>\n</blockquote>\n<p>이미지를 변수에 담았으니 앞서 정의한 <code>render</code> 함수를 통해 <code>canvas</code>에 이미지를 그려주면 되는데\n프레임이 변경될 때마다 이미지를 다운받고 그리게 되면 이미지가 모두 다운로드 되기 전에 이미 다음 프레임을 보여줘야 할 때가 되었을 가능성이 크다.</p>\n<p>이미지를 <code>preloading</code>하여 사전에 이미지를 다운 받아두고 <code>render</code>가 호출 될 때에는 <code>cache</code>된 이미지를 그리도록 해야한다.</p>\n<pre><code class=\"language-javascript\">const preloadImages = () =&gt; {\n  imageSources.forEach((imgSrc) =&gt; {\n    const img = new Image()\n    img.src = imgSrc\n  })\n}\n</code></pre>\n<h3 id=\"초기-이미지-그리기\">초기 이미지 그리기</h3>\n<p><code>canvas</code>에 이미지가 채워지는 시점은 <code>scroll</code> 이벤트가 발생 했을 때다. 만약 화면이 로딩되고 스크롤을 움직이지 않는다면 <code>canvas</code>는 비어 있는 상태일 것이다.\n명시적으로 첫번째 이미지를 그리도록 하여 비어 있는 <code>canvas</code>가 노출 되지 않도록 한다.</p>\n<pre><code class=\"language-javascript\">const initFirstFrame = () =&gt; {\n  const image = new Image()\n  image.src = imageSources[0]\n  image.onload = () =&gt;\n    context.drawImage(image, 0, 0, canvas.width, canvas.height)\n}\n</code></pre>\n<h3 id=\"그-밖의-최적화\">그 밖의 최적화</h3>\n<p>아무래도 여러개의 이미지 파일을 다운받아야 하기 때문에 UX 및 성능상의 이슈를 고려해야한다.</p>\n<ul>\n<li>네트워크 속도가 좋지 못하여 빠른 속도로 이미지를 다운 받지 못하는 환경</li>\n<li>데이터 소모에 대해 거부감을 갖고 있는 사용자</li>\n</ul>\n<p>등의 경우에 따라 에니메이션 효과를 적용하는 것이 아닌 대표 이미지만 나타내도록 하는 것이 방법이 될 것 같다.</p>\n"},"__N_SSG":true}