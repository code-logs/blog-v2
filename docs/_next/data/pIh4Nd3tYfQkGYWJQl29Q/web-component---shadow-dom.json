{
  "pageProps": {
    "post": {
      "title": "Web component - Shadow DOM",
      "description": "Web component의 핵심인 encapsulation은 어떻게 이루어질까?\nShadow DOM의 이해",
      "fileName": "web-component-web-component---shadow-dom.md",
      "category": "web-component",
      "published": true,
      "publishedAt": "2022-08-10",
      "thumbnailName": "ab751eb302db9d348765b3134068a6aa",
      "tags": [
        "Shadow DOM",
        "custom element",
        "encapsulation",
        "shadow",
        "shadow tree",
        "web component",
        "쉐도우",
        "쉐도우 돔",
        "쉐도우 트리",
        "웹 컴포넌트",
        "은닉화",
        "커스텀 엘리먼트"
      ],
      "references": [
        { "title": "MDN - Composed", "url": "https://developer.mozilla.org/en-US/docs/Web/API/Event/composed" },
        { "title": "MDN - Using shadow DOM", "url": "https://developer.mozilla.org/ko/docs/Web/Web_Components/Using_shadow_DOM" }
      ],
      "series": { "prevPostTitle": "Web component - custom element" },
      "order": 22
    },
    "content": "<h2 id=\"table-of-contents\">Table of contents</h2>\n<ol>\n<li><a href=\"#shadow-dom\">Shadow DOM</a></li>\n<li><a href=\"#document-tree%EC%97%90-shadow-root-%EC%82%BD%EC%9E%85%ED%95%98%EA%B8%B0\">Document tree에 Shadow root 삽입하기</a><ol>\n<li><a href=\"#open-mode-shadow-root\">Open mode shadow root</a></li>\n<li><a href=\"#closed-mode-shadow-root\">Closed mode shadow root</a></li>\n<li><a href=\"#delegatesfocus%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-focus-%EC%A7%80%EC%A0%95\">delegatesFocus를 이용한 focus 지정</a></li>\n</ol>\n</li>\n<li><a href=\"#composed-%EC%86%8D%EC%84%B1%EC%9D%84-%EC%9D%B4%EC%9A%A9%ED%95%9C-custom-event-%EC%A0%84%ED%8C%8C\">Composed 속성을 이용한 Custom Event 전파</a></li>\n</ol>\n<h2 id=\"shadow-dom\">Shadow DOM</h2>\n<p>웹 컴포넌트로 제작된 커스텀 엘리먼트는 <code>Shadow DOM</code> 영역에 존재하며 외부의 스타일 정의로 부터 독립적으로 동작할 수 있도록 돕고 컴포넌트 내부에서 발생하는 커스텀 이벤트의 버블링이 <code>Shadow DOM</code> 바깥의 영역까지 전파되어 발생 할 수 있는 side effect를 방지 할 수 있도록 돕는다.</p>\n<p>이렇게 <code>encapsulation</code> 처리가된 커스텀 엘리먼트는 어떤 DOM Tree에 존재하더라도 항상 동일한 생김새와 기능을 보장 할 수 있다.</p>\n<p><code>Shadow DOM</code>은 구조적으로 아래의 용어로 세분화 할 수 있다.</p>\n<ul>\n<li>Shadow root<ul>\n<li><code>Shadow root</code>는 <code>Shadow tree</code>의 관점에서 바라본 <code>root</code> 노드를 의미한다.</li>\n</ul>\n</li>\n<li>Shadow host<ul>\n<li><code>Shadow host</code>는 <code>Document tree</code>의 관점에서 바라본 <code>Shadow tree</code>의 <code>root</code> 노드를 의미한다.</li>\n</ul>\n</li>\n<li>Shadow tree<ul>\n<li><code>Shadow tree</code>는 <code>Document tree</code>와 상응하는 개념으로 <code>Shadow root</code>를 포함한 모든 하위 노드의 트리를 의미한다.</li>\n</ul>\n</li>\n<li>Shadow boundary<ul>\n<li><code>Shadow boundary</code>는 <code>Shadow DOM</code>과 <code>Document tree</code>의 경계를 의미한다.</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"document-tree에-shadow-root-삽입하기\">Document tree에 Shadow root 삽입하기</h2>\n<p><code>Shadow root</code>를 생성하기 위해 <code>Element</code>의 <code>attachShadow</code> 메서드를 사용한다.</p>\n<pre><code class=\"language-javascript\">const container = document.querySelector(&#39;div#container&#39;)\ncontainer.attachShadow({ mode: &#39;open&#39; })\n</code></pre>\n<blockquote>\n<p>모든 엘리먼트에 Shadow DOM을 삽입 할 수 있을까?</p>\n<p>보안상의 이유로 일부 엘리먼트에는 <code>shadow dom</code>을 삽입 할 수 없다. (ex. <code>anchor</code>)\n<code>shadow dom</code>을 삽입 할 수 있는 엘리먼트는\n커스텀 엘리먼트와 <code>article</code>, <code>aside</code>, <code>blockquote</code>, <code>body</code>, <code>div</code>, <code>footer</code>, <code>h1~h6</code>, <code>header</code>, <code>main</code>, <code>nav</code>, <code>p</code>, <code>section</code>, <code>span</code>이 있다.</p>\n</blockquote>\n<p><code>attachShadow</code> 메서드는 <code>option</code>을 객체 형태의 매개변수로 전달 받는다. <code>option</code> 객체는 아래의 형식을 갖는다</p>\n<pre><code class=\"language-typescript\">interface ShadowRootInit {\n  mode: &#39;closed&#39; | &#39;open&#39;\n  delegatesFocus?: boolean\n}\n</code></pre>\n<h3 id=\"open-mode-shadow-root\">Open mode shadow root</h3>\n<p><code>shadow dom</code>이 삽입 될 때 <code>mode</code> 프로퍼티를 <code>open</code>으로 설정하면 <code>JavaScript</code>를 통해 <code>shadowRoot</code>에 접근 할 수 있도록 허용한다.\n<code>mode</code> 프로퍼티는 앞서 이야기한 캡슐화와 관계 없는 옵션으로 <code>open</code> 모드를 사용하더라도 캡슐화는 여전히 유효하다.</p>\n<pre><code class=\"language-javascript\">document.body.attachShadow({ mode: &#39;open&#39; })\nconsole.log(document.body.shadowRoot) // #shadow-root (open)\n</code></pre>\n<h3 id=\"closed-mode-shadow-root\">Closed mode shadow root</h3>\n<p><code>shadow dom</code>이 삽입 될 때 <code>mode</code> 프로퍼티를 <code>closed</code>로 설정하면 <code>JavaScript</code>를 통해 <code>shadowRoot</code>에 접근 할 수 없게된다.</p>\n<pre><code class=\"language-javascript\">document.body.attachShadow({ mode: &#39;closed&#39; })\nconsole.log(document.body.shadowRoot) // null\n</code></pre>\n<blockquote>\n<p>Closed 모드를 사용하는 것은 엔드유저가 할 수 있는 일에 상당한 제약을 준다. 더불어 <code>closed</code> 모드를 사용하더라도 <code>shadow dom</code>에 우회적으로 접근할 수 있다.\n특별한 이유가 없다면 <code>open</code> 모드를 사용하는 것이 좋다.</p>\n</blockquote>\n<blockquote>\n<p>Closed 모드인 shadow dom에 접근하는 방법</p>\n<pre><code class=\"language-javascript\">Element.prototype._attachShadow = Element.prototype.attachShadow\nElement.prototype.attachShadow = function () {\n  return this._attachShadow({ mode: &#39;open&#39; })\n}\n</code></pre>\n</blockquote>\n<h3 id=\"delegatesfocus를-이용한-focus-지정\">delegatesFocus를 이용한 focus 지정</h3>\n<p><code>shadow dom</code>은 또 다른 <code>shadow dom</code> 아래에 삽입 될 수 있다. 중첩된 <code>shadow dom</code> 중 상위 요소를 클릭 했을 때 focus가 대체될 대상 <code>shadow dom</code>을 생성하기 위해 <code>delegatesFocus</code> 속성을 사용한다.</p>\n<pre><code class=\"language-javascript\">document.body.attachShadow({ mode: &#39;open&#39; })\n\nconst shadowRoot = document.body.shadowRoot\nshadowRoot.innerHTML = `\n  &lt;style&gt;\n    div {\n      padding: 20px;\n      background-color: tomato;\n    }\n  &lt;/style&gt;\n  &lt;div&gt;&lt;/div&gt;\n`\nconst div = shadowRoot.querySelector(&#39;div&#39;)\nconst focusableInput = div.attachShadow({\n  mode: &#39;open&#39;,\n  delegatesFocus: true,\n})\nfocusableInput.innerHTML = `&lt;input placeholder=&quot;focusable&quot; /&gt;`\n</code></pre>\n<p>위와 같은 형식으로 <code>DOM</code>과 <code>shadow DOM</code>이 구성되어 있다면 <code>input</code> 엘리먼트를 감싸고 있는 <code>div</code>의 여백 영역을 클릭하면 <code>input</code>으로 포커스가 이동하게 된다.</p>\n<h2 id=\"composed-속성을-이용한-custom-event-전파\">Composed 속성을 이용한 Custom Event 전파</h2>\n<p>커스텀 엘리먼트를 만들게되면 <code>Event</code>를 통해 외부 요소와 커뮤니케이션 해야하는 일들이 빈번히 발생한다.\n<code>click</code>, <code>touch</code>, <code>mouseover</code>와 같은 모든 UI 이벤트는 기본적으로 <code>composed</code> 속성이 설정되어 있고, 다시 말해 <code>shadow boundary</code>를 넘어 외부 <code>DOM</code> 요소로 이벤트가 전파된다. 하지만 <code>Custom Event</code>를 사용할 경우 기본적으로 <code>composed</code>가 <code>false</code>로 설정되어 있다. 다시 말해 <code>shadow boundary</code> 내부에서 생성된 <code>Custom Event</code>는 기본적으로 외부에서 이벤트를 위임할 수 없다는 의미가 된다.</p>\n<p>예측할 수 없는 커스텀 엘리먼트의 이벤트 전파로 인해 발생할 수 있는 부작용을 차단하기 위함이지만 경우에 따라 버블링을 통한 이벤트 전파 및 위임이 필요하기도 하다.</p>\n<pre><code class=\"language-javascript\">shadowElement.dispatchEvent(new CustomEvent(&#39;notify&#39;, {\n  bubbles: true,\n  composed: true\n})\n</code></pre>\n<p><code>composed</code> 속성은 반드시 <code>bubbles</code> 속성이 <code>true</code>일 때 의도와 같이 설정되고 마침내 상위 엘리먼트에서 하위의 <code>shadow dom</code>에서 발생한 custom event를 전파 받을 수 있게된다.</p>\n<blockquote>\n<p>Event capturing과 shadow DOM</p>\n<p>Event capturing은 shadow DOM에서 상위 엘리멘트로의 이벤트 전파가 아니기 때문에 <code>shadow DOM</code>의 존재 유무와 관계 없이 일반적인 형태로 흐른다.</p>\n</blockquote>\n",
    "postsByCategory": [
      {
        "title": "Web component - custom element",
        "description": "웹 컴포넌트로 만드는 나만의 custom element",
        "fileName": "web-component-web-component---custom-element.md",
        "category": "web-component",
        "published": true,
        "publishedAt": "2022-07-31",
        "thumbnailName": "e0e40e28cf11f896033c8650f19188b7",
        "tags": [],
        "references": [
          { "title": "Custom element naming convention", "url": "https://html.spec.whatwg.org/#valid-custom-element-name" },
          { "title": "WebComponent org", "url": "https://www.webcomponents.org/" },
          { "title": "https://web.dev/custom-elements-v1/#custom-element-reactions", "url": "https://web.dev/custom-elements-v1/#custom-element-reactions" }
        ],
        "series": { "nextPostTitle": "Web component - Shadow DOM" },
        "order": 18
      }
    ]
  },
  "__N_SSG": true
}
