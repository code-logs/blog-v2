{"pageProps":{"post":{"title":"Turbo repo (pnpm) 환경에서 Next.js Dockerizing","description":"Turbo repo와 pnpm 환경에서 Next.js Dockerizing 하기","fileName":"turbo-repo-nextjs-dockerizing.md","category":"infrastructure","published":true,"publishedAt":"2023-05-01","thumbnailName":"turbo-pnpm-nextjs-dockerizing.webp","tags":["docker","dockerizing","monorepo","next.js","pnpm","turbo","turbo repo","개발환경","모노리포","빌드","빌드 시스템"],"references":[{"title":"Turbo - Deploying with Docker","url":"https://turbo.build/repo/docs/handbook/deploying-with-docker"}],"order":24},"content":"<h2 id=\"table-of-contents\">Table of contents</h2>\n<ol>\n<li><a href=\"#package-manager\">Package Manager</a><ol>\n<li><a href=\"#pnpm-workspaceyaml-%ED%8C%8C%EC%9D%BC-%EC%83%9D%EC%84%B1\">pnpm-workspace.yaml 파일 생성</a></li>\n<li><a href=\"#pnpm-lockyaml-%ED%8C%8C%EC%9D%BC-%EC%83%9D%EC%84%B1\">pnpm-lock.yaml 파일 생성</a></li>\n</ol>\n</li>\n<li><a href=\"#packagejson\">package.json</a></li>\n<li><a href=\"#dockerignore\">dockerignore</a><ol>\n<li><a href=\"#node_modules\">node_modules</a></li>\n<li><a href=\"#out\">out</a></li>\n</ol>\n</li>\n<li><a href=\"#dockerfile\">Dockerfile</a><ol>\n<li><a href=\"#pnpm-%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%EC%82%AC%EC%9A%A9\">pnpm 스크립트 사용</a></li>\n</ol>\n</li>\n<li><a href=\"#nextconfigjs\">next.config.js</a><ol>\n<li><a href=\"#experimentaloutputfiletracingroot\">experimental.outputFileTracingRoot</a></li>\n</ol>\n</li>\n</ol>\n<h2 id=\"package-manager\">Package Manager</h2>\n<p><code>pnpm</code>을 패키지 매니저로 사용하도록 설정해야 한다 이미 <code>pnpm</code>을 프로젝트의 패키지 매니저로 사용하고 있다면 현재 과정은 생략한다.</p>\n<h3 id=\"pnpm-workspaceyaml-파일-생성\">pnpm-workspace.yaml 파일 생성</h3>\n<p>기존에 <code>pnpm</code>을 사용하지 않았다면 <code>package.json</code>에 설정되어 있는 <code>workspace</code>를 <code>pnpm-workspace.yaml</code> 파일을 통해 참조 할 수 있도록 <code>pnpm-workspace.yaml</code> 파일을 생성해야 한다.</p>\n<pre><code class=\"language-yaml\">packages:\n  - &#39;apps/*&#39;\n  - &#39;packages/*&#39;\n</code></pre>\n<blockquote>\n<p><code>package.json</code> 파일에 있는 <code>workspace</code> 설정은 제거한다.</p>\n</blockquote>\n<h3 id=\"pnpm-lockyaml-파일-생성\">pnpm-lock.yaml 파일 생성</h3>\n<p>정상적으로 <code>pnpm</code>을 통한 <code>workspace</code> 설정이 완료되면 <code>pnpm install</code> 커맨드를 통해 <code>pnpm-lock.yaml</code> 파일을 생성한다. 이후 <code>Docker</code>를 통해 빌드를 진행할 때 lock 파일을 바탕으로 개발환경과 동일한 디펜던시를 설치하기 위해 빌드를 시작하기 전에 반드시 lock 파일을 생성해야 한다.</p>\n<h2 id=\"packagejson\">package.json</h2>\n<p><code>pnpm -v</code> 커맨드를 통해 현재 설치된 <code>pnpm</code>의 버전을 확인하고 <code>package.json</code>에 <code>packageManager</code> 프로퍼티를 아래와 같은 형태로 수정한다.</p>\n<pre><code class=\"language-json\">{\n  ...\n    &quot;packageManager&quot;: &quot;pnpm@8.1.1&quot;\n  ...\n}\n</code></pre>\n<h2 id=\"dockerignore\">dockerignore</h2>\n<h3 id=\"node_modules\">node_modules</h3>\n<p><code>pnpm</code>을 통해 패키지를 설정하면 모노리포의 애플리케이션 디렉토리에 설치되는 모듈은 <code>symbolic link</code>를 통해 <code>workspace</code> 루트의 모듈을 참조한다.\n<code>Docker</code> 빌드 과정에서 설치한 모듈을 복사하게 되는데 이렇게 링크로 생성된 파일은 에러를 발생 시킨다.</p>\n<blockquote>\n<p><code>symbolic link</code>를 통한 참조는 실행환경에 따라 다르기 때문에 <code>Docker</code>를 통한 빌드가 항상 동일한 결과를 만든다는 것을 보장 할 수 없기 때문에 <code>symbolic link</code>를 빌드 과정에 개입 시키는 것을 방지하고 있다.</p>\n</blockquote>\n<p><code>dockerignore</code> 파일에 <code>**/node_modules</code>를 추가해서 모든 루트 디렉토리 뿐 아니라 하위 패키지에 설치된 <code>node_modules</code> 디렉토리도 복사 대상이 되지 않도록 제외해야 한다.</p>\n<h3 id=\"out\">out</h3>\n<p><code>Docker</code>는 빌드시 생성된 파일을 캐싱하고 캐싱 된 레이어를 통해 동일한 작업을 반복하지 않도록 하여 성능을 최적화 한다.</p>\n<p><code>Dockerizing</code> 대상이 되지 않는 파일의 <code>package.json</code>을 빌드 대상에 포함 시키면 빌드와는 관계가 없는 모듈의 패키지 의존 정보가 변경됨에 따라 캐싱된 레이어를 파기하고 다시 한번 불필요한 빌드 과정을 수행하게 된다. 결과적으로 <code>Dockerizing</code>의 성능 최적화 이점을 사용 할 수 없게 된다.</p>\n<p><code>turbo</code>는 이런 최적화를 그대로 사용 할 수 있도록 <code>prune</code> 커맨드를 제공한다. <code>prune</code> 커맨드를 실행하면 특정된 <code>scope</code>와 관계 있는 패키지들의 <code>package.json</code> 파일을 추출하고 <code>out</code> 디렉토리에 저장한다.</p>\n<pre><code class=\"language-sh\">$ turbo prune --scope=&lt;target&gt;\n</code></pre>\n<p><code>out</code> 디렉토리가 <code>dockerignore</code>에 포함되지 않은 상태로 이미지 빌드를 하게 되면 <code>out</code> 디렉토리가 이미지 안쪽에 복사되는 문제가 발생 할 수 있다. <code>docker</code> 이미지 빌드 시점에 <code>out</code> 디렉토리가 <code>COPY</code> 커맨드의 대상이 되지 않도록 <code>dockerignore</code>에 추가한다.</p>\n<blockquote>\n<p><code>turbo</code> 프로젝트를 스캐폴딩하고 나면 기본적으로 <code>out</code> 디렉토리는 <code>gitignore</code> 항목으로 추가되어 있다.\n일반적으로 <code>github action</code>과 같은 <code>CI/CD</code> 툴을 사용한다면 소스 코드를 remote 저장소에서 가지고 오기 때문에 <code>out</code> 디렉토리가 존재하지 않는다.</p>\n</blockquote>\n<h2 id=\"dockerfile\">Dockerfile</h2>\n<h3 id=\"pnpm-스크립트-사용\">pnpm 스크립트 사용</h3>\n<p>패키지 설치, 빌드를 위해 실행하는 커맨드를 <code>pnpm</code>을 사용하도록 수정한다.</p>\n<p>패키지 설치 스크립트는 <code>---frozen-lockfile</code> 옵션을 추가해서 <code>pnpm-lock.yaml</code> 파일을 참조하여 개발환경과 정확히 일치하는 디펜던시를 설치 할 수 있도록 강제해야 한다.</p>\n<blockquote>\n<p><code>pnpm</code>을 통해 스크립트를 실행해야 하는 <code>intermediate layer</code>에서 커맨드 실행전 <code>npm</code>을 통해 <code>pnpm</code>을 전역에 설치 할 필요가 있다.</p>\n</blockquote>\n<h2 id=\"nextconfigjs\">next.config.js</h2>\n<h3 id=\"experimentaloutputfiletracingroot\"><code>experimental.outputFileTracingRoot</code></h3>\n<p><code>pnpm</code>을 통해 모노리포 환경에서 디펜던시를 설치하게 되면 앞서 이야기한 바와 같이 모든 디펜던시를 프로젝트의 루트 디렉토리에 설치하게 된다. 최종적으로 서버를 실행하는데 사용되는 <code>server.js</code> 파일은 이런 구조에 대한 참조를 정확히 하고 있지 않다. <code>Next.js</code>는 이런 경우를 위한 옵션을 제공하는데 <code>experimental.outputFileTracingRoot</code> 설정을 통해 <code>server.js</code> 파일과 동일한 디렉토리에 모듈이 설치 될 수 있도록 한다.</p>\n<pre><code class=\"language-json\">{\n  // next.config.js\n  ...\n  experimental: {\n    outputFileTracingRoot: path.join(__dirname, &#39;../../) // 패키지의 애플리케이션 디렉토리 부터 프로젝트 루트 까지 경로를 설정\n  },\n  ...\n}\n</code></pre>\n","postsByCategory":[{"title":"yarn berry로 구성하는 monorepo","description":"yarn berry와 yarn workspaces를 이용해 monorepo 구성 - 환경 설정, 샘플 프로젝트","fileName":"yarn-berry-monorepo.md","category":"infrastructure","published":true,"publishedAt":"2022-02-26","thumbnailName":"yarn-berry-monorepo.png","tags":["berry","monorepo","workspace","workspaces","yarn","yarn berry","zero-install","모노리포"],"references":[{"title":"yarn workspaces","url":"https://yarnpkg.com/features/workspaces"}],"series":{"prevPostTitle":"Nx build system 맛보기"},"order":10},{"title":"Nx build system 맛보기","description":"Nx build system을 이용한 Monorepo 구성하기","fileName":"monorepo-with-nx.md","category":"infrastructure","published":true,"publishedAt":"2022-02-12","thumbnailName":"monorepo-with-nx.png","tags":["build","build system","monorepo","nx","모노리포","빌드","빌드 시스템"],"series":{"prevPostTitle":"Nx build system 맛보기","nextPostTitle":"yarn berry로 구성하는 monorepo"},"order":9}],"enableContentExplorer":true},"__N_SSG":true}