{"pageProps":{"post":{"title":"Proxy","fileName":"proxy.md","description":"Javascript ES6 Proxy, Proxy, Trap, 프락시를 이용한 객체 조작의 제어","category":"javascript","published":true,"publishedAt":"2021-10-25","tags":["javascript","proxy","trap","es6","프록시"],"thumbnailName":"proxy.png"},"content":"<h2 id=\"table-of-contents\">Table of contents</h2>\n<ol>\n<li><a href=\"#proxy\">Proxy?</a></li>\n<li><a href=\"#%EC%9A%A9%EB%B2%95\">용법</a><ol>\n<li><a href=\"#trap%EC%9D%98-%EC%A2%85%EB%A5%98\">Trap의 종류</a></li>\n</ol>\n</li>\n<li><a href=\"#sample\">Sample</a><ol>\n<li><a href=\"#get\">Get</a></li>\n<li><a href=\"#set\">Set</a></li>\n<li><a href=\"#apply\">Apply</a></li>\n<li><a href=\"#construct\">Construct</a></li>\n</ol>\n</li>\n<li><a href=\"#revocable-proxy\">Revocable proxy</a></li>\n<li><a href=\"#%EB%A7%88%EC%B9%98%EB%A9%B0\">마치며</a></li>\n</ol>\n<h2 id=\"proxy\">Proxy?</h2>\n<p>프락시라는 말은 오늘 기록하려고 하는 javascript에서뿐 아니라 다양한 분야에서 범용적으로 사용되는 용어인듯하다.\n나에게 익숙한 용어는 <code>Proxy server</code>인데 웹서버 구성시 Reverse proxy 설정을 유용히 사용하면서 익숙해졌다.</p>\n<blockquote>\n<p>Reverse proxy?</p>\n<p>클라이언트로부터의 요청을 프락시 서버가 직접 받아 내부 네트워크에서 자원을 다운받고 응답하는 네트워크 구조</p>\n<p>WAS가 요청을 처리하는 것이 아닌 요청과 응답 사이에 대리인 (Proxy)이 개입하여 이를 중계함</p>\n</blockquote>\n<p><code>Proxy</code>의 사전적 의미는 &#39;대리&#39;로 중계의 역할을 수행하는 것에 보통 사용된다.</p>\n<p>javascript에서의 프락시 또한 어떤 객체의 조작이 발생할 때 이를 가로채서 <code>Proxy</code> 내부의 로직을 통해 대상 객체를 조작하는 것을 말한다.</p>\n<h2 id=\"용법\">용법</h2>\n<pre><code class=\"language-javascript\">const target = {}\nconst handler = {\n  get(target, prop) {\n    if (prop in target) {\n      return target[prop]\n    } else {\n      return `타겟 오브젝트에 해당 프로퍼티 (${prop})가 존재하지 않습니다.`\n    }\n  },\n}\n\nconst proxy = new Proxy(target, handler)\nconsole.log(\n  proxy.name\n) /* 타겟 오브젝트에 해당 프로퍼티 (name)가 존재하지 않습니다. */\n</code></pre>\n<p><code>Proxy</code> 객체는 두개의 파라미터를 인자로 받는다. 첫번째는 <code>Proxy</code>를 적용할 대상 객체이고 두번째는 대상 객체를 조작할 때 호출될 핸들러 객체이다.\n핸들러는 <code>trap</code>이라고 불리는 매서드를 가질 수 있으며, <code>trap</code>은 대상 객체의 조작이 발생 할 경우 그것을 가로채어 처리하는 역할을 한다.</p>\n<p>생성된 <code>proxy</code>에 조작이 발생 했을때 handler 내부에 해당 조작을 가로챌 <code>trap</code>이 존재한다면 <code>trap</code> 매서드가 호출된다.</p>\n<p>예제에서 본 것과 같이 <code>trap</code>은 정해진 명칭을 통해 구현해야한다.</p>\n<h3 id=\"trap의-종류\">Trap의 종류</h3>\n<table>\n<thead>\n<tr>\n<th align=\"center\">내부 메서드</th>\n<th align=\"center\">핸들러 메서드 명칭</th>\n<th>트리거</th>\n<th>구현 규칙</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">[[Get]]</td>\n<td align=\"center\">get</td>\n<td>프로퍼티 읽기</td>\n<td></td>\n</tr>\n<tr>\n<td align=\"center\">[[Set]]</td>\n<td align=\"center\">set</td>\n<td>프로퍼티 쓰기</td>\n<td>프로퍼티 쓰기 성공여부를 true/false로 리턴 해야함</td>\n</tr>\n<tr>\n<td align=\"center\">[[HasProperty]]</td>\n<td align=\"center\">has</td>\n<td>in 연산자 사용</td>\n<td></td>\n</tr>\n<tr>\n<td align=\"center\">[[Delete]]</td>\n<td align=\"center\">deleteProperty</td>\n<td>프로퍼티 삭제</td>\n<td>프로퍼티 삭제 성공여부를 true/false로 리턴 해야함</td>\n</tr>\n<tr>\n<td align=\"center\">[[Call]]</td>\n<td align=\"center\">apply</td>\n<td>함수 호출</td>\n<td></td>\n</tr>\n<tr>\n<td align=\"center\">[[Construct]]</td>\n<td align=\"center\">construct</td>\n<td>new 연산자 사용</td>\n<td>반드시 생성자를 통해 호출된 객체를 리턴 해야함</td>\n</tr>\n<tr>\n<td align=\"center\">[[GetPrototypeOf]]</td>\n<td align=\"center\">getPrototypeOf</td>\n<td>Object.getPrototypeOf</td>\n<td></td>\n</tr>\n<tr>\n<td align=\"center\">[[SetPrototypeOf]]</td>\n<td align=\"center\">setPrototypeOf</td>\n<td>Object.setPrototypeOf</td>\n<td></td>\n</tr>\n<tr>\n<td align=\"center\">[[IsExtensible]]</td>\n<td align=\"center\">isExtensible</td>\n<td>Object.isExtensible</td>\n<td></td>\n</tr>\n<tr>\n<td align=\"center\">[[PreventExtensions]]</td>\n<td align=\"center\">preventExtensions</td>\n<td>Object.preventExtensions</td>\n<td></td>\n</tr>\n<tr>\n<td align=\"center\">[[DefineOwnProperty]]</td>\n<td align=\"center\">defineProperty</td>\n<td>Object.defineProperty, Object.defineProperties</td>\n<td></td>\n</tr>\n<tr>\n<td align=\"center\">[[GetOwnProperty]]</td>\n<td align=\"center\">getOwnPropertyDescriptor</td>\n<td>Object.getOwnPropertyDescriptor, for..in, Object.keys, Object.values, Object.entries</td>\n<td></td>\n</tr>\n<tr>\n<td align=\"center\">[[OwnPropertyKeys]]</td>\n<td align=\"center\">ownKeys</td>\n<td>Object.getOwnPropertyNames, Object.getOwnPropertySymbols, for..in, Object.keys, Object.values, Object.entries</td>\n<td></td>\n</tr>\n</tbody></table>\n<blockquote>\n<p>Trap의 기본적인 규칙은 Proxy를 통해 호출되지 않았을 때와 동일한 유형의 값을 return 해야 한다는데 있다.</p>\n</blockquote>\n<h2 id=\"sample\">Sample</h2>\n<h3 id=\"get\">Get</h3>\n<p>다음 예제는 <code>Proxy</code>를 이용하여 객체의 프로퍼티를 조회할 때 해당 프로퍼티가 없을 경우 기본값을 반환하도록 한다.</p>\n<pre><code class=\"language-javascript\">const defaultValueProxy = (target, defaultValue) =&gt; {\n  const handler = {\n    get(target, prop) {\n      if (prop in target) {\n        return prop[target]\n      } else {\n        return defaultValue\n      }\n    },\n  }\n\n  return new Proxy(target, handler)\n}\n\nconst target = { prop1: &#39;value 1&#39; }\nconst defaultValueTarget = defaultValueProxy(target, &#39;default value&#39;)\nconsole.log(defaultValueTarget.prop1) /* value 1 */\nconsole.log(defaultValueTarget.prop2) /* default value */\n</code></pre>\n<h3 id=\"set\">Set</h3>\n<p>다음 예제는 <code>Proxy</code>를 이용하여 객체의 프로퍼티를 쓰기 전 Validation을 수행한다.</p>\n<pre><code class=\"language-javascript\">const validatorProxy = (target, validator) =&gt; {\n  const handler = {\n    set(target, prop, value) {\n      try {\n        if (prop in validator) {\n          validator[prop](value)\n        }\n\n        target[prop] = value\n        return true\n      } catch (e) {\n        console.error(e.message)\n        return false\n      }\n    },\n  }\n\n  return new Proxy(target, handler)\n}\n\nconst profile = validatorProxy(\n  {},\n  {\n    age(age) {\n      if (typeof age !== &#39;number&#39;)\n        throw new Error(&#39;나이는 반드시 숫자 유형이여야 합니다.&#39;)\n      if (age &lt; 0) throw new Error(&#39;나이는 0 보다 작을 수 없습니다.&#39;)\n    },\n  }\n)\n\nprofile.name = &#39;홍길동&#39;\nprofile.age = &#39;스물&#39;\nconsole.log(`Age: ${profile.age}`) /* Age: undefined */\nprofile.age = -20\nconsole.log(`Age: ${profile.age}`) /* Age: undefined */\nprofile.age = 20\nconsole.log(`Age: ${profile.age}`) /* Age: 20 */\n</code></pre>\n<h3 id=\"apply\">Apply</h3>\n<p>다음 예제는 함수 호출시 함수 동작 시간을 출력한다.</p>\n<pre><code class=\"language-javascript\">const timestampProxy = (target) =&gt; {\n  const handler = {\n    apply(target, thisArgs, args) {\n      console.time(&#39;소요시간&#39;)\n      target.apply(thisArgs, args)\n      console.timeEnd(&#39;소요시간&#39;)\n    },\n  }\n  return new Proxy(target, handler)\n}\n\nconst sleep = (second) =&gt; {\n  const startedAt = Date.now()\n  while ((Date.now() - startedAt) / 1000 &lt; second) {} // sleep\n\n  console.log(&#39;Done&#39;)\n}\n\nconst sleepTimestamp = timestampProxy(sleep)\nsleepTimestamp(3)\n/*\n  Done\n  소요시간: 3000ms \n*/\n</code></pre>\n<blockquote>\n<p>Proxy의 대상은 객체이기 때문에 함수도 그 대상이 될 수 있다.</p>\n</blockquote>\n<h3 id=\"construct\">Construct</h3>\n<pre><code class=\"language-javascript\">const strictConstructor = (target, paramCount) =&gt; {\n  const handler = {\n    construct(target, args) {\n      if (args.length &lt; paramCount)\n        throw new Error(\n          &#39;생성자 호출을 위해 필요한 모든 파라미터를 전달 받지 못했습니다.&#39;\n        )\n      return new target(...args)\n    },\n  }\n\n  return new Proxy(target, handler)\n}\n\nclass Person {\n  constructor(name, age, nickname, hobby) {\n    this.name = name\n    this.age = age\n    this.nickname = nickname\n    this.hobby = hobby\n  }\n\n  profile() {\n    console.table(this)\n  }\n}\n\nconst person = new Person()\nperson.profile()\n/*\n  | (index)  |  Values   |\n  ------------------------\n  |   name   | undefined |\n  |   age    | undefined |\n  | nickname | undefined |\n  |  hobby   | undefined |\n*/\n</code></pre>\n<pre><code class=\"language-javascript\">const StrictPerson = strictConstructor(Person, 2)\nnew StrictPerson(&#39;John&#39;)\n/*\n  Error: 생성자 호출을 위해 필요한 모든 파라미터를 전달 받지 못했습니다.\n*/\n</code></pre>\n<pre><code class=\"language-javascript\">const strictPerson = new StrictPerson(&#39;John&#39;, 20)\nstrictPerson.profile()\n/*\n  | (index)  |  Values   |\n  ------------------------\n  |   name   |  &#39;John&#39;   |\n  |   age    |    20     |\n  | nickname | undefined |\n  |  hobby   | undefined |\n*/\n</code></pre>\n<h2 id=\"revocable-proxy\">Revocable proxy</h2>\n<p><code>Proxy</code>를 통해 생성된 객체는 <code>GC</code>의 대상에서 제외된다. 이것을 <code>GC</code>의 대상으로 포함시키기 위해서는 아래와 같은 방식으로 <code>Proxy</code>를 생성해야한다.</p>\n<blockquote>\n<p>GC (Garbage Collection)</p>\n<p>메모리 관리 기법 중의 하나로, 프로그램이 동적으로 할당했던 메모리 영역 중에서 필요없게 된 영역을 해제하는 기능 - <a href=\"https://ko.wikipedia.org/wiki/%EC%93%B0%EB%A0%88%EA%B8%B0_%EC%88%98%EC%A7%91_(%EC%BB%B4%ED%93%A8%ED%84%B0_%EA%B3%BC%ED%95%99)\">wiki</a></p>\n</blockquote>\n<pre><code class=\"language-javascript\">const target = {}\nconst handler = {}\nconst revocableProxy = Proxy.revocable(target, handler)\n</code></pre>\n<p>new 연산자를 통해 <code>Proxy</code>를 생성하는 것이 아닌 static method인 <code>revocable</code>을 호출하는 것으로 <code>Proxy</code> 객체를 생성하면 된다.\n그 외의 사용법은 new 연산자를 통해 생성한 <code>Proxy</code>와 동일하다.</p>\n<p><code>revocable proxy</code>의 경우 <code>proxy</code> 프로퍼티를 통해 대상 객체의 인자에 접근 할 수 있다.\n<code>revocable proxy</code>의 사용이 완료되고 <code>GC</code>의 대상으로 포함시키기 위해서는 아래와 같이 명시적으로 <code>revoke</code>를 호출해주면 된다.\n<code>revoke</code>가 호출된 이후 대상 객체에 대한 조작을 시도하면 <code>TypeError</code>를 발생시키고 <code>revocable proxy</code>는 <code>GC</code>의 대상이 되어 폐기된다.</p>\n<pre><code class=\"language-javascript\">const revocableProxy = (target) =&gt; {\n  const handler = {\n    get(target, prop) {\n      console.log(&#39;Proxy Getter&#39;)\n      return target[prop]\n    },\n  }\n\n  return Proxy.revocable(target, handler)\n}\n\nconst revocable = revocableProxy({ name: &#39;홍길동&#39; })\nrevocable.proxy.name\n/*\n  Proxy Getter\n  홍길동\n*/\nrevocable.revoke()\nrevocable.proxy.name\n/*\n  TypeError: Cannot perform &#39;get&#39; on a proxy that has been revoked\n*/\n</code></pre>\n<h2 id=\"마치며\">마치며</h2>\n<p><code>Proxy</code>는 객체 내부 인자에 대한 조작을 감지 할 수 있다는 것 자체로도 많은 잠재력을 가지고 있다. 상황에 맞게 <code>Proxy</code>를 이용하면 객체의 상태 감지를 통한 특별한 작업들을 할 수 있다. (상태 관리 도구와 같은)</p>\n","postsByCategory":[{"title":"Iterator and Generator","fileName":"iterator-generator.md","description":"Javascript ES6 Iterator & Generator, 열거형, 제너레이터 함수, generator function, yield, function*","category":"javascript","published":true,"publishedAt":"2021-10-17","tags":["javascript","iterator","iterable","generator","es6","function*","yield"],"thumbnailName":"iterator-generator.png"},{"title":"Tagged Template Literal","fileName":"tagged-template-literal.md","description":"Javascript ES6 Tagged Template Literal","category":"javascript","published":true,"publishedAt":"2021-10-11","tags":["javascript","tagged template","tagged template literal","es6"],"thumbnailName":"tagged-template-literal.png"}]},"__N_SSG":true}