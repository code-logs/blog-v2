{"pageProps":{"post":{"title":"고차 컴퍼넌트 (HOC: Higher Order Component)","fileName":"hoc.md","description":"React - 고차 컴퍼넌트를 이용한 컴퍼넌트의 재사용","category":"react","published":true,"publishedAt":"2021-10-30","tags":["hoc","higher order component","고차 컴퍼넌트","react","리액트"],"thumbnailName":"hoc.png"},"content":"<h2 id=\"table-of-contents\">Table of contents</h2>\n<ol>\n<li><a href=\"#%EA%B3%A0%EC%B0%A8-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8%EB%9E%80\">고차 컴포넌트란?</a><ol>\n<li><a href=\"#%EC%A0%95%EC%9D%98\">정의</a></li>\n</ol>\n</li>\n<li><a href=\"#%EA%B3%A0%EC%B0%A8-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0\">고차 컴포넌트를 사용하는 이유</a></li>\n<li><a href=\"#%EA%B3%A0%EC%B0%A8-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8-%EC%82%AC%EC%9A%A9%EB%B0%A9%EB%B2%95\">고차 컴포넌트 사용방법</a><ol>\n<li><a href=\"#sample\">Sample</a></li>\n</ol>\n</li>\n</ol>\n<h2 id=\"고차-컴포넌트란\">고차 컴포넌트란?</h2>\n<p>컴포넌트를 이용한 웹개발은 재사용성을 확보하는데 아주 큰 의미가 있다. 일회성으로 사용되고 다시는 사용 할 수 없는 컴포넌트는 컴포넌트 그 자체의 의미를 잃어버리는 것이다.</p>\n<h3 id=\"정의\">정의</h3>\n<p>고차 컴포넌트는 컴포넌트의 재사용을 위해 사용 할 수 있는 <code>패턴</code>으로 특정 컴포넌트가 가지고 있는 로직을 재사용할 수 있도록 돕는다.</p>\n<p>고차 컴포넌트는 아래와 같이 컴포넌트를 함수의 인자로 받아 새로운 컴포넌트를 리턴하는 형식을 갖느다.</p>\n<pre><code class=\"language-javascript\">const EnhancedComponent = higherOrderComponent(WrappedComponent)\n</code></pre>\n<blockquote>\n<p>고차 컴포넌트(HOC)는 React API의 일부가 아니며, React의 구성적 특성에서 나오는 패턴입니다. - <a href=\"https://ko.reactjs.org/docs/higher-order-components.html\">React Docs</a></p>\n</blockquote>\n<h2 id=\"고차-컴포넌트를-사용하는-이유\">고차 컴포넌트를 사용하는 이유</h2>\n<p>서두에 이야기한 것 처럼 고차 컴포넌트는 <strong>컴포넌트가 가지고 있는 로직을 재사용</strong>하기 위해 사용한다. 간단히 말하면 재사용성을 확보한다는데 의미가 있으며 이를 통해 <strong>횡단 관심사</strong> 문제를 해결 할 수 있다.</p>\n<blockquote>\n<p>횡단 관심사 (Cross cutting concerns)</p>\n<p>어떤 시스템의 본래 목적을 위한 기능들을 핵심 관심사라하며 핵심 관심사를 수행하기 위한 절차에 반복적으로 등장하는 기능이 횡단 관심사다.</p>\n<p>핵심 관심사를 수행하기 위해 발생하는 클라이언트의 요청을 완료하기 까지 매번 발생하게 되는 <code>인증 확인</code>, <code>로그 생성</code>과 같은 것을 예로 들수있다.</p>\n</blockquote>\n<h2 id=\"고차-컴포넌트-사용방법\">고차 컴포넌트 사용방법</h2>\n<p>고차 컴포넌트를 사용하기 위해 아래의 몇가지 규칙을 따라야한다.</p>\n<ul>\n<li>고차 컴포넌트는 컴포넌트를 리턴해야한다.</li>\n<li>일반적으로 고차 컴포넌트 생성 함수의 명칭은 <code>with___</code> 형태를 갖는다.</li>\n<li>클래스 컴포넌트를 이용할 경우 고차 컴포넌트는 기존 컴포넌트의 static method를 갖지 않기 때문에 이를 복사해 줘야 한다.<ul>\n<li><a href=\"https://github.com/mridgway/hoist-non-react-statics\">hoist-non-react-statics</a>를 사용하여 이를 편히 해결 할 수 있다.</li>\n</ul>\n</li>\n<li>클래스 컴포넌트를 이용할 경우 <code>render</code> 함수 내부에서 고차함수를 호출해선 안된다.<ul>\n<li>render가 발생 할 때 마다 새로운 고차함수를 만들어내게 되고 그 결과 내부로 전달되었던 property와 컴포넌트가 가지고 있던 state가 손실되기 때문</li>\n</ul>\n</li>\n<li>ref는 전달되지 않는다.<ul>\n<li>ref는 React에서 일반적인 props와 동일하게 취급되지 않기 때문에 ref를 전달할 경우 내부 컴포넌트가 전달되는 것이 아닌 가장 바깥쪽 컨테이너 컴포넌트를 가르키게 된다.</li>\n<li>이를 해결하기 위해서는 <a href=\"https://ko.reactjs.org/docs/forwarding-refs.html\">React.forwardRef API</a>를 사용해야 합니다.</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"sample\">Sample</h3>\n<p>다음 이야기를 기준으로 컴포넌트를 개발해 보도록 한다.</p>\n<p>버튼을 클릭하면 클릭한 횟수를 표시하는 버튼 컴포넌트를 개발해야 한다.</p>\n<pre><code class=\"language-javascript\">// ClickCounterButton.jsx\nconst ClickCounterButton = () =&gt; {\n  const [count, setCount] = useState(0)\n\n  const increaseCount = () =&gt; {\n    setCount(count + 1)\n  }\n\n  return &lt;button onClick={increaseCount}&gt;Click count: {count}&lt;/button&gt;\n}\n\nexport default ClickCounterButton\n</code></pre>\n<p>버튼을 더블클릭하면 더블클릭한 횟수를 표시하는 버튼 컴포넌트를 개발해야 한다.</p>\n<pre><code class=\"language-javascript\">// DblClickCounterButton.jsx\nconst DblClickCounterButton = () =&gt; {\n  const [count, setCount] = useState(0)\n\n  const increaseCount = () =&gt; {\n    setCount(count + 1)\n  }\n\n  return &lt;button onDblClick={increaseCount}&gt;Double click count: {count}&lt;/button&gt;\n}\n\nexport default DblClickCounterButton\n</code></pre>\n<p>앞서 만든 두개의 컴포넌트가 상당부분 유사한 기능을 수행하고 있다는 것을 발견하고 이를 공통화 한다.</p>\n<pre><code class=\"language-javascript\">// withCounter.jsx\nconst withCounter = (WrappedComponent) =&gt; (props) =&gt; {\n  const [count, setCount] = useState(0)\n\n  const increaseCount = () =&gt; {\n    setCount(count + 1)\n  }\n\n  return (\n    &lt;WrappedComponent increaseCount={increaseCount} count={count} {...props} /&gt;\n  )\n}\n\nexport default withCounter\n</code></pre>\n<p>고차 컴포넌트를 생성하기 위한 함수를 만들었으니 기존에 만들었던 <code>ClickCounterButton</code>과 <code>DblClickCounterButton</code>의 공통된 내부 로직을 삭제하고 <code>withCounter</code>의 공통 로직을 전달 받도록 수정한다.</p>\n<pre><code class=\"language-javascript\">// ClickCounterButton.jsx\nconst ClickCounterButton = (props) =&gt; (\n  &lt;button onClick={props.increaseCount}&gt;Click count: {props.count}&lt;/button&gt;\n)\n\nexport default withCounter(ClickCounterButton)\n</code></pre>\n<pre><code class=\"language-javascript\">// DblClickCounterButton.jsx\nconst DblClickCounterButton = (props) =&gt; (\n  &lt;button onDblClick={increaseCount}&gt;Double click count: {props.count}&lt;/button&gt;\n)\n\nexport default withCounter(DblClickCounterButton)\n</code></pre>\n<blockquote>\n<p>주목할 부분은 <code>export</code> 구문에 있다. 기존의 정의한 컴포넌트를 리턴하는 것이 아닌 <code>withCounter</code>를 호출한 결과 생성된 컴포넌트를 리턴하는 것을 통해 고차 컴포넌트를 생성해야 한다.</p>\n</blockquote>\n<p><code>ClickCounterButton</code>의 버튼 메시지 <code>Click count:</code>를 <code>text</code>라는 명칭의 프로퍼티를 통해 외부에서 주입 받도록 수정해야한다면?</p>\n<pre><code class=\"language-javascript\">// ClickCounterButton.jsx\nconst ClickCounterButton = (props) =&gt; (\n  &lt;button onClick={props.increaseCount}&gt;\n    {props.text}: {props.count}\n  &lt;/button&gt;\n)\n\nexport default withCounter(ClickCounterButton)\n</code></pre>\n<p><code>DblClickCounterButton</code>의 버튼 메시지 <code>Double click count:</code> 또한 외부에서 주입 받도록 수정해야 하고 이번에는 <code>title</code>이라는 명칭의 프로퍼티를 통해야 한다면?</p>\n<pre><code class=\"language-javascript\">// DblClickCounterButton.jsx\nconst DblClickCounterButton = (props) =&gt; (\n  &lt;button onDblClick={increaseCount}&gt;\n    {props.title} {props.count}\n  &lt;/button&gt;\n)\n\nexport default withCounter(DblClickCounterButton)\n</code></pre>\n<p>이렇게 컴포넌트의 로컬 프로퍼티를 정의 했다고 하더라고 <code>HOC</code>를 통해 대상 프로퍼티의 값을 전달해 줄수 있다.</p>\n<pre><code class=\"language-javascript\">// withCounter.jsx\nconst withCounter = (WrappedComponent) =&gt; (props) =&gt; {\n  const [count, setCount] = useState(0)\n\n  const increaseCount = () =&gt; {\n    setCount(count + 1)\n  }\n\n  return (\n    &lt;WrappedComponent increaseCount={increaseCount} count={count} {...props} /&gt;\n  )\n}\n\nexport default withCounter\n</code></pre>\n<blockquote>\n<p>앞서 정의한 <code>HOC</code>를 다시 살펴 보면 <code>withCounter</code>는 <code>WrappedComponent</code>를 전달 받고 바로 <code>(props) =&gt; JSX.Element</code> 형식의 함수를 리턴하게 된다 그 결과 <code>props</code> 변수를 통해 컴포넌트를 대상으로한 <code>props</code>를 전달 받을 수 있고 최종적으로 <code>{...props}</code>를 통해 대상 컴포넌트에 프로퍼티를 전달 할 수 있게 된다.</p>\n</blockquote>\n"},"__N_SSG":true}