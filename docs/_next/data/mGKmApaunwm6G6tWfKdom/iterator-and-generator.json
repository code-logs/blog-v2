{
  "pageProps": {
    "post": {
      "title": "Iterator and Generator",
      "description": "Javascript ES6 Iterator & Generator, 열거형, 제너레이터 함수, generator function, yield, function*",
      "fileName": "iterator-generator.md",
      "category": "javascript",
      "published": true,
      "publishedAt": "2021-10-17",
      "thumbnailName": "iterator-generator.png",
      "tags": ["es6", "function*", "generator", "iterable", "iterator", "javascript", "yield"]
    },
    "content": "<h2 id=\"table-of-contents\">Table of contents</h2>\n<ol>\n<li><a href=\"#iterable-and-iterator\">Iterable and Iterator</a><ol>\n<li><a href=\"#iterable\">Iterable</a></li>\n<li><a href=\"#iterator\">iterator</a></li>\n</ol>\n</li>\n<li><a href=\"#generator\">Generator</a></li>\n</ol>\n<h2 id=\"iterable-and-iterator\">Iterable and Iterator</h2>\n<p>개발을 하다 보면 이런 에러 메시지를 마주치곤 한다.</p>\n<pre><code class=\"language-javascript\">TypeError: variable is not iterable\n</code></pre>\n<p>variable이 반복될 수 없다는 의미인데, 정확히 iterable이 어떤 것인지 그리고 iterator는 어떤 것인지 정리한다.</p>\n<h3 id=\"iterable\">Iterable</h3>\n<p>Array, Map과 같이 <code>for..of</code>문 내에서 반복 되는 것 처럼 어떤 반복 동작이 가능한 경우 iterable이라 할 수 있다. javascript에는 이미 내장되어 있는 iterable한 객체들이 몇 있는데 이런 것을 내장 iterable이라 한다.</p>\n<p>내장 iterable:</p>\n<ul>\n<li>String</li>\n<li>Array</li>\n<li>TypedArray</li>\n<li>Map</li>\n<li>Set</li>\n</ul>\n<p>내장 iterable 외에 사용자가 iterable을 직접 정의해서 사용 할 수 있는데 사용자가 iterable을 직접 정의하기 위해서는 아래의 구조적인 규칙을 반드시 준수 해야한다.</p>\n<ul>\n<li>iterable 객체는 <code>Symbol.iterator</code>를 키로하는 <code>@@iterator</code> 메서드를 갖고 있어야 함.</li>\n</ul>\n<h3 id=\"iterator\">Iterator</h3>\n<p>Iterator는 <code>Iterator protocol</code>을 따르는 객체로, Iterator protocol은 아래의 규칙을 의미한다.</p>\n<ul>\n<li><code>next</code> 메서드를 갖고 있어야 한다.<ul>\n<li>next 메서드는 호출시 { done: boolean, value: any } 형태의 값을 반환해야 한다.</li>\n</ul>\n</li>\n<li><code>Symbol.iterator</code>를 키로하고 <code>iterator</code>를 리턴하는 메서드를 갖고 있어야 한다.</li>\n</ul>\n<pre><code class=\"language-javascript\">const adder = {\n  value: 0,\n  increment: 2,\n  limit: 10,\n  next: function () {\n    if (this.value &gt;= this.limit) return { done: true }\n    return { done: false, value: (this.value += this.increment) }\n  },\n  [Symbol.iterator]: function () {\n    return this\n  },\n}\n</code></pre>\n<p><code>adder</code>라는 객체를 정의 하였다. <code>adder</code>는 <code>value</code>의 초기값 0을 기준으로 매번 반복동작이 수행 될 때 (<code>next</code> 메서드가 호출 될 때) 마다 <code>increment</code> 만큼 값이 증가하고 <code>value</code>가 <code>limit</code> 보다 크거나 같을 경우 더이상 반복동작을 수행 할 수 없다.</p>\n<p>이와 같이 사용자가 직접 iterable한 객체를 정의 할 수 있다. 구조적으로 조건에 충족하는 iterator를 구현하면 아래와 같은 문법을 통해 해당 객체를 순회 할 수 있다.</p>\n<pre><code class=\"language-javascript\">for (const value of adder) {\n  console.log(value)\n}\n\n/* 실행 결과:\n  2\n  4\n  6\n  8\n  10\n*/\n</code></pre>\n<p>당연히 iterator를 통해 값을 순회 할 경우 내부 변수의 값이 변경되기 때문에 순회를 이미 마친 객체는 일반적인 방법으로는 다시 처음의 값으로 되돌릴 수 없다.</p>\n<pre><code class=\"language-javascript\">for (const value of adder) {\n  console.log(value)\n}\n\n/* 실행 결과:\n  2\n  4\n  6\n  8\n  10\n*/\n\nconsole.log(&#39;Value&#39;, ...adder)\n/* 실행 결과:  \n  Value\n*/\n</code></pre>\n<h2 id=\"generator\">Generator</h2>\n<p><code>Iterator</code>를 직접 정의하여 사용 할 수 있지만 <code>Generator</code> 함수를 이용하면 조금 더 간편하게 <code>iterator</code>를 구현 할 수 있다.</p>\n<p><code>Generator</code> 함수는 일반 함수 정의와 달리 function 키워드 뒤에 <code>*</code>를 붙여야 한다.</p>\n<blockquote>\n<p>Arrow function 정의 방식을 통해서는 generator를 구현 할 수 없음</p>\n</blockquote>\n<p><code>iterator</code>에서 <code>next</code> 메서드를 호출하는 것은 반복구문을 1회 수행한다는 것을 의미하는데 <code>Generator</code> 함수에서는 <code>yield</code> 키워드를 통해 함수 반복구문의 범위를 설정 할 수 있다.</p>\n<p>아래 예제 코드를 보면 앞서 설명한 이야기를 조금 더 쉽게 이해 할 수 있다.</p>\n<pre><code class=\"language-javascript\">function* adder() {\n  let value = 0\n  const increment = 2\n  const limit = 10\n\n  value += increment\n  yield value\n\n  value += increment\n  yield value\n\n  value += increment\n  yield value\n\n  value += increment\n  yield value\n\n  value += increment\n  yield value\n}\n\nfor (const value of adder()) {\n  console.log(value)\n}\n\n/* 실행 결과:\n  2\n  4\n  6\n  8\n  10\n*/\n</code></pre>\n<p><code>Generator</code> 함수 내부에서 루프문을 이용하면 조금더 쉽게 반복구문을 정의 할 수 있다.</p>\n<pre><code class=\"language-javascript\">function* adder() {\n  let value = 0\n  const increment = 2\n  const limit = 10\n\n  while (value &lt; limit) {\n    yield (value += increment)\n  }\n}\n\nfor (const value of adder()) {\n  console.log(value)\n}\n\n/* 실행 결과:\n  2\n  4\n  6\n  8\n  10\n*/\n</code></pre>\n<p>개인적으로 <code>Generator</code> 함수를 사용하여 실무에서 무언가 작업한 경험은 극히 드물다 . 반복적인 작업을 처리할 때 <code>Iterator</code>와 <code>Generator</code>를 떠올리기 보단 <code>Array</code>를 통해 간단히 해결하는 것이 대부분인 것 같다. 그런데 순차적인 반복구문의 수행 그리고 일정 범위에 도달 했을 때의 반복 불가와 같은 <code>Iterable</code>의 특징은 단방향의 절차적 흐름을 가지고 있는 데이터를 처리하는데 용이하다는 생각이 든다.</p>\n",
    "postsByCategory": [
      {
        "title": "Proxy",
        "description": "Javascript ES6 Proxy, Proxy, Trap, 프락시를 이용한 객체 조작의 제어",
        "fileName": "proxy.md",
        "category": "javascript",
        "published": true,
        "publishedAt": "2021-10-25",
        "thumbnailName": "proxy.png",
        "tags": ["es6", "javascript", "proxy", "trap", "프록시"]
      },
      {
        "title": "Tagged Template Literal",
        "description": "Javascript ES6 Tagged Template Literal",
        "fileName": "tagged-template-literal.md",
        "category": "javascript",
        "published": true,
        "publishedAt": "2021-10-11",
        "thumbnailName": "tagged-template-literal.png",
        "tags": ["es6", "javascript", "tagged template", "tagged template literal"]
      }
    ]
  },
  "__N_SSG": true
}
