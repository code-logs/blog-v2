<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta name="viewport" content="width=device-width" />
    <meta charset="utf-8" />
    <link rel="canonical" href="https://code-logs.github.io/web-component---custom-element" />
    <link rel="apple-touch-icon" href="/icons/icon-192x-192.png" />
    <link rel="manifest" href="/manifest.json" />
    <meta name="theme-color" content="#fff" />
    <meta property="og:type" content="website" />
    <meta property="og:site_name" content="Code Logs" />
    <meta name="author" content="Jay Lee" />
    <meta name="keyword" content="Web component - custom element, 웹 컴포넌트로 만드는 나만의 custom element, web-component" />
    <meta name="description" content="Code Logs Web component - custom element - 웹 컴포넌트로 만드는 나만의 custom element | web-component, " />
    <meta property="og:description" content="Code Logs Web component - custom element - 웹 컴포넌트로 만드는 나만의 custom element | web-component, " />
    <meta property="og:title" content="Web component - custom element | Code Logs" />
    <meta property="og:url" content="https://code-logs.github.io/web-component---custom-element" />
    <meta property="og:image" content="/assets/images/e0e40e28cf11f896033c8650f19188b7" />
    <title>Web component - custom element | Code Logs</title>
    <meta name="next-head-count" content="16" />
    <link rel="preload" href="/_next/static/css/ea84f604a7990c7b.css" as="style" />
    <link rel="stylesheet" href="/_next/static/css/ea84f604a7990c7b.css" data-n-g="" />
    <link rel="preload" href="/_next/static/css/e4e42ae632305f90.css" as="style" />
    <link rel="stylesheet" href="/_next/static/css/e4e42ae632305f90.css" data-n-p="" />
    <noscript data-n-css=""></noscript>
    <script defer="" nomodule="" src="/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script>
    <script src="/_next/static/chunks/webpack-2e51481b1d484a05.js" defer=""></script>
    <script src="/_next/static/chunks/framework-5f4595e5518b5600.js" defer=""></script>
    <script src="/_next/static/chunks/main-a4d9e436b9a532ca.js" defer=""></script>
    <script src="/_next/static/chunks/pages/_app-011266434a92a220.js" defer=""></script>
    <script src="/_next/static/chunks/294-6603e2d70ff7953e.js" defer=""></script>
    <script src="/_next/static/chunks/435-53f0efcf9c863326.js" defer=""></script>
    <script src="/_next/static/chunks/pages/%5Btitle%5D-21caa513367653a4.js" defer=""></script>
    <script src="/_next/static/5Hhuw6icEhH2OOBBJ38VN/_buildManifest.js" defer=""></script>
    <script src="/_next/static/5Hhuw6icEhH2OOBBJ38VN/_ssgManifest.js" defer=""></script>
    <script src="/_next/static/5Hhuw6icEhH2OOBBJ38VN/_middlewareManifest.js" defer=""></script>
  </head>
  <body>
    <div id="__next" data-reactroot="">
      <header class="Header_header__RW35m">
        <span class="Header_title__GPS8b">Code Logs</span>
        <ul class="Header_socialIcons__CBf_s">
          <li>
            <a href="https://github.com/possible819" target="_blank" rel="noreferrer" aria-label="My Github"
              ><style data-emotion="css vubbuv">
                .css-vubbuv {
                  -webkit-user-select: none;
                  -moz-user-select: none;
                  -ms-user-select: none;
                  user-select: none;
                  width: 1em;
                  height: 1em;
                  display: inline-block;
                  fill: currentColor;
                  -webkit-flex-shrink: 0;
                  -ms-flex-negative: 0;
                  flex-shrink: 0;
                  -webkit-transition: fill 200ms cubic-bezier(0.4, 0, 0.2, 1) 0ms;
                  transition: fill 200ms cubic-bezier(0.4, 0, 0.2, 1) 0ms;
                  font-size: 1.5rem;
                }</style
              ><svg
                class="MuiSvgIcon-root MuiSvgIcon-fontSizeMedium css-vubbuv"
                focusable="false"
                aria-hidden="true"
                viewBox="0 0 24 24"
                data-testid="GitHubIcon"
              >
                <path
                  d="M12 1.27a11 11 0 00-3.48 21.46c.55.09.73-.28.73-.55v-1.84c-3.03.64-3.67-1.46-3.67-1.46-.55-1.29-1.28-1.65-1.28-1.65-.92-.65.1-.65.1-.65 1.1 0 1.73 1.1 1.73 1.1.92 1.65 2.57 1.2 3.21.92a2 2 0 01.64-1.47c-2.47-.27-5.04-1.19-5.04-5.5 0-1.1.46-2.1 1.2-2.84a3.76 3.76 0 010-2.93s.91-.28 3.11 1.1c1.8-.49 3.7-.49 5.5 0 2.1-1.38 3.02-1.1 3.02-1.1a3.76 3.76 0 010 2.93c.83.74 1.2 1.74 1.2 2.94 0 4.21-2.57 5.13-5.04 5.4.45.37.82.92.82 2.02v3.03c0 .27.1.64.73.55A11 11 0 0012 1.27"
                ></path></svg
            ></a>
          </li>
        </ul>
        <nav class="NavBar_navBar__akqA3">
          <ul>
            <li class="clickable"><a class="MarkedAnchor_anchor__QCmkL" href="/">Home</a></li>
            <li class="clickable"><a class="MarkedAnchor_anchor__QCmkL" href="/posts/1">Posts</a></li>
            <li class="clickable"><a class="MarkedAnchor_anchor__QCmkL" href="/about">About</a></li>
          </ul>
        </nav>
      </header>
      <main>
        <article class="PostDetail_container__Ma_26">
          <p class="PostDetail_publishedAt__7GOQm"><span></span></p>
          <section class="PostDetail_thumbnailWrapper__oALCg">
            <img src="/assets/images/e0e40e28cf11f896033c8650f19188b7" alt="웹 컴포넌트로 만드는 나만의 custom element" />
          </section>
          <section>
            <h1>Web component - custom element</h1>
            <p class="PostDetail_description__l6wHC">웹 컴포넌트로 만드는 나만의 custom element</p>
          </section>
          <section>
            <h2 id="table-of-contents">Table of contents</h2>
            <ol>
              <li>
                <a href="#%EC%9B%B9-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8">웹 컴포넌트</a>
                <ol>
                  <li><a href="#why-webcomponent">Why webcomponent?</a></li>
                </ol>
              </li>
              <li>
                <a href="#%EC%BB%A4%EC%8A%A4%ED%85%80-%EC%97%98%EB%A6%AC%EB%A8%BC%ED%8A%B8">커스텀 엘리먼트</a>
                <ol>
                  <li>
                    <a href="#%EC%BB%A4%EC%8A%A4%ED%85%80-%EC%97%98%EB%A6%AC%EB%A8%BC%ED%8A%B8-%EB%93%B1%EB%A1%9D%ED%95%98%EA%B8%B0"
                      >커스텀 엘리먼트 등록하기</a
                    >
                  </li>
                  <li><a href="#%EC%83%9D%EB%AA%85%EC%A3%BC%EA%B8%B0">생명주기</a></li>
                </ol>
              </li>
              <li>
                <a href="#custom-form">custom-form</a>
                <ol>
                  <li><a href="#custom-form-%EB%93%B1%EB%A1%9D%ED%95%98%EA%B8%B0">custom-form 등록하기</a></li>
                  <li>
                    <a href="#custom-form-%EB%82%B4%EB%B6%80-%EB%A9%94%EC%84%9C%EB%93%9C-%EC%A0%95%EC%9D%98%ED%95%98%EA%B8%B0"
                      >custom-form 내부 메서드 정의하기</a
                    >
                  </li>
                  <li><a href="#custom-form-HTML%EC%97%90%EC%84%9C-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0">custom-form HTML에서 사용하기</a></li>
                </ol>
              </li>
              <li>
                <a href="#counter-button">counter-button</a>
                <ol>
                  <li><a href="#counter-button-%EB%93%B1%EB%A1%9D%ED%95%98%EA%B8%B0">counter-button 등록하기</a></li>
                  <li>
                    <a href="#counter-button-%EB%82%B4%EB%B6%80-%EB%A9%94%EC%84%9C%EB%93%9C-%EC%A0%95%EC%9D%98%ED%95%98%EA%B8%B0"
                      >counter-button 내부 메서드 정의하기</a
                    >
                  </li>
                  <li>
                    <a
                      href="#counter-button-property%EB%A5%BC-%ED%86%B5%ED%95%B4-%EC%BB%A4%EC%8A%A4%ED%85%80-%EC%97%98%EB%A6%AC%EB%A8%BC%ED%8A%B8-%EA%B0%92-%EB%B3%80%EA%B2%BD%ED%95%98%EA%B8%B0"
                      >counter-button Property를 통해 커스텀 엘리먼트 값 변경하기</a
                    >
                  </li>
                  <li><a href="#counter-button-html%EC%97%90%EC%84%9C-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0">counter-button HTML에서 사용하기</a></li>
                </ol>
              </li>
              <li><a href="#%EB%A7%88%EC%B9%98%EB%A9%B0">마치며</a></li>
            </ol>
            <h2 id="웹-컴포넌트">웹 컴포넌트</h2>
            <p>
              웹 컴포넌트는 존재하는 HTML <code>태그를 확장</code>하여 새로운 기능을 추가하고 <code>캡슐화</code>를 통해 외부 요소로 부터 독립적인 커스텀
              엘리먼트를 제작하기 위한 웹 API의 모음이다.
            </p>
            <p>
              웹 컴포넌트는 <code>웹 표준</code>을 따르기 때문에 대부분의 모던 브라우저에서 문제 없이 동작한다. 지금도 꾸준히 표준을 잡아가고 있으며 브라우저
              <code>spec</code>이 계속해서 정립되고 있다.
            </p>
            <h3 id="why-webcomponent">Why Webcomponent?</h3>
            <ul>
              <li>웹 컴포넌트는 <code>캡슐화</code>를 통해 기본적으로 외부 요소와 독립적으로 존재한다.</li>
            </ul>
            <p>
              웹 컴포넌트 API를 통해 정의된 커스텀 엘리먼트는 캡슐화되어 존재하기 때문에 외부에서 주입되는 <code>style sheet</code>의 영향을 받지 않는다.
              컴포넌트가 <code>부품</code>으로서의 가치를 갖기 위해서는 어떠한 환경에서 사용 되더라도 동일한 기능과 형태를 유지해야 한다. 이런 관점에서 웹
              컴포넌트로 생성된 커스텀 엘리먼트는 <code>shadow root</code>라는 영역에 독립적으로 존재하며 외부의 <code>style sheet</code>에 의해 형태가 변형되지
              않는다.
            </p>
            <blockquote>
              <p>물론 필요에 따라 외부의 style sheet의 영향을 받도록 설정할 수 있다.</p>
            </blockquote>
            <p>
              더불어 커스텀 엘리먼트 내부에서 발생하는 이벤트의 버블링은 기본적으로 <code>shadow root</code>를 벗어 날 수 없다. 이는 이벤트 버블링에 의해 야기될
              수 있는 사이드 이펙트를 방지 할 수 있도록 돕는다.
            </p>
            <ul>
              <li>표준 API를 사용해 어떤 라이브러리 또는 프레임워크를 통해 구성된 웹 앱에서도 동작 할 수 있다.</li>
            </ul>
            <p>
              웹 표준 API를 통해 구현되는 커스텀 엘리먼트는 사용자의 브라우저 환경이 이를 지원한다면 (대부분의 모던 브라우저가 지원하고 있다.) 별도의
              라이브러리에 의존하지 않는다. 다시말해 <code>React</code>로 구성 되었건 <code>Vue</code>로 구성 되었건 화면의 일부 요소는 얼마든지
              <code>custom element</code>로 구현 할 수 있다. <code>어떤 환경에서도 사용 할 수 있는 것</code> 또한 컴포넌트로서의 가치를 증가 시킬수 있는 요소다.
            </p>
            <h2 id="커스텀-엘리먼트">커스텀 엘리먼트</h2>
            <p>
              커스텀 엘리먼트는 <code>CustomElementRegistry</code> 객체를 통해 제어 할 수 있다. <code>CustomElementRegistry</code> 객체의
              <code>define</code> 메서드를 통해 새로운 커스텀 엘리먼트를 등록하게 된다.
            </p>
            <p>
              커스텀 엘리먼트는 반드시 <code>kebab-case</code> 형식의 명칭을 사용해야 하는데 이는 미래에 추가될 <code>html</code> 네이티브 태그와 구분하기
              위함이다. (새롭게 추가될 html 태그는 절대 <code>-</code>을 포함하지 않을 것이기 때문에) -
              <a href="https://html.spec.whatwg.org/#valid-custom-element-name">Custom element naming convention</a>
            </p>
            <h3 id="커스텀-엘리먼트-등록하기">커스텀 엘리먼트 등록하기</h3>
            <pre><code class="language-javascript">window.customElements.define(&#39;custom-element&#39;, CustomElement)

// or

window.customElements.define(&#39;custom-element&#39;, CustomElement, { extends: &#39;form&#39; })
</code></pre>
            <p><code>define</code> 메서드는 다음 세가지의 매개변수를 전달 받을 수 있다.</p>
            <ul>
              <li>DOMString: 커스텀 엘리먼트의 이름</li>
              <li>class 객체: 커스텀 엘리먼트의 동작을 정의한 <code>class</code> 객체</li>
              <li><code>optional</code> extends 속성: 현재 커스텀 엘리먼트가 상속 받는 대상 태그</li>
            </ul>
            <h3 id="생명주기">생명주기</h3>
            <p>
              커스텀 엘리먼트를 등록하기 위해 동작에 대한 정의를 담고 있는 class 객체를 생성해야한다. class 객체는 생명주기를 갖고 있으며 생명주기에 따라 적절한
              동작을 정의해야한다.
            </p>
            <ul>
              <li>constructor: 커스텀 엘리먼트의 인스턴스가 생성될 때마다 호출됨</li>
              <li>connectedCallback: 커스텀 엘리먼트가 <code>document</code>에 추가될 때마다 호출됨</li>
              <li>disconnectedCallback: 커스텀 엘리먼트가 <code>document</code>에서 제거 될 때마다 호출됨</li>
              <li>adoptedCallback: 커스텀 엘리먼트가 새로운 <code>document</code>로 이동할 때마다 호출됨</li>
              <li>attributeChangedCallback: 커스텀 엘리먼트의 attribute가 변화할 때 마다 호출됨</li>
            </ul>
            <p>
              이런 생명주기를 통해 이벤트 리스너를 등록/제거 하거나 특정 속성의 변화에 따른 동작을 구현할 수 있고 데이터 패칭과 같이 컴포넌트 초기화 시점에
              필요한 상태들을 설정할 때 사용할 수 있다. -
              <a href="https://web.dev/custom-elements-v1/#custom-element-reactions">https://web.dev/custom-elements-v1/#custom-element-reactions</a>
            </p>
            <blockquote>
              <p>attributeChangedCallback(attrName, oldVal, newVal)</p>
              <p>
                <code>attributeChangedCallback</code>은 상기와 같은 매개변수를 전달 받는다. 이렇게 attributeChangedCallback을 통해 관리 돼야하는
                <code>attribute</code>는 반드시 객체 내부의 <code>observedAttributes</code> 배열로 작성되어야 한다.
              </p>
            </blockquote>
            <h2 id="custom-form">custom-form</h2>
            <p>
              앞서 살펴본 커스텀 엘리먼트의 기본적인 요소들을 바탕으로 <code>custom-form</code>을 작성한다. <code>custom-form</code>은 기존
              <code>form</code> 태그를 상속 받아 <code>serialize</code>라는 내부 메서드를 갖는다.
            </p>
            <p>
              <code>serialize</code> 메서드는 <code>form</code> 내부에 정의된 입력 요소들 (<code>input</code>, <code>select</code>, <code>textarea</code> 와
              같은)의 값을 추출하고 입력된 <code>type</code>에 따라 값을 변형하여 return하는 역할을 하게 된다.
            </p>
            <h3 id="custom-form-등록하기">custom-form 등록하기</h3>
            <pre><code class="language-javascript">class CustomForm extends HTMLFormElement {}

window.customElements.define(&#39;custom-form&#39;, CustomForm, { extends: &#39;form&#39; })
</code></pre>
            <h3 id="custom-form-내부-메서드-정의하기">custom-form 내부 메서드 정의하기</h3>
            <pre><code class="language-javascript">class CustomForm extends HTMLFormElement {
  serialize() {
    const elements = Array.from(this.querySelectorAll(&#39;input,select,textarea&#39;))
    if (elements.some((element) =&gt; !element.name)) {
      throw new Error(&#39;Failed to find field name&#39;)
    }

    let result = {}

    elements.forEach(({ name, type, value, checked }) =&gt; {
      switch (type) {
        case &#39;number&#39;:
          result[name] = Number(value)
          break

        case &#39;checkbox&#39;:
          result[name] = checked
          break

        default:
          result[name] = value
      }
    })

    return result
  }
}

window.customElements.define(&#39;custom-form&#39;, CustomForm, { extends: &#39;form&#39; })
</code></pre>
            <p>
              <code>CustomForm</code> class 내부에 <code>serialize</code>라는 명칭의 메서드를 정의한다. <code>form</code> 내부에 존재하는 입력 요소들을 찾아
              필드 명칭을 확인하고 데이터 유형에 따라 변형한 값을 객체에 담아 반환한다.
            </p>
            <h3 id="custom-form-html에서-사용하기">custom-form HTML에서 사용하기</h3>
            <pre><code class="language-html">...

&lt;script defer src=&quot;./custom-form.js&quot;&gt;&lt;/script&gt;

...

&lt;form id=&quot;custom-form&quot; is=&quot;custom-form&quot;&gt;
  &lt;input type=&quot;text&quot; name=&quot;text&quot; /&gt;
  &lt;input type=&quot;number&quot; name=&quot;number&quot; /&gt;
  &lt;input type=&quot;date&quot; name=&quot;date&quot; /&gt;
  &lt;input type=&quot;checkbox&quot; name=&quot;checkbox&quot; /&gt;
  &lt;textarea name=&quot;textarea&quot;&gt;&lt;/textarea&gt;
  &lt;select name=&quot;option&quot;&gt;
    &lt;option&gt;Option 1&lt;/option&gt;
    &lt;option&gt;Option 2&lt;/option&gt;
    &lt;option&gt;Option 3&lt;/option&gt;
  &lt;/select&gt;
&lt;/form&gt;

...

&lt;script&gt;
  const formData = document.querySelector(&#39;#custom-form&#39;).serialize()
  console.log(formData)
&lt;/script&gt;
</code></pre>
            <p>예제에서 처럼 기존의 HTML 태그를 상속 받아 사용할 경우 <code>is</code> 속성을 통해 사용하고자 하는 커스텀 엘리먼트의 명칭을 입력한다.</p>
            <h2 id="counter-button">counter-button</h2>
            <p>
              버튼을 클릭하면 숫자가 올라가는 간단한 커스텀 엘리먼트를 작성한다. 기존에 존재하는 태그의 기능을 상속 받지 않는 완전히 새로운 형태의 커스텀
              엘리먼트다.
            </p>
            <h3 id="counter-button-등록하기">counter-button 등록하기</h3>
            <pre><code class="language-javascript">class CounterButton extends HTMLElement {}

window.customElements.define(&#39;counter-button&#39;, CounterButton)
</code></pre>
            <h3 id="counter-button-내부-메서드-정의하기">counter-button 내부 메서드 정의하기</h3>
            <p><code>constructor</code>가 호출되는 시점에 <code>counter-button</code>의 shadowRoot 생성하고 shadowRoot 아래에 캡슐화된 UI 요소들을 삽입한다.</p>
            <pre><code class="language-javascript">class CounterButton extends HTMLElement {
  constructor() {
    super()
    const template = document.createElement(&#39;template&#39;)
    template.innerHTML = `
      &lt;style&gt;
        span {
          font-size: 20px;
        }
      &lt;/style&gt;

      &lt;span id=&quot;display&quot;&gt;&lt;/span&gt;
      &lt;button id=&quot;button&quot;&gt;+&lt;/button&gt;
    `

    const shadowRoot = this.attachShadow({ mode: &#39;open&#39; })
    shadowRoot.append(template.content.cloneNode(true))
  }
}

window.customElements.define(&#39;counter-button&#39;, CounterButton)
</code></pre>
            <p>
              <code>connectedCallback</code> 라이프 사이클을 통해 버튼 엘리먼트에 이벤트 리스너를 등록한다. <code>getter</code>를 정의해서 커스텀 엘리먼트
              내부의 요소에 쉽게 접근 할 수 있도록 한다.
            </p>
            <pre><code class="language-javascript">class CounterButton extends HTMLElement {
  constructor() {
    super()
    const template = document.createElement(&#39;template&#39;)
    template.innerHTML = `
      &lt;style&gt;
        span {
          font-size: 20px;
        }
      &lt;/style&gt;

      &lt;span id=&quot;display&quot;&gt;&lt;/span&gt;
      &lt;button id=&quot;button&quot;&gt;+&lt;/button&gt;
    `

    const shadowRoot = this.attachShadow({ mode: &#39;open&#39; })
    shadowRoot.append(template.content.cloneNode(true))
  }

  get display() {
    return this.shadowRoot.querySelector(&#39;#display&#39;)
  }

  get button() {
    return this.shadowRoot.querySelector(&#39;#button&#39;)
  }

  connectedCallback() {
    if (this.isConnected) {
      this.button.addEventListener(&#39;click&#39;, () =&gt; {
        this.buttonClickHandler()
      })
    }
  }

  buttonClickHandler() {
    const currentNumber = this.display.textContent ? Number(this.display.textContent) : 0
    this.display.textContent = currentNumber + 1
  }
}

window.customElements.define(&#39;counter-button&#39;, CounterButton)
</code></pre>
            <h3 id="counter-button-property를-통해-커스텀-엘리먼트-값-변경하기">counter-button Property를 통해 커스텀 엘리먼트 값 변경하기</h3>
            <pre><code class="language-javascript">class CounterButton extends HTMLElement {
  constructor() {
    super()
    const template = document.createElement(&#39;template&#39;)
    template.innerHTML = `
      &lt;style&gt;
        span {
          font-size: 20px;
        }
      &lt;/style&gt;

      &lt;span id=&quot;display&quot;&gt;&lt;/span&gt;
      &lt;button id=&quot;button&quot;&gt;+&lt;/button&gt;
    `

    const shadowRoot = this.attachShadow({ mode: &#39;open&#39; })
    shadowRoot.append(template.content.cloneNode(true))
  }

  get display() {
    return this.shadowRoot.querySelector(&#39;#display&#39;)
  }

  get button() {
    return this.shadowRoot.querySelector(&#39;#button&#39;)
  }

  connectedCallback() {
    if (this.isConnected) {
      this.button.addEventListener(&#39;click&#39;, () =&gt; {
        this.buttonClickHandler()
      })
    }
  }

  attributeChangedCallback(props, oldValue, newValue) {
    if (props === &#39;count&#39;) {
      this.countChangeHandler(newValue)
    }
  }

  static get observedAttributes() {
    return [&#39;count&#39;]
  }

  buttonClickHandler() {
    const currentNumber = this.display.textContent ? Number(this.display.textContent) : 0
    this.display.textContent = currentNumber + 1
  }

  countChangeHandler(newValue) {
    this.display.textContent = newValue
  }
}

window.customElements.define(&#39;counter-button&#39;, CounterButton)
</code></pre>
            <p>
              <code>attributeChangedCallback</code>과 <code>observedAttributes</code> 메서드를 구현하여 커스텀 엘리먼트의 <code>attribute</code>의 변화를
              감지하고 값을 반영 할 수 있도록 한다.
            </p>
            <h3 id="counter-button-html에서-사용하기">counter-button HTML에서 사용하기</h3>
            <pre><code class="language-html">...

&lt;script defer src=&quot;./counter-button.js&quot;&gt;&lt;/script&gt;

...

&lt;counter-button&gt;&lt;/counter-button&gt;

&lt;!-- or --&gt;

&lt;counter-button count=&quot;20&quot;&gt;&lt;/counter-button&gt;

...
</code></pre>
            <h2 id="마치며">마치며</h2>
            <p>
              커스텀 엘리먼트를 만드는 방법에 대해 간단하게 정리했다. Web Component의 주요 개념을 이해하기 위해서는 <code>shadow dom</code>과
              <code>template tag</code>에 대한 이해도 필요하다고 생각한다. 다른 포스팅을 통해 <code>shadow dom</code>과 <code>template tag</code> 정리해야겠다.
            </p>
          </section>
        </article>
        <section class="PostDetail_relatedPosting__VlXXV">
          <h2>연관 포스팅</h2>
          <ol class="PostSeriesLink_container__jtRUh">
            <li>
              <h3><span>다음글 - </span>Web component - Shadow DOM</h3>
              <a href="/web-component---shadow-dom">Web component의 핵심인 encapsulation은 어떻게 이루어질까? Shadow DOM의 이해</a>
            </li>
          </ol>
        </section>
        <section class="PostDetail_categoryGroup___S2ib">
          <h2>카테고리 더보기</h2>
          <ul class="CategoryPostGroup_container__MDFUe"></ul>
        </section>
        <section class="PostDetail_references__EU_hH">
          <h2>참고</h2>
          <ul class="PostDetail_references__EU_hH">
            <li>
              <a href="https%3A%2F%2Fhtml.spec.whatwg.org%2F%23valid-custom-element-name" target="_blank" rel="noreferrer">Custom element naming convention</a>
            </li>
            <li><a href="https%3A%2F%2Fwww.webcomponents.org%2F" target="_blank" rel="noreferrer">WebComponent org</a></li>
            <li>
              <a href="https%3A%2F%2Fweb.dev%2Fcustom-elements-v1%2F%23custom-element-reactions" target="_blank" rel="noreferrer"
                >https://web.dev/custom-elements-v1/#custom-element-reactions</a
              >
            </li>
          </ul>
        </section>
        <section class="PostDetail_utterances__jZeOm">
          <h2>댓글</h2>
          <div class="Utterrances_utteranceContainer__qopWy"></div>
        </section>
        <ins
          class="adsbygoogle"
          style="display: block"
          data-ad-client="ca-pub-7134579063537339"
          data-ad-slot="5391522351"
          data-ad-format="auto"
          data-full-width-responsive="true"
        ></ins>
      </main>
      <aside></aside>
      <footer class="Footer_footer__GLL0J"><p>ⓒ 2021. Jay Lee all rights reserved.</p></footer>
    </div>
    <script id="__NEXT_DATA__" type="application/json">
      {
        "props": {
          "pageProps": {
            "post": {
              "title": "Web component - custom element",
              "description": "웹 컴포넌트로 만드는 나만의 custom element",
              "fileName": "web-component-web-component---custom-element.md",
              "category": "web-component",
              "published": true,
              "publishedAt": "2022-07-31",
              "thumbnailName": "e0e40e28cf11f896033c8650f19188b7",
              "tags": [],
              "references": [
                { "title": "Custom element naming convention", "url": "https://html.spec.whatwg.org/#valid-custom-element-name" },
                { "title": "WebComponent org", "url": "https://www.webcomponents.org/" },
                {
                  "title": "https://web.dev/custom-elements-v1/#custom-element-reactions",
                  "url": "https://web.dev/custom-elements-v1/#custom-element-reactions"
                }
              ],
              "series": { "nextPostTitle": "Web component - Shadow DOM" },
              "order": 18
            },
            "content": "\u003ch2 id=\"table-of-contents\"\u003eTable of contents\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003e\u003ca href=\"#%EC%9B%B9-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8\"\u003e웹 컴포넌트\u003c/a\u003e\u003col\u003e\n\u003cli\u003e\u003ca href=\"#why-webcomponent\"\u003eWhy webcomponent?\u003c/a\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#%EC%BB%A4%EC%8A%A4%ED%85%80-%EC%97%98%EB%A6%AC%EB%A8%BC%ED%8A%B8\"\u003e커스텀 엘리먼트\u003c/a\u003e\u003col\u003e\n\u003cli\u003e\u003ca href=\"#%EC%BB%A4%EC%8A%A4%ED%85%80-%EC%97%98%EB%A6%AC%EB%A8%BC%ED%8A%B8-%EB%93%B1%EB%A1%9D%ED%95%98%EA%B8%B0\"\u003e커스텀 엘리먼트 등록하기\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#%EC%83%9D%EB%AA%85%EC%A3%BC%EA%B8%B0\"\u003e생명주기\u003c/a\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#custom-form\"\u003ecustom-form\u003c/a\u003e\u003col\u003e\n\u003cli\u003e\u003ca href=\"#custom-form-%EB%93%B1%EB%A1%9D%ED%95%98%EA%B8%B0\"\u003ecustom-form 등록하기\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#custom-form-%EB%82%B4%EB%B6%80-%EB%A9%94%EC%84%9C%EB%93%9C-%EC%A0%95%EC%9D%98%ED%95%98%EA%B8%B0\"\u003ecustom-form 내부 메서드 정의하기\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#custom-form-HTML%EC%97%90%EC%84%9C-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0\"\u003ecustom-form HTML에서 사용하기\u003c/a\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#counter-button\"\u003ecounter-button\u003c/a\u003e\u003col\u003e\n\u003cli\u003e\u003ca href=\"#counter-button-%EB%93%B1%EB%A1%9D%ED%95%98%EA%B8%B0\"\u003ecounter-button 등록하기\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#counter-button-%EB%82%B4%EB%B6%80-%EB%A9%94%EC%84%9C%EB%93%9C-%EC%A0%95%EC%9D%98%ED%95%98%EA%B8%B0\"\u003ecounter-button 내부 메서드 정의하기\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#counter-button-property%EB%A5%BC-%ED%86%B5%ED%95%B4-%EC%BB%A4%EC%8A%A4%ED%85%80-%EC%97%98%EB%A6%AC%EB%A8%BC%ED%8A%B8-%EA%B0%92-%EB%B3%80%EA%B2%BD%ED%95%98%EA%B8%B0\"\u003ecounter-button Property를 통해 커스텀 엘리먼트 값 변경하기\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#counter-button-html%EC%97%90%EC%84%9C-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0\"\u003ecounter-button HTML에서 사용하기\u003c/a\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#%EB%A7%88%EC%B9%98%EB%A9%B0\"\u003e마치며\u003c/a\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2 id=\"웹-컴포넌트\"\u003e웹 컴포넌트\u003c/h2\u003e\n\u003cp\u003e웹 컴포넌트는 존재하는 HTML \u003ccode\u003e태그를 확장\u003c/code\u003e하여 새로운 기능을 추가하고 \u003ccode\u003e캡슐화\u003c/code\u003e를 통해 외부 요소로 부터 독립적인 커스텀 엘리먼트를 제작하기 위한 웹 API의 모음이다.\u003c/p\u003e\n\u003cp\u003e웹 컴포넌트는 \u003ccode\u003e웹 표준\u003c/code\u003e을 따르기 때문에 대부분의 모던 브라우저에서 문제 없이 동작한다. 지금도 꾸준히 표준을 잡아가고 있으며 브라우저 \u003ccode\u003espec\u003c/code\u003e이 계속해서 정립되고 있다.\u003c/p\u003e\n\u003ch3 id=\"why-webcomponent\"\u003eWhy Webcomponent?\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e웹 컴포넌트는 \u003ccode\u003e캡슐화\u003c/code\u003e를 통해 기본적으로 외부 요소와 독립적으로 존재한다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e웹 컴포넌트 API를 통해 정의된 커스텀 엘리먼트는 캡슐화되어 존재하기 때문에 외부에서 주입되는 \u003ccode\u003estyle sheet\u003c/code\u003e의 영향을 받지 않는다.\n컴포넌트가 \u003ccode\u003e부품\u003c/code\u003e으로서의 가치를 갖기 위해서는 어떠한 환경에서 사용 되더라도 동일한 기능과 형태를 유지해야 한다. 이런 관점에서 웹 컴포넌트로 생성된 커스텀 엘리먼트는 \u003ccode\u003eshadow root\u003c/code\u003e라는 영역에 독립적으로 존재하며 외부의 \u003ccode\u003estyle sheet\u003c/code\u003e에 의해 형태가 변형되지 않는다.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e물론 필요에 따라 외부의 style sheet의 영향을 받도록 설정할 수 있다.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e더불어 커스텀 엘리먼트 내부에서 발생하는 이벤트의 버블링은 기본적으로 \u003ccode\u003eshadow root\u003c/code\u003e를 벗어 날 수 없다. 이는 이벤트 버블링에 의해 야기될 수 있는 사이드 이펙트를 방지 할 수 있도록 돕는다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e표준 API를 사용해 어떤 라이브러리 또는 프레임워크를 통해 구성된 웹 앱에서도 동작 할 수 있다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e웹 표준 API를 통해 구현되는 커스텀 엘리먼트는 사용자의 브라우저 환경이 이를 지원한다면 (대부분의 모던 브라우저가 지원하고 있다.) 별도의 라이브러리에 의존하지 않는다. 다시말해 \u003ccode\u003eReact\u003c/code\u003e로 구성 되었건 \u003ccode\u003eVue\u003c/code\u003e로 구성 되었건 화면의 일부 요소는 얼마든지 \u003ccode\u003ecustom element\u003c/code\u003e로 구현 할 수 있다.\n\u003ccode\u003e어떤 환경에서도 사용 할 수 있는 것\u003c/code\u003e 또한 컴포넌트로서의 가치를 증가 시킬수 있는 요소다.\u003c/p\u003e\n\u003ch2 id=\"커스텀-엘리먼트\"\u003e커스텀 엘리먼트\u003c/h2\u003e\n\u003cp\u003e커스텀 엘리먼트는 \u003ccode\u003eCustomElementRegistry\u003c/code\u003e 객체를 통해 제어 할 수 있다. \u003ccode\u003eCustomElementRegistry\u003c/code\u003e 객체의 \u003ccode\u003edefine\u003c/code\u003e 메서드를 통해 새로운 커스텀 엘리먼트를 등록하게 된다.\u003c/p\u003e\n\u003cp\u003e커스텀 엘리먼트는 반드시 \u003ccode\u003ekebab-case\u003c/code\u003e 형식의 명칭을 사용해야 하는데 이는 미래에 추가될 \u003ccode\u003ehtml\u003c/code\u003e 네이티브 태그와 구분하기 위함이다. (새롭게 추가될 html 태그는 절대 \u003ccode\u003e-\u003c/code\u003e을 포함하지 않을 것이기 때문에) - \u003ca href=\"https://html.spec.whatwg.org/#valid-custom-element-name\"\u003eCustom element naming convention\u003c/a\u003e\u003c/p\u003e\n\u003ch3 id=\"커스텀-엘리먼트-등록하기\"\u003e커스텀 엘리먼트 등록하기\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003ewindow.customElements.define(\u0026#39;custom-element\u0026#39;, CustomElement)\n\n// or\n\nwindow.customElements.define(\u0026#39;custom-element\u0026#39;, CustomElement, { extends: \u0026#39;form\u0026#39; })\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003edefine\u003c/code\u003e 메서드는 다음 세가지의 매개변수를 전달 받을 수 있다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eDOMString: 커스텀 엘리먼트의 이름\u003c/li\u003e\n\u003cli\u003eclass 객체: 커스텀 엘리먼트의 동작을 정의한 \u003ccode\u003eclass\u003c/code\u003e 객체\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eoptional\u003c/code\u003e extends 속성: 현재 커스텀 엘리먼트가 상속 받는 대상 태그\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"생명주기\"\u003e생명주기\u003c/h3\u003e\n\u003cp\u003e커스텀 엘리먼트를 등록하기 위해 동작에 대한 정의를 담고 있는 class 객체를 생성해야한다.\nclass 객체는 생명주기를 갖고 있으며 생명주기에 따라 적절한 동작을 정의해야한다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003econstructor: 커스텀 엘리먼트의 인스턴스가 생성될 때마다 호출됨\u003c/li\u003e\n\u003cli\u003econnectedCallback: 커스텀 엘리먼트가 \u003ccode\u003edocument\u003c/code\u003e에 추가될 때마다 호출됨\u003c/li\u003e\n\u003cli\u003edisconnectedCallback: 커스텀 엘리먼트가 \u003ccode\u003edocument\u003c/code\u003e에서 제거 될 때마다 호출됨\u003c/li\u003e\n\u003cli\u003eadoptedCallback: 커스텀 엘리먼트가 새로운 \u003ccode\u003edocument\u003c/code\u003e로 이동할 때마다 호출됨\u003c/li\u003e\n\u003cli\u003eattributeChangedCallback: 커스텀 엘리먼트의 attribute가 변화할 때 마다 호출됨\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e이런 생명주기를 통해 이벤트 리스너를 등록/제거 하거나 특정 속성의 변화에 따른 동작을 구현할 수 있고 데이터 패칭과 같이 컴포넌트 초기화 시점에 필요한 상태들을 설정할 때 사용할 수 있다. - \u003ca href=\"https://web.dev/custom-elements-v1/#custom-element-reactions\"\u003ehttps://web.dev/custom-elements-v1/#custom-element-reactions\u003c/a\u003e\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eattributeChangedCallback(attrName, oldVal, newVal)\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eattributeChangedCallback\u003c/code\u003e은 상기와 같은 매개변수를 전달 받는다. 이렇게 attributeChangedCallback을 통해 관리 돼야하는 \u003ccode\u003eattribute\u003c/code\u003e는 반드시 객체 내부의 \u003ccode\u003eobservedAttributes\u003c/code\u003e 배열로 작성되어야 한다.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch2 id=\"custom-form\"\u003ecustom-form\u003c/h2\u003e\n\u003cp\u003e앞서 살펴본 커스텀 엘리먼트의 기본적인 요소들을 바탕으로 \u003ccode\u003ecustom-form\u003c/code\u003e을 작성한다.\n\u003ccode\u003ecustom-form\u003c/code\u003e은 기존 \u003ccode\u003eform\u003c/code\u003e 태그를 상속 받아 \u003ccode\u003eserialize\u003c/code\u003e라는 내부 메서드를 갖는다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eserialize\u003c/code\u003e 메서드는 \u003ccode\u003eform\u003c/code\u003e 내부에 정의된 입력 요소들 (\u003ccode\u003einput\u003c/code\u003e, \u003ccode\u003eselect\u003c/code\u003e, \u003ccode\u003etextarea\u003c/code\u003e 와 같은)의 값을 추출하고 입력된 \u003ccode\u003etype\u003c/code\u003e에 따라 값을 변형하여 return하는 역할을 하게 된다.\u003c/p\u003e\n\u003ch3 id=\"custom-form-등록하기\"\u003ecustom-form 등록하기\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003eclass CustomForm extends HTMLFormElement {}\n\nwindow.customElements.define(\u0026#39;custom-form\u0026#39;, CustomForm, { extends: \u0026#39;form\u0026#39; })\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"custom-form-내부-메서드-정의하기\"\u003ecustom-form 내부 메서드 정의하기\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003eclass CustomForm extends HTMLFormElement {\n  serialize() {\n    const elements = Array.from(this.querySelectorAll(\u0026#39;input,select,textarea\u0026#39;))\n    if (elements.some((element) =\u0026gt; !element.name)) {\n      throw new Error(\u0026#39;Failed to find field name\u0026#39;)\n    }\n\n    let result = {}\n\n    elements.forEach(({ name, type, value, checked }) =\u0026gt; {\n      switch (type) {\n        case \u0026#39;number\u0026#39;:\n          result[name] = Number(value)\n          break\n\n        case \u0026#39;checkbox\u0026#39;:\n          result[name] = checked\n          break\n\n        default:\n          result[name] = value\n      }\n    })\n\n    return result\n  }\n}\n\nwindow.customElements.define(\u0026#39;custom-form\u0026#39;, CustomForm, { extends: \u0026#39;form\u0026#39; })\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003eCustomForm\u003c/code\u003e class 내부에 \u003ccode\u003eserialize\u003c/code\u003e라는 명칭의 메서드를 정의한다. \u003ccode\u003eform\u003c/code\u003e 내부에 존재하는 입력 요소들을 찾아 필드 명칭을 확인하고 데이터 유형에 따라 변형한 값을 객체에 담아 반환한다.\u003c/p\u003e\n\u003ch3 id=\"custom-form-html에서-사용하기\"\u003ecustom-form HTML에서 사용하기\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-html\"\u003e...\n\n\u0026lt;script defer src=\u0026quot;./custom-form.js\u0026quot;\u0026gt;\u0026lt;/script\u0026gt;\n\n...\n\n\u0026lt;form id=\u0026quot;custom-form\u0026quot; is=\u0026quot;custom-form\u0026quot;\u0026gt;\n  \u0026lt;input type=\u0026quot;text\u0026quot; name=\u0026quot;text\u0026quot; /\u0026gt;\n  \u0026lt;input type=\u0026quot;number\u0026quot; name=\u0026quot;number\u0026quot; /\u0026gt;\n  \u0026lt;input type=\u0026quot;date\u0026quot; name=\u0026quot;date\u0026quot; /\u0026gt;\n  \u0026lt;input type=\u0026quot;checkbox\u0026quot; name=\u0026quot;checkbox\u0026quot; /\u0026gt;\n  \u0026lt;textarea name=\u0026quot;textarea\u0026quot;\u0026gt;\u0026lt;/textarea\u0026gt;\n  \u0026lt;select name=\u0026quot;option\u0026quot;\u0026gt;\n    \u0026lt;option\u0026gt;Option 1\u0026lt;/option\u0026gt;\n    \u0026lt;option\u0026gt;Option 2\u0026lt;/option\u0026gt;\n    \u0026lt;option\u0026gt;Option 3\u0026lt;/option\u0026gt;\n  \u0026lt;/select\u0026gt;\n\u0026lt;/form\u0026gt;\n\n...\n\n\u0026lt;script\u0026gt;\n  const formData = document.querySelector(\u0026#39;#custom-form\u0026#39;).serialize()\n  console.log(formData)\n\u0026lt;/script\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e예제에서 처럼 기존의 HTML 태그를 상속 받아 사용할 경우 \u003ccode\u003eis\u003c/code\u003e 속성을 통해 사용하고자 하는 커스텀 엘리먼트의 명칭을 입력한다.\u003c/p\u003e\n\u003ch2 id=\"counter-button\"\u003ecounter-button\u003c/h2\u003e\n\u003cp\u003e버튼을 클릭하면 숫자가 올라가는 간단한 커스텀 엘리먼트를 작성한다. 기존에 존재하는 태그의 기능을 상속 받지 않는 완전히 새로운 형태의 커스텀 엘리먼트다.\u003c/p\u003e\n\u003ch3 id=\"counter-button-등록하기\"\u003ecounter-button 등록하기\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003eclass CounterButton extends HTMLElement {}\n\nwindow.customElements.define(\u0026#39;counter-button\u0026#39;, CounterButton)\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"counter-button-내부-메서드-정의하기\"\u003ecounter-button 내부 메서드 정의하기\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003econstructor\u003c/code\u003e가 호출되는 시점에 \u003ccode\u003ecounter-button\u003c/code\u003e의 shadowRoot 생성하고 shadowRoot 아래에 캡슐화된 UI 요소들을 삽입한다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003eclass CounterButton extends HTMLElement {\n  constructor() {\n    super()\n    const template = document.createElement(\u0026#39;template\u0026#39;)\n    template.innerHTML = `\n      \u0026lt;style\u0026gt;\n        span {\n          font-size: 20px;\n        }\n      \u0026lt;/style\u0026gt;\n\n      \u0026lt;span id=\u0026quot;display\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;\n      \u0026lt;button id=\u0026quot;button\u0026quot;\u0026gt;+\u0026lt;/button\u0026gt;\n    `\n\n    const shadowRoot = this.attachShadow({ mode: \u0026#39;open\u0026#39; })\n    shadowRoot.append(template.content.cloneNode(true))\n  }\n}\n\nwindow.customElements.define(\u0026#39;counter-button\u0026#39;, CounterButton)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003econnectedCallback\u003c/code\u003e 라이프 사이클을 통해 버튼 엘리먼트에 이벤트 리스너를 등록한다.\n\u003ccode\u003egetter\u003c/code\u003e를 정의해서 커스텀 엘리먼트 내부의 요소에 쉽게 접근 할 수 있도록 한다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003eclass CounterButton extends HTMLElement {\n  constructor() {\n    super()\n    const template = document.createElement(\u0026#39;template\u0026#39;)\n    template.innerHTML = `\n      \u0026lt;style\u0026gt;\n        span {\n          font-size: 20px;\n        }\n      \u0026lt;/style\u0026gt;\n\n      \u0026lt;span id=\u0026quot;display\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;\n      \u0026lt;button id=\u0026quot;button\u0026quot;\u0026gt;+\u0026lt;/button\u0026gt;\n    `\n\n    const shadowRoot = this.attachShadow({ mode: \u0026#39;open\u0026#39; })\n    shadowRoot.append(template.content.cloneNode(true))\n  }\n\n  get display() {\n    return this.shadowRoot.querySelector(\u0026#39;#display\u0026#39;)\n  }\n\n  get button() {\n    return this.shadowRoot.querySelector(\u0026#39;#button\u0026#39;)\n  }\n\n  connectedCallback() {\n    if (this.isConnected) {\n      this.button.addEventListener(\u0026#39;click\u0026#39;, () =\u0026gt; {\n        this.buttonClickHandler()\n      })\n    }\n  }\n\n  buttonClickHandler() {\n    const currentNumber = this.display.textContent ? Number(this.display.textContent) : 0\n    this.display.textContent = currentNumber + 1\n  }\n}\n\nwindow.customElements.define(\u0026#39;counter-button\u0026#39;, CounterButton)\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"counter-button-property를-통해-커스텀-엘리먼트-값-변경하기\"\u003ecounter-button Property를 통해 커스텀 엘리먼트 값 변경하기\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003eclass CounterButton extends HTMLElement {\n  constructor() {\n    super()\n    const template = document.createElement(\u0026#39;template\u0026#39;)\n    template.innerHTML = `\n      \u0026lt;style\u0026gt;\n        span {\n          font-size: 20px;\n        }\n      \u0026lt;/style\u0026gt;\n\n      \u0026lt;span id=\u0026quot;display\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;\n      \u0026lt;button id=\u0026quot;button\u0026quot;\u0026gt;+\u0026lt;/button\u0026gt;\n    `\n\n    const shadowRoot = this.attachShadow({ mode: \u0026#39;open\u0026#39; })\n    shadowRoot.append(template.content.cloneNode(true))\n  }\n\n  get display() {\n    return this.shadowRoot.querySelector(\u0026#39;#display\u0026#39;)\n  }\n\n  get button() {\n    return this.shadowRoot.querySelector(\u0026#39;#button\u0026#39;)\n  }\n\n  connectedCallback() {\n    if (this.isConnected) {\n      this.button.addEventListener(\u0026#39;click\u0026#39;, () =\u0026gt; {\n        this.buttonClickHandler()\n      })\n    }\n  }\n\n  attributeChangedCallback(props, oldValue, newValue) {\n    if (props === \u0026#39;count\u0026#39;) {\n      this.countChangeHandler(newValue)\n    }\n  }\n\n  static get observedAttributes() {\n    return [\u0026#39;count\u0026#39;]\n  }\n\n  buttonClickHandler() {\n    const currentNumber = this.display.textContent ? Number(this.display.textContent) : 0\n    this.display.textContent = currentNumber + 1\n  }\n\n  countChangeHandler(newValue) {\n    this.display.textContent = newValue\n  }\n}\n\nwindow.customElements.define(\u0026#39;counter-button\u0026#39;, CounterButton)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003eattributeChangedCallback\u003c/code\u003e과 \u003ccode\u003eobservedAttributes\u003c/code\u003e 메서드를 구현하여 커스텀 엘리먼트의 \u003ccode\u003eattribute\u003c/code\u003e의 변화를 감지하고 값을 반영 할 수 있도록 한다.\u003c/p\u003e\n\u003ch3 id=\"counter-button-html에서-사용하기\"\u003ecounter-button HTML에서 사용하기\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-html\"\u003e...\n\n\u0026lt;script defer src=\u0026quot;./counter-button.js\u0026quot;\u0026gt;\u0026lt;/script\u0026gt;\n\n...\n\n\u0026lt;counter-button\u0026gt;\u0026lt;/counter-button\u0026gt;\n\n\u0026lt;!-- or --\u0026gt;\n\n\u0026lt;counter-button count=\u0026quot;20\u0026quot;\u0026gt;\u0026lt;/counter-button\u0026gt;\n\n...\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"마치며\"\u003e마치며\u003c/h2\u003e\n\u003cp\u003e커스텀 엘리먼트를 만드는 방법에 대해 간단하게 정리했다. Web Component의 주요 개념을 이해하기 위해서는 \u003ccode\u003eshadow dom\u003c/code\u003e과 \u003ccode\u003etemplate tag\u003c/code\u003e에 대한 이해도 필요하다고 생각한다.\n다른 포스팅을 통해 \u003ccode\u003eshadow dom\u003c/code\u003e과 \u003ccode\u003etemplate tag\u003c/code\u003e 정리해야겠다.\u003c/p\u003e\n",
            "postsByCategory": [
              {
                "title": "Web component - Shadow DOM",
                "description": "Web component의 핵심인 encapsulation은 어떻게 이루어질까?\nShadow DOM의 이해",
                "fileName": "web-component-web-component---shadow-dom.md",
                "category": "web-component",
                "published": true,
                "publishedAt": "2022-08-10",
                "thumbnailName": "ab751eb302db9d348765b3134068a6aa",
                "tags": [
                  "Shadow DOM",
                  "custom element",
                  "encapsulation",
                  "shadow",
                  "shadow tree",
                  "web component",
                  "쉐도우",
                  "쉐도우 돔",
                  "쉐도우 트리",
                  "웹 컴포넌트",
                  "은닉화",
                  "커스텀 엘리먼트"
                ],
                "references": [
                  { "title": "MDN - Composed", "url": "https://developer.mozilla.org/en-US/docs/Web/API/Event/composed" },
                  { "title": "MDN - Using shadow DOM", "url": "https://developer.mozilla.org/ko/docs/Web/Web_Components/Using_shadow_DOM" }
                ],
                "series": { "prevPostTitle": "Web component - custom element" },
                "order": 22
              }
            ]
          },
          "__N_SSG": true
        },
        "page": "/[title]",
        "query": { "title": "web-component---custom-element" },
        "buildId": "5Hhuw6icEhH2OOBBJ38VN",
        "isFallback": false,
        "gsp": true,
        "scriptLoader": []
      }
    </script>
  </body>
</html>
