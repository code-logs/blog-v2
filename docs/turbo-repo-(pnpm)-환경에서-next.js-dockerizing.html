<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><link rel="canonical" href="https://code-logs.github.io/turbo-repo-(pnpm)-환경에서-next.js-dockerizing"/><link rel="apple-touch-icon" href="/icons/icon-192x-192.png"/><link rel="manifest" href="/manifest.json"/><meta name="theme-color" content="#fff"/><meta property="og:type" content="website"/><meta property="og:site_name" content="Code Logs"/><meta name="author" content="Jay Lee"/><meta name="viewport" content="width=device-width, user-scalable=no"/><meta name="keyword" content="docker, dockerizing, monorepo, next.js, pnpm, turbo, turbo repo, 개발환경, 모노리포, 빌드, 빌드 시스템, Turbo repo (pnpm) 환경에서 Next.js Dockerizing, Turbo repo와 pnpm 환경에서 Next.js Dockerizing 하기, infrastructure"/><meta name="description" content="Code Logs Turbo repo (pnpm) 환경에서 Next.js Dockerizing - Turbo repo와 pnpm 환경에서 Next.js Dockerizing 하기 | infrastructure, docker, dockerizing, monorepo, next.js, pnpm, turbo, turbo repo, 개발환경, 모노리포, 빌드, 빌드 시스템"/><meta property="og:description" content="Code Logs Turbo repo (pnpm) 환경에서 Next.js Dockerizing - Turbo repo와 pnpm 환경에서 Next.js Dockerizing 하기 | infrastructure, docker, dockerizing, monorepo, next.js, pnpm, turbo, turbo repo, 개발환경, 모노리포, 빌드, 빌드 시스템"/><meta property="og:title" content="Turbo repo (pnpm) 환경에서 Next.js Dockerizing | Code Logs"/><meta property="og:url" content="https://code-logs.github.io/turbo-repo-(pnpm)-환경에서-next.js-dockerizing"/><meta property="og:image" content="/assets/images/turbo-pnpm-nextjs-dockerizing.webp"/><title>Turbo repo (pnpm) 환경에서 Next.js Dockerizing | Code Logs</title><meta name="next-head-count" content="16"/><link rel="preload" href="/_next/static/css/29a66addcc8c07ce.css" as="style"/><link rel="stylesheet" href="/_next/static/css/29a66addcc8c07ce.css" data-n-g=""/><link rel="preload" href="/_next/static/css/a9f71118156934ed.css" as="style"/><link rel="stylesheet" href="/_next/static/css/a9f71118156934ed.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script src="/_next/static/chunks/webpack-2e51481b1d484a05.js" defer=""></script><script src="/_next/static/chunks/framework-5f4595e5518b5600.js" defer=""></script><script src="/_next/static/chunks/main-a4d9e436b9a532ca.js" defer=""></script><script src="/_next/static/chunks/pages/_app-2a86e51ee3e66f08.js" defer=""></script><script src="/_next/static/chunks/294-cb5252cdae161d2e.js" defer=""></script><script src="/_next/static/chunks/867-0f29e514e1174563.js" defer=""></script><script src="/_next/static/chunks/pages/%5Btitle%5D-6715b0273a6db0ac.js" defer=""></script><script src="/_next/static/8hg3Wv6jOEFOXWQALigER/_buildManifest.js" defer=""></script><script src="/_next/static/8hg3Wv6jOEFOXWQALigER/_ssgManifest.js" defer=""></script><script src="/_next/static/8hg3Wv6jOEFOXWQALigER/_middlewareManifest.js" defer=""></script></head><body><div id="__next" data-reactroot=""><header class="Header_header__RW35m"><span class="Header_title__GPS8b">Code Logs</span><ul class="Header_socialIcons__CBf_s"><li><a href="https://github.com/possible819" target="_blank" rel="noreferrer" aria-label="My Github"><style data-emotion="css vubbuv">.css-vubbuv{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;width:1em;height:1em;display:inline-block;fill:currentColor;-webkit-flex-shrink:0;-ms-flex-negative:0;flex-shrink:0;-webkit-transition:fill 200ms cubic-bezier(0.4, 0, 0.2, 1) 0ms;transition:fill 200ms cubic-bezier(0.4, 0, 0.2, 1) 0ms;font-size:1.5rem;}</style><svg class="MuiSvgIcon-root MuiSvgIcon-fontSizeMedium css-vubbuv" focusable="false" aria-hidden="true" viewBox="0 0 24 24" data-testid="GitHubIcon"><path d="M12 1.27a11 11 0 00-3.48 21.46c.55.09.73-.28.73-.55v-1.84c-3.03.64-3.67-1.46-3.67-1.46-.55-1.29-1.28-1.65-1.28-1.65-.92-.65.1-.65.1-.65 1.1 0 1.73 1.1 1.73 1.1.92 1.65 2.57 1.2 3.21.92a2 2 0 01.64-1.47c-2.47-.27-5.04-1.19-5.04-5.5 0-1.1.46-2.1 1.2-2.84a3.76 3.76 0 010-2.93s.91-.28 3.11 1.1c1.8-.49 3.7-.49 5.5 0 2.1-1.38 3.02-1.1 3.02-1.1a3.76 3.76 0 010 2.93c.83.74 1.2 1.74 1.2 2.94 0 4.21-2.57 5.13-5.04 5.4.45.37.82.92.82 2.02v3.03c0 .27.1.64.73.55A11 11 0 0012 1.27"></path></svg></a></li></ul><nav class="NavBar_navBar__akqA3"><ul><li class="clickable"><a href="/" class="MarkedAnchor_anchor__QCmkL">Home</a></li><li class="clickable"><a href="/posts/1" class="MarkedAnchor_anchor__QCmkL">Posts</a></li><li class="clickable"><a href="/about" class="MarkedAnchor_anchor__QCmkL">About</a></li></ul></nav></header><main><article class="PostDetail_container__Ma_26"><p class="PostDetail_publishedAt__7GOQm"><span>23.05.01</span></p><section class="PostDetail_thumbnailWrapper__oALCg"><img src="/assets/images/turbo-pnpm-nextjs-dockerizing.webp" alt="Turbo repo와 pnpm 환경에서 Next.js Dockerizing 하기" width="400" height="300"/></section><div class="style_bannerContainer__so5Cp"><a href="https://m.youtube.com/@cat_bread." target="_blank" rel="noreferrer"><img src="/assets/banners/cat-bread.webp" alt="고양이 빵 Cat bread - 세마리의 고양이와 홈베이킹 이야기" width="400" height="131"/></a></div><section><h1>Turbo repo (pnpm) 환경에서 Next.js Dockerizing</h1><p class="PostDetail_description__l6wHC">Turbo repo와 pnpm 환경에서 Next.js Dockerizing 하기</p></section><section id="content"><h2 id="table-of-contents">Table of contents</h2>
<ol>
<li><a href="#package-manager">Package Manager</a><ol>
<li><a href="#pnpm-workspaceyaml-%ED%8C%8C%EC%9D%BC-%EC%83%9D%EC%84%B1">pnpm-workspace.yaml 파일 생성</a></li>
<li><a href="#pnpm-lockyaml-%ED%8C%8C%EC%9D%BC-%EC%83%9D%EC%84%B1">pnpm-lock.yaml 파일 생성</a></li>
</ol>
</li>
<li><a href="#packagejson">package.json</a></li>
<li><a href="#dockerignore">dockerignore</a><ol>
<li><a href="#node_modules">node_modules</a></li>
<li><a href="#out">out</a></li>
</ol>
</li>
<li><a href="#dockerfile">Dockerfile</a><ol>
<li><a href="#pnpm-%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%EC%82%AC%EC%9A%A9">pnpm 스크립트 사용</a></li>
</ol>
</li>
<li><a href="#nextconfigjs">next.config.js</a><ol>
<li><a href="#experimentaloutputfiletracingroot">experimental.outputFileTracingRoot</a></li>
</ol>
</li>
</ol>
<h2 id="package-manager">Package Manager</h2>
<p><code>pnpm</code>을 패키지 매니저로 사용하도록 설정해야 한다 이미 <code>pnpm</code>을 프로젝트의 패키지 매니저로 사용하고 있다면 현재 과정은 생략한다.</p>
<h3 id="pnpm-workspaceyaml-파일-생성">pnpm-workspace.yaml 파일 생성</h3>
<p>기존에 <code>pnpm</code>을 사용하지 않았다면 <code>package.json</code>에 설정되어 있는 <code>workspace</code>를 <code>pnpm-workspace.yaml</code> 파일을 통해 참조 할 수 있도록 <code>pnpm-workspace.yaml</code> 파일을 생성해야 한다.</p>
<pre><code class="language-yaml">packages:
  - &#39;apps/*&#39;
  - &#39;packages/*&#39;
</code></pre>
<blockquote>
<p><code>package.json</code> 파일에 있는 <code>workspace</code> 설정은 제거한다.</p>
</blockquote>
<h3 id="pnpm-lockyaml-파일-생성">pnpm-lock.yaml 파일 생성</h3>
<p>정상적으로 <code>pnpm</code>을 통한 <code>workspace</code> 설정이 완료되면 <code>pnpm install</code> 커맨드를 통해 <code>pnpm-lock.yaml</code> 파일을 생성한다. 이후 <code>Docker</code>를 통해 빌드를 진행할 때 lock 파일을 바탕으로 개발환경과 동일한 디펜던시를 설치하기 위해 빌드를 시작하기 전에 반드시 lock 파일을 생성해야 한다.</p>
<h2 id="packagejson">package.json</h2>
<p><code>pnpm -v</code> 커맨드를 통해 현재 설치된 <code>pnpm</code>의 버전을 확인하고 <code>package.json</code>에 <code>packageManager</code> 프로퍼티를 아래와 같은 형태로 수정한다.</p>
<pre><code class="language-json">{
  ...
    &quot;packageManager&quot;: &quot;pnpm@8.1.1&quot;
  ...
}
</code></pre>
<h2 id="dockerignore">dockerignore</h2>
<h3 id="node_modules">node_modules</h3>
<p><code>pnpm</code>을 통해 패키지를 설정하면 모노리포의 애플리케이션 디렉토리에 설치되는 모듈은 <code>symbolic link</code>를 통해 <code>workspace</code> 루트의 모듈을 참조한다.
<code>Docker</code> 빌드 과정에서 설치한 모듈을 복사하게 되는데 이렇게 링크로 생성된 파일은 에러를 발생 시킨다.</p>
<blockquote>
<p><code>symbolic link</code>를 통한 참조는 실행환경에 따라 다르기 때문에 <code>Docker</code>를 통한 빌드가 항상 동일한 결과를 만든다는 것을 보장 할 수 없기 때문에 <code>symbolic link</code>를 빌드 과정에 개입 시키는 것을 방지하고 있다.</p>
</blockquote>
<p><code>dockerignore</code> 파일에 <code>**/node_modules</code>를 추가해서 모든 루트 디렉토리 뿐 아니라 하위 패키지에 설치된 <code>node_modules</code> 디렉토리도 복사 대상이 되지 않도록 제외해야 한다.</p>
<h3 id="out">out</h3>
<p><code>Docker</code>는 빌드시 생성된 파일을 캐싱하고 캐싱 된 레이어를 통해 동일한 작업을 반복하지 않도록 하여 성능을 최적화 한다.</p>
<p><code>Dockerizing</code> 대상이 되지 않는 파일의 <code>package.json</code>을 빌드 대상에 포함 시키면 빌드와는 관계가 없는 모듈의 패키지 의존 정보가 변경됨에 따라 캐싱된 레이어를 파기하고 다시 한번 불필요한 빌드 과정을 수행하게 된다. 결과적으로 <code>Dockerizing</code>의 성능 최적화 이점을 사용 할 수 없게 된다.</p>
<p><code>turbo</code>는 이런 최적화를 그대로 사용 할 수 있도록 <code>prune</code> 커맨드를 제공한다. <code>prune</code> 커맨드를 실행하면 특정된 <code>scope</code>와 관계 있는 패키지들의 <code>package.json</code> 파일을 추출하고 <code>out</code> 디렉토리에 저장한다.</p>
<pre><code class="language-sh">$ turbo prune --scope=&lt;target&gt;
</code></pre>
<p><code>out</code> 디렉토리가 <code>dockerignore</code>에 포함되지 않은 상태로 이미지 빌드를 하게 되면 <code>out</code> 디렉토리가 이미지 안쪽에 복사되는 문제가 발생 할 수 있다. <code>docker</code> 이미지 빌드 시점에 <code>out</code> 디렉토리가 <code>COPY</code> 커맨드의 대상이 되지 않도록 <code>dockerignore</code>에 추가한다.</p>
<blockquote>
<p><code>turbo</code> 프로젝트를 스캐폴딩하고 나면 기본적으로 <code>out</code> 디렉토리는 <code>gitignore</code> 항목으로 추가되어 있다.
일반적으로 <code>github action</code>과 같은 <code>CI/CD</code> 툴을 사용한다면 소스 코드를 remote 저장소에서 가지고 오기 때문에 <code>out</code> 디렉토리가 존재하지 않는다.</p>
</blockquote>
<h2 id="dockerfile">Dockerfile</h2>
<h3 id="pnpm-스크립트-사용">pnpm 스크립트 사용</h3>
<p>패키지 설치, 빌드를 위해 실행하는 커맨드를 <code>pnpm</code>을 사용하도록 수정한다.</p>
<p>패키지 설치 스크립트는 <code>---frozen-lockfile</code> 옵션을 추가해서 <code>pnpm-lock.yaml</code> 파일을 참조하여 개발환경과 정확히 일치하는 디펜던시를 설치 할 수 있도록 강제해야 한다.</p>
<blockquote>
<p><code>pnpm</code>을 통해 스크립트를 실행해야 하는 <code>intermediate layer</code>에서 커맨드 실행전 <code>npm</code>을 통해 <code>pnpm</code>을 전역에 설치 할 필요가 있다.</p>
</blockquote>
<h2 id="nextconfigjs">next.config.js</h2>
<h3 id="experimentaloutputfiletracingroot"><code>experimental.outputFileTracingRoot</code></h3>
<p><code>pnpm</code>을 통해 모노리포 환경에서 디펜던시를 설치하게 되면 앞서 이야기한 바와 같이 모든 디펜던시를 프로젝트의 루트 디렉토리에 설치하게 된다. 최종적으로 서버를 실행하는데 사용되는 <code>server.js</code> 파일은 이런 구조에 대한 참조를 정확히 하고 있지 않다. <code>Next.js</code>는 이런 경우를 위한 옵션을 제공하는데 <code>experimental.outputFileTracingRoot</code> 설정을 통해 <code>server.js</code> 파일과 동일한 디렉토리에 모듈이 설치 될 수 있도록 한다.</p>
<pre><code class="language-json">{
  // next.config.js
  ...
  experimental: {
    outputFileTracingRoot: path.join(__dirname, &#39;../../) // 패키지의 애플리케이션 디렉토리 부터 프로젝트 루트 까지 경로를 설정
  },
  ...
}
</code></pre>
</section></article><section class="MainAdsBanner_container__YWe5C"><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-7134579063537339" data-ad-slot="5391522351" data-ad-format="auto" data-full-width-responsive="true"></ins></section><section class="PostDetail_categoryGroup___S2ib"><h2>카테고리 더보기</h2><ul class="CategoryPostGroup_container__MDFUe"></ul></section><section class="PostDetail_references__EU_hH"><h2>참고</h2><ul class="PostDetail_references__EU_hH"><li><a href="https://turbo.build/repo/docs/handbook/deploying-with-docker" target="_blank" rel="noreferrer">Turbo - Deploying with Docker</a></li></ul></section><section class="PostDetail_utterances__jZeOm"><h2>댓글</h2><div class="Utterrances_utteranceContainer__qopWy"></div></section></main><aside></aside><footer class="Footer_footer__GLL0J"><p>ⓒ 2021. Jay Lee  all rights reserved.</p></footer></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"Turbo repo (pnpm) 환경에서 Next.js Dockerizing","description":"Turbo repo와 pnpm 환경에서 Next.js Dockerizing 하기","fileName":"turbo-repo-nextjs-dockerizing.md","category":"infrastructure","published":true,"publishedAt":"2023-05-01","thumbnailName":"turbo-pnpm-nextjs-dockerizing.webp","tags":["docker","dockerizing","monorepo","next.js","pnpm","turbo","turbo repo","개발환경","모노리포","빌드","빌드 시스템"],"references":[{"title":"Turbo - Deploying with Docker","url":"https://turbo.build/repo/docs/handbook/deploying-with-docker"}],"order":24},"content":"\u003ch2 id=\"table-of-contents\"\u003eTable of contents\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003e\u003ca href=\"#package-manager\"\u003ePackage Manager\u003c/a\u003e\u003col\u003e\n\u003cli\u003e\u003ca href=\"#pnpm-workspaceyaml-%ED%8C%8C%EC%9D%BC-%EC%83%9D%EC%84%B1\"\u003epnpm-workspace.yaml 파일 생성\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#pnpm-lockyaml-%ED%8C%8C%EC%9D%BC-%EC%83%9D%EC%84%B1\"\u003epnpm-lock.yaml 파일 생성\u003c/a\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#packagejson\"\u003epackage.json\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#dockerignore\"\u003edockerignore\u003c/a\u003e\u003col\u003e\n\u003cli\u003e\u003ca href=\"#node_modules\"\u003enode_modules\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#out\"\u003eout\u003c/a\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#dockerfile\"\u003eDockerfile\u003c/a\u003e\u003col\u003e\n\u003cli\u003e\u003ca href=\"#pnpm-%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%EC%82%AC%EC%9A%A9\"\u003epnpm 스크립트 사용\u003c/a\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#nextconfigjs\"\u003enext.config.js\u003c/a\u003e\u003col\u003e\n\u003cli\u003e\u003ca href=\"#experimentaloutputfiletracingroot\"\u003eexperimental.outputFileTracingRoot\u003c/a\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2 id=\"package-manager\"\u003ePackage Manager\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003epnpm\u003c/code\u003e을 패키지 매니저로 사용하도록 설정해야 한다 이미 \u003ccode\u003epnpm\u003c/code\u003e을 프로젝트의 패키지 매니저로 사용하고 있다면 현재 과정은 생략한다.\u003c/p\u003e\n\u003ch3 id=\"pnpm-workspaceyaml-파일-생성\"\u003epnpm-workspace.yaml 파일 생성\u003c/h3\u003e\n\u003cp\u003e기존에 \u003ccode\u003epnpm\u003c/code\u003e을 사용하지 않았다면 \u003ccode\u003epackage.json\u003c/code\u003e에 설정되어 있는 \u003ccode\u003eworkspace\u003c/code\u003e를 \u003ccode\u003epnpm-workspace.yaml\u003c/code\u003e 파일을 통해 참조 할 수 있도록 \u003ccode\u003epnpm-workspace.yaml\u003c/code\u003e 파일을 생성해야 한다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-yaml\"\u003epackages:\n  - \u0026#39;apps/*\u0026#39;\n  - \u0026#39;packages/*\u0026#39;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003ccode\u003epackage.json\u003c/code\u003e 파일에 있는 \u003ccode\u003eworkspace\u003c/code\u003e 설정은 제거한다.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch3 id=\"pnpm-lockyaml-파일-생성\"\u003epnpm-lock.yaml 파일 생성\u003c/h3\u003e\n\u003cp\u003e정상적으로 \u003ccode\u003epnpm\u003c/code\u003e을 통한 \u003ccode\u003eworkspace\u003c/code\u003e 설정이 완료되면 \u003ccode\u003epnpm install\u003c/code\u003e 커맨드를 통해 \u003ccode\u003epnpm-lock.yaml\u003c/code\u003e 파일을 생성한다. 이후 \u003ccode\u003eDocker\u003c/code\u003e를 통해 빌드를 진행할 때 lock 파일을 바탕으로 개발환경과 동일한 디펜던시를 설치하기 위해 빌드를 시작하기 전에 반드시 lock 파일을 생성해야 한다.\u003c/p\u003e\n\u003ch2 id=\"packagejson\"\u003epackage.json\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003epnpm -v\u003c/code\u003e 커맨드를 통해 현재 설치된 \u003ccode\u003epnpm\u003c/code\u003e의 버전을 확인하고 \u003ccode\u003epackage.json\u003c/code\u003e에 \u003ccode\u003epackageManager\u003c/code\u003e 프로퍼티를 아래와 같은 형태로 수정한다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-json\"\u003e{\n  ...\n    \u0026quot;packageManager\u0026quot;: \u0026quot;pnpm@8.1.1\u0026quot;\n  ...\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"dockerignore\"\u003edockerignore\u003c/h2\u003e\n\u003ch3 id=\"node_modules\"\u003enode_modules\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003epnpm\u003c/code\u003e을 통해 패키지를 설정하면 모노리포의 애플리케이션 디렉토리에 설치되는 모듈은 \u003ccode\u003esymbolic link\u003c/code\u003e를 통해 \u003ccode\u003eworkspace\u003c/code\u003e 루트의 모듈을 참조한다.\n\u003ccode\u003eDocker\u003c/code\u003e 빌드 과정에서 설치한 모듈을 복사하게 되는데 이렇게 링크로 생성된 파일은 에러를 발생 시킨다.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003ccode\u003esymbolic link\u003c/code\u003e를 통한 참조는 실행환경에 따라 다르기 때문에 \u003ccode\u003eDocker\u003c/code\u003e를 통한 빌드가 항상 동일한 결과를 만든다는 것을 보장 할 수 없기 때문에 \u003ccode\u003esymbolic link\u003c/code\u003e를 빌드 과정에 개입 시키는 것을 방지하고 있다.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e\u003ccode\u003edockerignore\u003c/code\u003e 파일에 \u003ccode\u003e**/node_modules\u003c/code\u003e를 추가해서 모든 루트 디렉토리 뿐 아니라 하위 패키지에 설치된 \u003ccode\u003enode_modules\u003c/code\u003e 디렉토리도 복사 대상이 되지 않도록 제외해야 한다.\u003c/p\u003e\n\u003ch3 id=\"out\"\u003eout\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003eDocker\u003c/code\u003e는 빌드시 생성된 파일을 캐싱하고 캐싱 된 레이어를 통해 동일한 작업을 반복하지 않도록 하여 성능을 최적화 한다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eDockerizing\u003c/code\u003e 대상이 되지 않는 파일의 \u003ccode\u003epackage.json\u003c/code\u003e을 빌드 대상에 포함 시키면 빌드와는 관계가 없는 모듈의 패키지 의존 정보가 변경됨에 따라 캐싱된 레이어를 파기하고 다시 한번 불필요한 빌드 과정을 수행하게 된다. 결과적으로 \u003ccode\u003eDockerizing\u003c/code\u003e의 성능 최적화 이점을 사용 할 수 없게 된다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eturbo\u003c/code\u003e는 이런 최적화를 그대로 사용 할 수 있도록 \u003ccode\u003eprune\u003c/code\u003e 커맨드를 제공한다. \u003ccode\u003eprune\u003c/code\u003e 커맨드를 실행하면 특정된 \u003ccode\u003escope\u003c/code\u003e와 관계 있는 패키지들의 \u003ccode\u003epackage.json\u003c/code\u003e 파일을 추출하고 \u003ccode\u003eout\u003c/code\u003e 디렉토리에 저장한다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-sh\"\u003e$ turbo prune --scope=\u0026lt;target\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003eout\u003c/code\u003e 디렉토리가 \u003ccode\u003edockerignore\u003c/code\u003e에 포함되지 않은 상태로 이미지 빌드를 하게 되면 \u003ccode\u003eout\u003c/code\u003e 디렉토리가 이미지 안쪽에 복사되는 문제가 발생 할 수 있다. \u003ccode\u003edocker\u003c/code\u003e 이미지 빌드 시점에 \u003ccode\u003eout\u003c/code\u003e 디렉토리가 \u003ccode\u003eCOPY\u003c/code\u003e 커맨드의 대상이 되지 않도록 \u003ccode\u003edockerignore\u003c/code\u003e에 추가한다.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003ccode\u003eturbo\u003c/code\u003e 프로젝트를 스캐폴딩하고 나면 기본적으로 \u003ccode\u003eout\u003c/code\u003e 디렉토리는 \u003ccode\u003egitignore\u003c/code\u003e 항목으로 추가되어 있다.\n일반적으로 \u003ccode\u003egithub action\u003c/code\u003e과 같은 \u003ccode\u003eCI/CD\u003c/code\u003e 툴을 사용한다면 소스 코드를 remote 저장소에서 가지고 오기 때문에 \u003ccode\u003eout\u003c/code\u003e 디렉토리가 존재하지 않는다.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch2 id=\"dockerfile\"\u003eDockerfile\u003c/h2\u003e\n\u003ch3 id=\"pnpm-스크립트-사용\"\u003epnpm 스크립트 사용\u003c/h3\u003e\n\u003cp\u003e패키지 설치, 빌드를 위해 실행하는 커맨드를 \u003ccode\u003epnpm\u003c/code\u003e을 사용하도록 수정한다.\u003c/p\u003e\n\u003cp\u003e패키지 설치 스크립트는 \u003ccode\u003e---frozen-lockfile\u003c/code\u003e 옵션을 추가해서 \u003ccode\u003epnpm-lock.yaml\u003c/code\u003e 파일을 참조하여 개발환경과 정확히 일치하는 디펜던시를 설치 할 수 있도록 강제해야 한다.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003ccode\u003epnpm\u003c/code\u003e을 통해 스크립트를 실행해야 하는 \u003ccode\u003eintermediate layer\u003c/code\u003e에서 커맨드 실행전 \u003ccode\u003enpm\u003c/code\u003e을 통해 \u003ccode\u003epnpm\u003c/code\u003e을 전역에 설치 할 필요가 있다.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch2 id=\"nextconfigjs\"\u003enext.config.js\u003c/h2\u003e\n\u003ch3 id=\"experimentaloutputfiletracingroot\"\u003e\u003ccode\u003eexperimental.outputFileTracingRoot\u003c/code\u003e\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003epnpm\u003c/code\u003e을 통해 모노리포 환경에서 디펜던시를 설치하게 되면 앞서 이야기한 바와 같이 모든 디펜던시를 프로젝트의 루트 디렉토리에 설치하게 된다. 최종적으로 서버를 실행하는데 사용되는 \u003ccode\u003eserver.js\u003c/code\u003e 파일은 이런 구조에 대한 참조를 정확히 하고 있지 않다. \u003ccode\u003eNext.js\u003c/code\u003e는 이런 경우를 위한 옵션을 제공하는데 \u003ccode\u003eexperimental.outputFileTracingRoot\u003c/code\u003e 설정을 통해 \u003ccode\u003eserver.js\u003c/code\u003e 파일과 동일한 디렉토리에 모듈이 설치 될 수 있도록 한다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-json\"\u003e{\n  // next.config.js\n  ...\n  experimental: {\n    outputFileTracingRoot: path.join(__dirname, \u0026#39;../../) // 패키지의 애플리케이션 디렉토리 부터 프로젝트 루트 까지 경로를 설정\n  },\n  ...\n}\n\u003c/code\u003e\u003c/pre\u003e\n","postsByCategory":[{"title":"yarn berry로 구성하는 monorepo","description":"yarn berry와 yarn workspaces를 이용해 monorepo 구성 - 환경 설정, 샘플 프로젝트","fileName":"yarn-berry-monorepo.md","category":"infrastructure","published":true,"publishedAt":"2022-02-26","thumbnailName":"yarn-berry-monorepo.png","tags":["berry","monorepo","workspace","workspaces","yarn","yarn berry","zero-install","모노리포"],"references":[{"title":"yarn workspaces","url":"https://yarnpkg.com/features/workspaces"}],"series":{"prevPostTitle":"Nx build system 맛보기"},"order":10},{"title":"Nx build system 맛보기","description":"Nx build system을 이용한 Monorepo 구성하기","fileName":"monorepo-with-nx.md","category":"infrastructure","published":true,"publishedAt":"2022-02-12","thumbnailName":"monorepo-with-nx.png","tags":["build","build system","monorepo","nx","모노리포","빌드","빌드 시스템"],"series":{"prevPostTitle":"Nx build system 맛보기","nextPostTitle":"yarn berry로 구성하는 monorepo"},"order":9}],"enableContentExplorer":true},"__N_SSG":true},"page":"/[title]","query":{"title":"turbo-repo-(pnpm)-환경에서-next.js-dockerizing"},"buildId":"8hg3Wv6jOEFOXWQALigER","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>