<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta name="viewport" content="width=device-width" />
    <meta charset="utf-8" />
    <link rel="canonical" href="https://code-logs.github.io/any-|-unknown-|-never" />
    <link rel="apple-touch-icon" href="/icons/icon-192x-192.png" />
    <link rel="manifest" href="/manifest.json" />
    <meta name="theme-color" content="#fff" />
    <meta property="og:type" content="website" />
    <meta property="og:site_name" content="Code Logs" />
    <meta name="author" content="Jay Lee" />
    <meta name="keyword" content="any, never, typescript, unknown, 타입스크립트, Any | Unknown | Never, TypeScript - Any | Unknown | Never, typescript" />
    <meta name="description" content="TypeScript - Any | Unknown | Never" />
    <meta property="og:description" content="TypeScript - Any | Unknown | Never" />
    <meta property="og:title" content="Any | Unknown | Never | Code Logs" />
    <meta property="og:url" content="https://code-logs.github.io/any-|-unknown-|-never" />
    <meta property="og:image" content="/assets/images/ts-any-unknown-never.png" />
    <title>Any | Unknown | Never | Code Logs</title>
    <meta name="next-head-count" content="16" />
    <link rel="preload" href="/_next/static/css/e67f92fc328a3d57.css" as="style" />
    <link rel="stylesheet" href="/_next/static/css/e67f92fc328a3d57.css" data-n-g="" />
    <link rel="preload" href="/_next/static/css/b5e8827db00c1c2b.css" as="style" />
    <link rel="stylesheet" href="/_next/static/css/b5e8827db00c1c2b.css" data-n-p="" />
    <noscript data-n-css=""></noscript>
    <script defer="" nomodule="" src="/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script>
    <script src="/_next/static/chunks/webpack-2e51481b1d484a05.js" defer=""></script>
    <script src="/_next/static/chunks/framework-5f4595e5518b5600.js" defer=""></script>
    <script src="/_next/static/chunks/main-a4d9e436b9a532ca.js" defer=""></script>
    <script src="/_next/static/chunks/pages/_app-302687a3b3726e89.js" defer=""></script>
    <script src="/_next/static/chunks/294-6603e2d70ff7953e.js" defer=""></script>
    <script src="/_next/static/chunks/377-bcd12e5f5670edaa.js" defer=""></script>
    <script src="/_next/static/chunks/pages/%5Btitle%5D-637c57b2312d7084.js" defer=""></script>
    <script src="/_next/static/mGKmApaunwm6G6tWfKdom/_buildManifest.js" defer=""></script>
    <script src="/_next/static/mGKmApaunwm6G6tWfKdom/_ssgManifest.js" defer=""></script>
    <script src="/_next/static/mGKmApaunwm6G6tWfKdom/_middlewareManifest.js" defer=""></script>
  </head>
  <body>
    <div id="__next" data-reactroot="">
      <header class="Header_header__RW35m">
        <p class="Header_title__GPS8b">Code Logs</p>
        <ul class="Header_socialIcons__CBf_s">
          <li>
            <a href="https://github.com/possible819" target="_blank" rel="noreferrer" aria-label="My Github"
              ><style data-emotion="css vubbuv">
                .css-vubbuv {
                  -webkit-user-select: none;
                  -moz-user-select: none;
                  -ms-user-select: none;
                  user-select: none;
                  width: 1em;
                  height: 1em;
                  display: inline-block;
                  fill: currentColor;
                  -webkit-flex-shrink: 0;
                  -ms-flex-negative: 0;
                  flex-shrink: 0;
                  -webkit-transition: fill 200ms cubic-bezier(0.4, 0, 0.2, 1) 0ms;
                  transition: fill 200ms cubic-bezier(0.4, 0, 0.2, 1) 0ms;
                  font-size: 1.5rem;
                }</style
              ><svg
                class="MuiSvgIcon-root MuiSvgIcon-fontSizeMedium css-vubbuv"
                focusable="false"
                aria-hidden="true"
                viewBox="0 0 24 24"
                data-testid="GitHubIcon"
              >
                <path
                  d="M12 1.27a11 11 0 00-3.48 21.46c.55.09.73-.28.73-.55v-1.84c-3.03.64-3.67-1.46-3.67-1.46-.55-1.29-1.28-1.65-1.28-1.65-.92-.65.1-.65.1-.65 1.1 0 1.73 1.1 1.73 1.1.92 1.65 2.57 1.2 3.21.92a2 2 0 01.64-1.47c-2.47-.27-5.04-1.19-5.04-5.5 0-1.1.46-2.1 1.2-2.84a3.76 3.76 0 010-2.93s.91-.28 3.11 1.1c1.8-.49 3.7-.49 5.5 0 2.1-1.38 3.02-1.1 3.02-1.1a3.76 3.76 0 010 2.93c.83.74 1.2 1.74 1.2 2.94 0 4.21-2.57 5.13-5.04 5.4.45.37.82.92.82 2.02v3.03c0 .27.1.64.73.55A11 11 0 0012 1.27"
                ></path></svg
            ></a>
          </li>
        </ul>
        <nav class="NavBar_navBar__akqA3">
          <ul>
            <li><a class="MarkedAnchor_anchor__QCmkL" href="https://code-logs.github.io/">Home</a></li>
            <li><a class="MarkedAnchor_anchor__QCmkL" href="https://code-logs.github.io/posts/1">Posts</a></li>
            <li><a class="MarkedAnchor_anchor__QCmkL" href="https://code-logs.github.io/about">About</a></li>
          </ul>
        </nav>
      </header>
      <main>
        <article class="PostDetail_container__Ma_26">
          <p class="PostDetail_publishedAt__7GOQm"><span></span></p>
          <section class="PostDetail_thumbnailWrapper__oALCg">
            <img src="/assets/images/ts-any-unknown-never.png" alt="TypeScript - Any | Unknown | Never" />
          </section>
          <section>
            <h1>Any | Unknown | Never</h1>
            <p class="PostDetail_description__l6wHC">TypeScript - Any | Unknown | Never</p>
          </section>
          <section>
            <h2 id="table-of-contents">Table of contents</h2>
            <ol>
              <li>
                <a href="#any">Any</a>
                <ol>
                  <li><a href="#any-%ED%83%80%EC%9E%85%EC%9D%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80">Any 타입은 무엇인가?</a></li>
                </ol>
              </li>
              <li>
                <a href="#unknown">Unknown</a>
                <ol>
                  <li><a href="#unknown-%ED%83%80%EC%9E%85%EC%9D%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80">Unknown 타입은 무엇인가?</a></li>
                  <li>
                    <a href="#any-%ED%83%80%EC%9E%85%EA%B3%BC-unknown-%ED%83%80%EC%9E%85%EC%9D%98-%EC%B0%A8%EC%9D%B4%EB%8A%94"
                      >Any 타입과 Unknown 타입의 차이는?</a
                    >
                  </li>
                  <li><a href="#unknown-%ED%83%80%EC%9E%85-%EC%9D%91%EC%9A%A9%ED%95%98%EA%B8%B0">Unknown 타입 응용하기</a></li>
                </ol>
              </li>
              <li>
                <a href="#never">Never</a>
                <ol>
                  <li><a href="#never-%ED%83%80%EC%9E%85%EC%9D%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80">Never 타입은 무엇인가?</a></li>
                  <li><a href="#never-%ED%83%80%EC%9E%85-%EC%9D%91%EC%9A%A9%ED%95%98%EA%B8%B0">Never 타입 응용하기</a></li>
                </ol>
              </li>
            </ol>
            <h2 id="any">Any</h2>
            <h3 id="any-타입은-무엇인가">Any 타입은 무엇인가?</h3>
            <p>
              처음 JavaScript 코드를 TypeScript로 마이그레이션 할 때 필살기 처럼 사용했던 타입이다. 이러면 안된다는걸 직감적으로 알고 있으면서도 당시에는 당장
              마이그레이션 하는게 우선이였기 때문에 묻어두고 넘어 갔고 당연히 시간이 지남에 따라 발목을 잡는 결과를 초래했다.
            </p>
            <p>
              <code>any</code> 타입은 말 그대로 &#39;무엇이든지 가능한&#39; 타입 유형이다. 사실상 무엇이든 가능한 JavaScript 세계에서의 기본적인 타입 규칙을
              따르는 것과 다름이 없기 때문에 모든 변수의 타입을 <code>any</code>로 잡는 것은 확장자만 ts인 js를 사용하는 것이다.
              <del>컴파일을 해야하는 불편함 까지 가지고 있는 JavaScript가 완성된다.</del>
            </p>
            <p>
              TypeScript는 정적인 타입을 보장하는 것을 통해 코드의 안정성을 확보하고 개발자가 인지하지 못하는 에러나 케이스 누락을 보장해주는 것인데 이런
              장점들을 모두 사라지게 만드는 무분별한 <code>any</code>의 사용은 당연히 권장되는 방법은 아니다.
            </p>
            <p>
              <code>any</code> 타입은 <code>TypeScript</code> 타입 생태계의 가장 최상위에 있는 <code>Super type</code>으로 모든 종류의 type을 포함한다. 다시
              말하면 어떤 값도 <code>any</code> 타입이 될 수 있다는 것이다.
            </p>
            <pre><code class="language-typescript">let iAmAny: any
iAmAny.hello.i.am.any.type.that.is.why.you.can.access.any.properties.of.mine()

let iAmBoolean: boolean = iAmAny
</code></pre>
            <p>예제에서 볼 수 있든 정의되지 않은 프로퍼티에 접근하려고 해도 컴파일 에러를 발생시키지 않는다. 심지어 값의 할당이 되기도 한다.</p>
            <h2 id="unknown">Unknown</h2>
            <h3 id="unknown-타입은-무엇인가">Unknown 타입은 무엇인가?</h3>
            <p>
              <code>unknown</code> 타입은 말그대로 타입을 알 수 없는 것이다. <code>any</code> 타입과 비슷한 의미로 기억 될 수 있고 어떤 부분에서는
              <code>any</code> 타입과도 닮아 있다. 하지만 <code>unknown</code> 타입은 <code>any</code> 타입과 분명한 차이점을 가지고 있으며 이 차이점에 대해서
              이해하고 있다면 유연하면서도 TypeScript의 정적 타이핑을 잘 이용한 코드를 작성 할 수 있다.
            </p>
            <pre><code class="language-typescript">let iAmUnknown: unknown = &#39;Hello&#39;
iAmUnknown = [&#39;I&#39;, &#39;can&#39;, &#39;be&#39;, &#39;anything&#39;, &#39;because&#39;, &#39;I&#39;, &#39;am&#39;, &#39;unknonw&#39;]
iAmUnknown = 12345
</code></pre>
            <p>
              예제에서 보는 것과 같이 <code>unknown</code> 타입의 경우도 <code>any</code> 타입과 같이 타입체크에 따른 컴파일 에러가 발생하지 않는 것을 볼 수
              있다.
            </p>
            <p>하지만 아래의 경우는 조금 차이가 있다.</p>
            <pre><code class="language-typescript">let iAmUnknown: unknown = &#39;Hello&#39;
iAmUnknown.split(&#39; &#39;) // Property &#39;split&#39; does not exist on type &#39;unknown&#39;.ts(2339)
iAmUnknown.join(&#39;&#39;) // Property &#39;join&#39; does not exist on type &#39;unknown&#39;.ts(2339)
</code></pre>
            <p>
              위의 예제에서 처럼 unknown 타입에는 split, join과 같은 속성이 없다는 컴파일 에러가 발생한다. 이런 에러를 방지하기 위해 반드시
              <code>type guard</code>가 필요하다.
            </p>
            <blockquote>
              <p>Type Guard</p>
              <p>객체의 타입을 좁혀 나가는 것을 통해 특정 변수의 타입을 보장하는 것</p>
            </blockquote>
            <pre><code class="language-typescript">let iAmUnknown: unknown = &#39;Hello&#39;

if (typeof iAmUnknown === &#39;string&#39;) {
  iAmUnknown.split(&#39; &#39;)
} else if (Array.isArray(iAmUnknown)) {
  iAmUnknown.join(&#39;&#39;)
}
</code></pre>
            <p>이런식으로 <code>unknown</code> 타입의 변수는 <code>type guard</code>를 통해 안정적인 코드로 변경 할 수 있다.</p>
            <h3 id="any-타입과-unknown-타입의-차이는">Any 타입과 Unknown 타입의 차이는?</h3>
            <p>결과적으로 <code>any</code> 타입과 <code>unknown</code> 타입의 차이점은 사용시 타입을 명시해야하는데 있다.</p>
            <h3 id="unknown-타입-응용하기">Unknown 타입 응용하기</h3>
            <p>
              <code>unknown</code> 타입은 타입 정의가 명확하게 되어 있지 않은 코드를 사용 할 때 유용히 쓰일 수 있다. 예를들어 아래와 같은 코드 블럭이 있다고
              가정 했을때
            </p>
            <pre><code class="language-typescript">const someResult = doSomething()
someResult.split(&#39;&#39;)
</code></pre>
            <p>
              코드를 통해 충분히 유추할 수 있듯 <code>doSomething</code>이란 함수는 <code>string</code> 타입을 리턴하는 것으로 보인다. 그런데 예상과 달리
              <code>number</code> 타입이나 <code>split</code>을 메소드로 가지고 있지 않은 유형의 데이터를 리턴하게 된다면 런타임에 에러가 발생하게 된다.
            </p>
            <p>
              <code>doSomething</code>의 호출 결과인 <code>someResult</code>는 기본적으로 any 타입을 갖게 된다. 이것을 <code>unknown</code> 타입으로 변경하면
              타입 가드를 반드시 만들어줘야하고 결과적으로 런타임에 발생하게 되는 에러를 미연에 방지 할 수 있다.
            </p>
            <pre><code class="language-typescript">const someResult: unknown = doSomething()

if (typeof someResult === &#39;string&#39;) {
  someResult.split(&#39;&#39;)
}
</code></pre>
            <h2 id="never">Never</h2>
            <h3 id="never-타입은-무엇인가">Never 타입은 무엇인가?</h3>
            <p>
              never 타입은 절대로 발생하지 않는 값의 타입이다. 절대로 발생하지 않는 값의 타입이라는 말이 무언가 모순적인데 아래의 예제 코드를 통해 조금 명확히
              해야겠다.
            </p>
            <pre><code class="language-typescript">const neverPass = (): never =&gt; {
  throw new Error(`You can&#39;t pass through this function`)
}
</code></pre>
            <p>
              <code>neverPass</code>라는 함수의 리턴 값이 <code>never</code>로 설정 했다 당연히 <code>neverPass</code> 함수는 절대로 값을 리턴할 수 없기
              때문이다. 또다른 예제는 아래와 같다
            </p>
            <pre><code class="language-typescript">const infiniteLoop = (): never =&gt; {
  while (true) {
    console.log(&#39;You are in infinite loop function&#39;)
  }
}
</code></pre>
            <p>
              <code>infiniteLoop</code>라는 함수의 리턴 타입 또한 <code>never</code>로 설정 됐다. 이 예제의 함수 또한 절대로 어떠한 값도 리턴 할 수 없기
              때문이다.
            </p>
            <p><code>never</code> 타입의 몇가지 특징에 대해서 이야기해 보면 아래와 같다.</p>
            <ul>
              <li><code>never</code> 타입은 모든 타입의 하위 타입이다. 다시 말해 어떠한 유형의 값에도 <code>never</code> 타입의 값은 할당 될 수 있다.</li>
              <li>
                어떠한 타입도 <code>never</code> 타입의 하위 타입이 될 수 없다. <code>never</code> 타입에는 <code>never</code> 그 자체만을 할당 할 수 있고 다른
                어떤 값도 <code>never</code> 타입에 할당 될 수 없다.
              </li>
            </ul>
            <h3 id="never-타입-응용하기">Never 타입 응용하기</h3>
            <p>앞서 살펴본 <code>never</code> 타입에는 <code>never</code> 타입만 할당 할 수 있다는 특징의 응용을 통해 런타임 에러를 방지 할 수 있다.</p>
            <p>우선 서로 다른 두개의 <code>type</code>을 정의한다.</p>
            <pre><code class="language-typescript">type CustomType1 = { name: &#39;custom type 1&#39; }
type CustomType2 = { name: &#39;custom type 2&#39; }
</code></pre>
            <p>그리고 두 타입의 유니언 타입을 정의한다.</p>
            <pre><code class="language-typescript">type CustomType1 = { name: &#39;custom type 1&#39; }
type CustomType2 = { name: &#39;custom type 2&#39; }

type CustomUnionType = CustomType1 | CustomType2
</code></pre>
            <p>그리고 <code>CustomUnionType</code>을 매개변수로 갖는 함수를 정의한다.</p>
            <pre><code class="language-typescript">function doSomething(param: CustomUnionType) {
  if (param.name === &#39;custom type 1&#39;) {
    return &#39;This is custom type 1&#39;
  } else if (param.name === &#39;custom type 2&#39;) {
    return &#39;This is custom type 2&#39;
  }
}
</code></pre>
            <p>
              예제의 코드는 상당히 간단하기 때문에 <code>doSomething</code> 함수 내부에서 다루어져야 하는 모든 케이스에 대한 처리가 되었음을 확인 할 수 있다.
            </p>
            <p>그런데 만약 <code>CustomUnionType</code>이 변경되어 새롭게 고려해야 할 케이스가 발생한다면 어떨까?</p>
            <p>결론부터 이야기하면 현재 상태로는 새롭게 추가되는 타입이 생기더라도 이것을 쉽게 알 수 없다.</p>
            <p>
              이때 <code>never</code>는 <code>never</code> 자체에만 할당 가능하다는 것을 이용하면 <code>doSomething</code> 내에서 모든 케이스가 다루어지고
              있는지 여부를 손쉽게 확인 할 수 있다.
            </p>
            <pre><code class="language-typescript">function doSomething(param: CustomUnionType) {
  if (param.name === &#39;custom type 1&#39;) {
    return &#39;This is custom type 1&#39;
  } else if (param.name === &#39;custom type 2&#39;) {
    return &#39;This is custom type 2&#39;
  }

  const isNever: never = param
}
</code></pre>
            <p>
              코드를 통해 확인 할 수 있듯이 전달받은 <code>param</code>은 <code>CustomType1</code> 또는 <code>CustomType2</code>인 경우 함수 실행이 종료되게
              되고 마지막 라인인 <code>const isNever: never = param</code>에 도달 했을 경우 <code>param</code>은 <code>CustomType1</code>도
              <code>CustomType2</code>도 아닌 <code>never</code> 타입이기 때문에 컴파일 에러가 발생하지 않는다.
            </p>
            <p>
              그런데 만약 <code>CustomUnionType</code>에 <code>CustomType3</code>라는 새로운 타입이 포함된다면 마지막 라인에서 <code>param</code>의 유형이
              <code>CustomType3</code>가 되고 결과적으로 <code>isNever</code>에 <code>param</code>을 할당 할 수 없게된다.
            </p>
            <pre><code class="language-typescript">type CustomType1 = { name: &#39;custom type 1&#39; }
type CustomType2 = { name: &#39;custom type 2&#39; }
type CustomType3 = { name: &#39;custom type 3&#39; }

type CustomUnionType = CustomType1 | CustomType2 | CustomType3

function doSomething(param: CustomUnionType) {
  if (param.name === &#39;custom type 1&#39;) {
    return &#39;This is custom type 1&#39;
  } else if (param.name === &#39;custom type 2&#39;) {
    return &#39;This is custom type 2&#39;
  }

  const isNever: never = param // &#39;isNever&#39; is declared but its value is never read.ts(6133)
}
</code></pre>
            <p>이런 장치를 함수 내부의 포함시키는 것을 통해 타입별 처리를 누락 없이 수행 할 수 있다.</p>
          </section>
        </article>
        <section class="PostDetail_utterances__jZeOm">
          <h2>댓글</h2>
          <div></div>
        </section>
        <ins
          class="adsbygoogle"
          style="display: block"
          data-ad-client="ca-pub-7134579063537339"
          data-ad-slot="5391522351"
          data-ad-format="auto"
          data-full-width-responsive="true"
        ></ins>
      </main>
      <aside></aside>
      <footer class="Footer_footer__GLL0J"><p>ⓒ 2021. Jay Lee all rights reserved.</p></footer>
    </div>
    <script id="__NEXT_DATA__" type="application/json">
      {
        "props": {
          "pageProps": {
            "post": {
              "title": "Any | Unknown | Never",
              "description": "TypeScript - Any | Unknown | Never",
              "fileName": "any-unknown-never.md",
              "category": "typescript",
              "published": true,
              "publishedAt": "2021-11-15",
              "thumbnailName": "ts-any-unknown-never.png",
              "tags": ["any", "never", "typescript", "unknown", "타입스크립트"]
            },
            "content": "\u003ch2 id=\"table-of-contents\"\u003eTable of contents\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003e\u003ca href=\"#any\"\u003eAny\u003c/a\u003e\u003col\u003e\n\u003cli\u003e\u003ca href=\"#any-%ED%83%80%EC%9E%85%EC%9D%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80\"\u003eAny 타입은 무엇인가?\u003c/a\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#unknown\"\u003eUnknown\u003c/a\u003e\u003col\u003e\n\u003cli\u003e\u003ca href=\"#unknown-%ED%83%80%EC%9E%85%EC%9D%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80\"\u003eUnknown 타입은 무엇인가?\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#any-%ED%83%80%EC%9E%85%EA%B3%BC-unknown-%ED%83%80%EC%9E%85%EC%9D%98-%EC%B0%A8%EC%9D%B4%EB%8A%94\"\u003eAny 타입과 Unknown 타입의 차이는?\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#unknown-%ED%83%80%EC%9E%85-%EC%9D%91%EC%9A%A9%ED%95%98%EA%B8%B0\"\u003eUnknown 타입 응용하기\u003c/a\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#never\"\u003eNever\u003c/a\u003e\u003col\u003e\n\u003cli\u003e\u003ca href=\"#never-%ED%83%80%EC%9E%85%EC%9D%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80\"\u003eNever 타입은 무엇인가?\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#never-%ED%83%80%EC%9E%85-%EC%9D%91%EC%9A%A9%ED%95%98%EA%B8%B0\"\u003eNever 타입 응용하기\u003c/a\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2 id=\"any\"\u003eAny\u003c/h2\u003e\n\u003ch3 id=\"any-타입은-무엇인가\"\u003eAny 타입은 무엇인가?\u003c/h3\u003e\n\u003cp\u003e처음 JavaScript 코드를 TypeScript로 마이그레이션 할 때 필살기 처럼 사용했던 타입이다. 이러면 안된다는걸 직감적으로 알고 있으면서도 당시에는 당장 마이그레이션 하는게 우선이였기 때문에 묻어두고 넘어 갔고 당연히 시간이 지남에 따라 발목을 잡는 결과를 초래했다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eany\u003c/code\u003e 타입은 말 그대로 \u0026#39;무엇이든지 가능한\u0026#39; 타입 유형이다. 사실상 무엇이든 가능한 JavaScript 세계에서의 기본적인 타입 규칙을 따르는 것과 다름이 없기 때문에 모든 변수의 타입을 \u003ccode\u003eany\u003c/code\u003e로 잡는 것은 확장자만 ts인 js를 사용하는 것이다. \u003cdel\u003e컴파일을 해야하는 불편함 까지 가지고 있는 JavaScript가 완성된다.\u003c/del\u003e\u003c/p\u003e\n\u003cp\u003eTypeScript는 정적인 타입을 보장하는 것을 통해 코드의 안정성을 확보하고 개발자가 인지하지 못하는 에러나 케이스 누락을 보장해주는 것인데 이런 장점들을 모두 사라지게 만드는 무분별한 \u003ccode\u003eany\u003c/code\u003e의 사용은 당연히 권장되는 방법은 아니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eany\u003c/code\u003e 타입은 \u003ccode\u003eTypeScript\u003c/code\u003e 타입 생태계의 가장 최상위에 있는 \u003ccode\u003eSuper type\u003c/code\u003e으로 모든 종류의 type을 포함한다. 다시 말하면 어떤 값도 \u003ccode\u003eany\u003c/code\u003e 타입이 될 수 있다는 것이다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-typescript\"\u003elet iAmAny: any\niAmAny.hello.i.am.any.type.that.is.why.you.can.access.any.properties.of.mine()\n\nlet iAmBoolean: boolean = iAmAny\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e예제에서 볼 수 있든 정의되지 않은 프로퍼티에 접근하려고 해도 컴파일 에러를 발생시키지 않는다. 심지어 값의 할당이 되기도 한다.\u003c/p\u003e\n\u003ch2 id=\"unknown\"\u003eUnknown\u003c/h2\u003e\n\u003ch3 id=\"unknown-타입은-무엇인가\"\u003eUnknown 타입은 무엇인가?\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003eunknown\u003c/code\u003e 타입은 말그대로 타입을 알 수 없는 것이다. \u003ccode\u003eany\u003c/code\u003e 타입과 비슷한 의미로 기억 될 수 있고 어떤 부분에서는 \u003ccode\u003eany\u003c/code\u003e 타입과도 닮아 있다. 하지만 \u003ccode\u003eunknown\u003c/code\u003e 타입은 \u003ccode\u003eany\u003c/code\u003e 타입과 분명한 차이점을 가지고 있으며 이 차이점에 대해서 이해하고 있다면 유연하면서도 TypeScript의 정적 타이핑을 잘 이용한 코드를 작성 할 수 있다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-typescript\"\u003elet iAmUnknown: unknown = \u0026#39;Hello\u0026#39;\niAmUnknown = [\u0026#39;I\u0026#39;, \u0026#39;can\u0026#39;, \u0026#39;be\u0026#39;, \u0026#39;anything\u0026#39;, \u0026#39;because\u0026#39;, \u0026#39;I\u0026#39;, \u0026#39;am\u0026#39;, \u0026#39;unknonw\u0026#39;]\niAmUnknown = 12345\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e예제에서 보는 것과 같이 \u003ccode\u003eunknown\u003c/code\u003e 타입의 경우도 \u003ccode\u003eany\u003c/code\u003e 타입과 같이 타입체크에 따른 컴파일 에러가 발생하지 않는 것을 볼 수 있다.\u003c/p\u003e\n\u003cp\u003e하지만 아래의 경우는 조금 차이가 있다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-typescript\"\u003elet iAmUnknown: unknown = \u0026#39;Hello\u0026#39;\niAmUnknown.split(\u0026#39; \u0026#39;) // Property \u0026#39;split\u0026#39; does not exist on type \u0026#39;unknown\u0026#39;.ts(2339)\niAmUnknown.join(\u0026#39;\u0026#39;) // Property \u0026#39;join\u0026#39; does not exist on type \u0026#39;unknown\u0026#39;.ts(2339)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e위의 예제에서 처럼 unknown 타입에는 split, join과 같은 속성이 없다는 컴파일 에러가 발생한다.\n이런 에러를 방지하기 위해 반드시 \u003ccode\u003etype guard\u003c/code\u003e가 필요하다.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eType Guard\u003c/p\u003e\n\u003cp\u003e객체의 타입을 좁혀 나가는 것을 통해 특정 변수의 타입을 보장하는 것\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cpre\u003e\u003ccode class=\"language-typescript\"\u003elet iAmUnknown: unknown = \u0026#39;Hello\u0026#39;\n\nif (typeof iAmUnknown === \u0026#39;string\u0026#39;) {\n  iAmUnknown.split(\u0026#39; \u0026#39;)\n} else if (Array.isArray(iAmUnknown)) {\n  iAmUnknown.join(\u0026#39;\u0026#39;)\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이런식으로 \u003ccode\u003eunknown\u003c/code\u003e 타입의 변수는 \u003ccode\u003etype guard\u003c/code\u003e를 통해 안정적인 코드로 변경 할 수 있다.\u003c/p\u003e\n\u003ch3 id=\"any-타입과-unknown-타입의-차이는\"\u003eAny 타입과 Unknown 타입의 차이는?\u003c/h3\u003e\n\u003cp\u003e결과적으로 \u003ccode\u003eany\u003c/code\u003e 타입과 \u003ccode\u003eunknown\u003c/code\u003e 타입의 차이점은 사용시 타입을 명시해야하는데 있다.\u003c/p\u003e\n\u003ch3 id=\"unknown-타입-응용하기\"\u003eUnknown 타입 응용하기\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003eunknown\u003c/code\u003e 타입은 타입 정의가 명확하게 되어 있지 않은 코드를 사용 할 때 유용히 쓰일 수 있다.\n예를들어 아래와 같은 코드 블럭이 있다고 가정 했을때\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-typescript\"\u003econst someResult = doSomething()\nsomeResult.split(\u0026#39;\u0026#39;)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e코드를 통해 충분히 유추할 수 있듯 \u003ccode\u003edoSomething\u003c/code\u003e이란 함수는 \u003ccode\u003estring\u003c/code\u003e 타입을 리턴하는 것으로 보인다.\n그런데 예상과 달리 \u003ccode\u003enumber\u003c/code\u003e 타입이나 \u003ccode\u003esplit\u003c/code\u003e을 메소드로 가지고 있지 않은 유형의 데이터를 리턴하게 된다면 런타임에 에러가 발생하게 된다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003edoSomething\u003c/code\u003e의 호출 결과인 \u003ccode\u003esomeResult\u003c/code\u003e는 기본적으로 any 타입을 갖게 된다.\n이것을 \u003ccode\u003eunknown\u003c/code\u003e 타입으로 변경하면 타입 가드를 반드시 만들어줘야하고 결과적으로 런타임에 발생하게 되는 에러를 미연에 방지 할 수 있다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-typescript\"\u003econst someResult: unknown = doSomething()\n\nif (typeof someResult === \u0026#39;string\u0026#39;) {\n  someResult.split(\u0026#39;\u0026#39;)\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"never\"\u003eNever\u003c/h2\u003e\n\u003ch3 id=\"never-타입은-무엇인가\"\u003eNever 타입은 무엇인가?\u003c/h3\u003e\n\u003cp\u003enever 타입은 절대로 발생하지 않는 값의 타입이다. 절대로 발생하지 않는 값의 타입이라는 말이 무언가 모순적인데 아래의 예제 코드를 통해 조금 명확히 해야겠다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-typescript\"\u003econst neverPass = (): never =\u0026gt; {\n  throw new Error(`You can\u0026#39;t pass through this function`)\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003eneverPass\u003c/code\u003e라는 함수의 리턴 값이 \u003ccode\u003enever\u003c/code\u003e로 설정 했다 당연히 \u003ccode\u003eneverPass\u003c/code\u003e 함수는 절대로 값을 리턴할 수 없기 때문이다. 또다른 예제는 아래와 같다\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-typescript\"\u003econst infiniteLoop = (): never =\u0026gt; {\n  while (true) {\n    console.log(\u0026#39;You are in infinite loop function\u0026#39;)\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003einfiniteLoop\u003c/code\u003e라는 함수의 리턴 타입 또한 \u003ccode\u003enever\u003c/code\u003e로 설정 됐다. 이 예제의 함수 또한 절대로 어떠한 값도 리턴 할 수 없기 때문이다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003enever\u003c/code\u003e 타입의 몇가지 특징에 대해서 이야기해 보면 아래와 같다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003enever\u003c/code\u003e 타입은 모든 타입의 하위 타입이다. 다시 말해 어떠한 유형의 값에도 \u003ccode\u003enever\u003c/code\u003e 타입의 값은 할당 될 수 있다.\u003c/li\u003e\n\u003cli\u003e어떠한 타입도 \u003ccode\u003enever\u003c/code\u003e 타입의 하위 타입이 될 수 없다. \u003ccode\u003enever\u003c/code\u003e 타입에는 \u003ccode\u003enever\u003c/code\u003e 그 자체만을 할당 할 수 있고 다른 어떤 값도 \u003ccode\u003enever\u003c/code\u003e 타입에 할당 될 수 없다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"never-타입-응용하기\"\u003eNever 타입 응용하기\u003c/h3\u003e\n\u003cp\u003e앞서 살펴본 \u003ccode\u003enever\u003c/code\u003e 타입에는 \u003ccode\u003enever\u003c/code\u003e 타입만 할당 할 수 있다는 특징의 응용을 통해 런타임 에러를 방지 할 수 있다.\u003c/p\u003e\n\u003cp\u003e우선 서로 다른 두개의 \u003ccode\u003etype\u003c/code\u003e을 정의한다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-typescript\"\u003etype CustomType1 = { name: \u0026#39;custom type 1\u0026#39; }\ntype CustomType2 = { name: \u0026#39;custom type 2\u0026#39; }\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e그리고 두 타입의 유니언 타입을 정의한다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-typescript\"\u003etype CustomType1 = { name: \u0026#39;custom type 1\u0026#39; }\ntype CustomType2 = { name: \u0026#39;custom type 2\u0026#39; }\n\ntype CustomUnionType = CustomType1 | CustomType2\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e그리고 \u003ccode\u003eCustomUnionType\u003c/code\u003e을 매개변수로 갖는 함수를 정의한다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-typescript\"\u003efunction doSomething(param: CustomUnionType) {\n  if (param.name === \u0026#39;custom type 1\u0026#39;) {\n    return \u0026#39;This is custom type 1\u0026#39;\n  } else if (param.name === \u0026#39;custom type 2\u0026#39;) {\n    return \u0026#39;This is custom type 2\u0026#39;\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e예제의 코드는 상당히 간단하기 때문에 \u003ccode\u003edoSomething\u003c/code\u003e 함수 내부에서 다루어져야 하는 모든 케이스에 대한 처리가 되었음을 확인 할 수 있다.\u003c/p\u003e\n\u003cp\u003e그런데 만약 \u003ccode\u003eCustomUnionType\u003c/code\u003e이 변경되어 새롭게 고려해야 할 케이스가 발생한다면 어떨까?\u003c/p\u003e\n\u003cp\u003e결론부터 이야기하면 현재 상태로는 새롭게 추가되는 타입이 생기더라도 이것을 쉽게 알 수 없다.\u003c/p\u003e\n\u003cp\u003e이때 \u003ccode\u003enever\u003c/code\u003e는 \u003ccode\u003enever\u003c/code\u003e 자체에만 할당 가능하다는 것을 이용하면 \u003ccode\u003edoSomething\u003c/code\u003e 내에서 모든 케이스가 다루어지고 있는지 여부를 손쉽게 확인 할 수 있다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-typescript\"\u003efunction doSomething(param: CustomUnionType) {\n  if (param.name === \u0026#39;custom type 1\u0026#39;) {\n    return \u0026#39;This is custom type 1\u0026#39;\n  } else if (param.name === \u0026#39;custom type 2\u0026#39;) {\n    return \u0026#39;This is custom type 2\u0026#39;\n  }\n\n  const isNever: never = param\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e코드를 통해 확인 할 수 있듯이 전달받은 \u003ccode\u003eparam\u003c/code\u003e은 \u003ccode\u003eCustomType1\u003c/code\u003e 또는 \u003ccode\u003eCustomType2\u003c/code\u003e인 경우 함수 실행이 종료되게 되고 마지막 라인인 \u003ccode\u003econst isNever: never = param\u003c/code\u003e에 도달 했을 경우 \u003ccode\u003eparam\u003c/code\u003e은 \u003ccode\u003eCustomType1\u003c/code\u003e도 \u003ccode\u003eCustomType2\u003c/code\u003e도 아닌 \u003ccode\u003enever\u003c/code\u003e 타입이기 때문에 컴파일 에러가 발생하지 않는다.\u003c/p\u003e\n\u003cp\u003e그런데 만약 \u003ccode\u003eCustomUnionType\u003c/code\u003e에 \u003ccode\u003eCustomType3\u003c/code\u003e라는 새로운 타입이 포함된다면 마지막 라인에서 \u003ccode\u003eparam\u003c/code\u003e의 유형이 \u003ccode\u003eCustomType3\u003c/code\u003e가 되고 결과적으로 \u003ccode\u003eisNever\u003c/code\u003e에 \u003ccode\u003eparam\u003c/code\u003e을 할당 할 수 없게된다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-typescript\"\u003etype CustomType1 = { name: \u0026#39;custom type 1\u0026#39; }\ntype CustomType2 = { name: \u0026#39;custom type 2\u0026#39; }\ntype CustomType3 = { name: \u0026#39;custom type 3\u0026#39; }\n\ntype CustomUnionType = CustomType1 | CustomType2 | CustomType3\n\nfunction doSomething(param: CustomUnionType) {\n  if (param.name === \u0026#39;custom type 1\u0026#39;) {\n    return \u0026#39;This is custom type 1\u0026#39;\n  } else if (param.name === \u0026#39;custom type 2\u0026#39;) {\n    return \u0026#39;This is custom type 2\u0026#39;\n  }\n\n  const isNever: never = param // \u0026#39;isNever\u0026#39; is declared but its value is never read.ts(6133)\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이런 장치를 함수 내부의 포함시키는 것을 통해 타입별 처리를 누락 없이 수행 할 수 있다.\u003c/p\u003e\n",
            "postsByCategory": []
          },
          "__N_SSG": true
        },
        "page": "/[title]",
        "query": { "title": "any-|-unknown-|-never" },
        "buildId": "mGKmApaunwm6G6tWfKdom",
        "isFallback": false,
        "gsp": true,
        "scriptLoader": []
      }
    </script>
  </body>
</html>
