<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta name="viewport" content="width=device-width" />
    <meta charset="utf-8" />
    <link rel="canonical" href="https://code-logs.github.io/iterator-and-generator" />
    <link rel="apple-touch-icon" href="/icons/icon-192x-192.png" />
    <link rel="manifest" href="/manifest.json" />
    <meta name="theme-color" content="#fff" />
    <meta property="og:type" content="website" />
    <meta property="og:site_name" content="Code Logs" />
    <meta name="author" content="Jay Lee" />
    <meta
      name="keyword"
      content="es6, function*, generator, iterable, iterator, javascript, yield, Iterator and Generator, Javascript ES6 Iterator &amp; Generator, 열거형, 제너레이터 함수, generator function, yield, function*, javascript"
    />
    <meta
      name="description"
      content="Code Logs Iterator and Generator - Javascript ES6 Iterator &amp; Generator, 열거형, 제너레이터 함수, generator function, yield, function* | javascript, es6, function*, generator, iterable, iterator, javascript, yield"
    />
    <meta
      property="og:description"
      content="Code Logs Iterator and Generator - Javascript ES6 Iterator &amp; Generator, 열거형, 제너레이터 함수, generator function, yield, function* | javascript, es6, function*, generator, iterable, iterator, javascript, yield"
    />
    <meta property="og:title" content="Iterator and Generator | Code Logs" />
    <meta property="og:url" content="https://code-logs.github.io/iterator-and-generator" />
    <meta property="og:image" content="/assets/images/iterator-generator.png" />
    <title>Iterator and Generator | Code Logs</title>
    <meta name="next-head-count" content="16" />
    <link rel="preload" href="/_next/static/css/a2a37558d2ecc13f.css" as="style" />
    <link rel="stylesheet" href="/_next/static/css/a2a37558d2ecc13f.css" data-n-g="" />
    <link rel="preload" href="/_next/static/css/a8d1921a822eb47e.css" as="style" />
    <link rel="stylesheet" href="/_next/static/css/a8d1921a822eb47e.css" data-n-p="" />
    <noscript data-n-css=""></noscript>
    <script defer="" nomodule="" src="/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script>
    <script src="/_next/static/chunks/webpack-2e51481b1d484a05.js" defer=""></script>
    <script src="/_next/static/chunks/framework-5f4595e5518b5600.js" defer=""></script>
    <script src="/_next/static/chunks/main-a4d9e436b9a532ca.js" defer=""></script>
    <script src="/_next/static/chunks/pages/_app-849862901ca7e682.js" defer=""></script>
    <script src="/_next/static/chunks/294-6603e2d70ff7953e.js" defer=""></script>
    <script src="/_next/static/chunks/117-a066a9c2dcf9a75d.js" defer=""></script>
    <script src="/_next/static/chunks/pages/%5Btitle%5D-215cb6570aa47998.js" defer=""></script>
    <script src="/_next/static/2oYJCirJN2ALp9MytDXct/_buildManifest.js" defer=""></script>
    <script src="/_next/static/2oYJCirJN2ALp9MytDXct/_ssgManifest.js" defer=""></script>
    <script src="/_next/static/2oYJCirJN2ALp9MytDXct/_middlewareManifest.js" defer=""></script>
  </head>
  <body>
    <div id="__next" data-reactroot="">
      <header class="Header_header__RW35m">
        <span class="Header_title__GPS8b">Code Logs</span>
        <ul class="Header_socialIcons__CBf_s">
          <li>
            <a href="https://github.com/possible819" target="_blank" rel="noreferrer" aria-label="My Github"
              ><style data-emotion="css vubbuv">
                .css-vubbuv {
                  -webkit-user-select: none;
                  -moz-user-select: none;
                  -ms-user-select: none;
                  user-select: none;
                  width: 1em;
                  height: 1em;
                  display: inline-block;
                  fill: currentColor;
                  -webkit-flex-shrink: 0;
                  -ms-flex-negative: 0;
                  flex-shrink: 0;
                  -webkit-transition: fill 200ms cubic-bezier(0.4, 0, 0.2, 1) 0ms;
                  transition: fill 200ms cubic-bezier(0.4, 0, 0.2, 1) 0ms;
                  font-size: 1.5rem;
                }</style
              ><svg
                class="MuiSvgIcon-root MuiSvgIcon-fontSizeMedium css-vubbuv"
                focusable="false"
                aria-hidden="true"
                viewBox="0 0 24 24"
                data-testid="GitHubIcon"
              >
                <path
                  d="M12 1.27a11 11 0 00-3.48 21.46c.55.09.73-.28.73-.55v-1.84c-3.03.64-3.67-1.46-3.67-1.46-.55-1.29-1.28-1.65-1.28-1.65-.92-.65.1-.65.1-.65 1.1 0 1.73 1.1 1.73 1.1.92 1.65 2.57 1.2 3.21.92a2 2 0 01.64-1.47c-2.47-.27-5.04-1.19-5.04-5.5 0-1.1.46-2.1 1.2-2.84a3.76 3.76 0 010-2.93s.91-.28 3.11 1.1c1.8-.49 3.7-.49 5.5 0 2.1-1.38 3.02-1.1 3.02-1.1a3.76 3.76 0 010 2.93c.83.74 1.2 1.74 1.2 2.94 0 4.21-2.57 5.13-5.04 5.4.45.37.82.92.82 2.02v3.03c0 .27.1.64.73.55A11 11 0 0012 1.27"
                ></path></svg
            ></a>
          </li>
        </ul>
        <nav class="NavBar_navBar__akqA3">
          <ul>
            <li class="clickable"><a class="MarkedAnchor_anchor__QCmkL" href="/">Home</a></li>
            <li class="clickable"><a class="MarkedAnchor_anchor__QCmkL" href="/posts/1">Posts</a></li>
            <li class="clickable"><a class="MarkedAnchor_anchor__QCmkL" href="/about">About</a></li>
          </ul>
        </nav>
      </header>
      <main>
        <article class="PostDetail_container__Ma_26">
          <p class="PostDetail_publishedAt__7GOQm"><span></span></p>
          <section class="PostDetail_thumbnailWrapper__oALCg">
            <img
              src="/assets/images/iterator-generator.png"
              alt="Javascript ES6 Iterator &amp; Generator, 열거형, 제너레이터 함수, generator function, yield, function*"
            />
          </section>
          <section>
            <h1>Iterator and Generator</h1>
            <p class="PostDetail_description__l6wHC">Javascript ES6 Iterator &amp; Generator, 열거형, 제너레이터 함수, generator function, yield, function*</p>
          </section>
          <section>
            <h2 id="table-of-contents">Table of contents</h2>
            <ol>
              <li>
                <a href="#iterable-and-iterator">Iterable and Iterator</a>
                <ol>
                  <li><a href="#iterable">Iterable</a></li>
                  <li><a href="#iterator">iterator</a></li>
                </ol>
              </li>
              <li><a href="#generator">Generator</a></li>
            </ol>
            <h2 id="iterable-and-iterator">Iterable and Iterator</h2>
            <p>개발을 하다 보면 이런 에러 메시지를 마주치곤 한다.</p>
            <pre><code class="language-javascript">TypeError: variable is not iterable
</code></pre>
            <p>variable이 반복될 수 없다는 의미인데, 정확히 iterable이 어떤 것인지 그리고 iterator는 어떤 것인지 정리한다.</p>
            <h3 id="iterable">Iterable</h3>
            <p>
              Array, Map과 같이 <code>for..of</code>문 내에서 반복 되는 것 처럼 어떤 반복 동작이 가능한 경우 iterable이라 할 수 있다. javascript에는 이미
              내장되어 있는 iterable한 객체들이 몇 있는데 이런 것을 내장 iterable이라 한다.
            </p>
            <p>내장 iterable:</p>
            <ul>
              <li>String</li>
              <li>Array</li>
              <li>TypedArray</li>
              <li>Map</li>
              <li>Set</li>
            </ul>
            <p>
              내장 iterable 외에 사용자가 iterable을 직접 정의해서 사용 할 수 있는데 사용자가 iterable을 직접 정의하기 위해서는 아래의 구조적인 규칙을 반드시
              준수 해야한다.
            </p>
            <ul>
              <li>iterable 객체는 <code>Symbol.iterator</code>를 키로하는 <code>@@iterator</code> 메서드를 갖고 있어야 함.</li>
            </ul>
            <h3 id="iterator">Iterator</h3>
            <p>Iterator는 <code>Iterator protocol</code>을 따르는 객체로, Iterator protocol은 아래의 규칙을 의미한다.</p>
            <ul>
              <li>
                <code>next</code> 메서드를 갖고 있어야 한다.
                <ul>
                  <li>next 메서드는 호출시 { done: boolean, value: any } 형태의 값을 반환해야 한다.</li>
                </ul>
              </li>
              <li><code>Symbol.iterator</code>를 키로하고 <code>iterator</code>를 리턴하는 메서드를 갖고 있어야 한다.</li>
            </ul>
            <pre><code class="language-javascript">const adder = {
  value: 0,
  increment: 2,
  limit: 10,
  next: function () {
    if (this.value &gt;= this.limit) return { done: true }
    return { done: false, value: (this.value += this.increment) }
  },
  [Symbol.iterator]: function () {
    return this
  },
}
</code></pre>
            <p>
              <code>adder</code>라는 객체를 정의 하였다. <code>adder</code>는 <code>value</code>의 초기값 0을 기준으로 매번 반복동작이 수행 될 때 (<code
                >next</code
              >
              메서드가 호출 될 때) 마다 <code>increment</code> 만큼 값이 증가하고 <code>value</code>가 <code>limit</code> 보다 크거나 같을 경우 더이상
              반복동작을 수행 할 수 없다.
            </p>
            <p>
              이와 같이 사용자가 직접 iterable한 객체를 정의 할 수 있다. 구조적으로 조건에 충족하는 iterator를 구현하면 아래와 같은 문법을 통해 해당 객체를 순회
              할 수 있다.
            </p>
            <pre><code class="language-javascript">for (const value of adder) {
  console.log(value)
}

/* 실행 결과:
  2
  4
  6
  8
  10
*/
</code></pre>
            <p>
              당연히 iterator를 통해 값을 순회 할 경우 내부 변수의 값이 변경되기 때문에 순회를 이미 마친 객체는 일반적인 방법으로는 다시 처음의 값으로 되돌릴 수
              없다.
            </p>
            <pre><code class="language-javascript">for (const value of adder) {
  console.log(value)
}

/* 실행 결과:
  2
  4
  6
  8
  10
*/

console.log(&#39;Value&#39;, ...adder)
/* 실행 결과:  
  Value
*/
</code></pre>
            <h2 id="generator">Generator</h2>
            <p>
              <code>Iterator</code>를 직접 정의하여 사용 할 수 있지만 <code>Generator</code> 함수를 이용하면 조금 더 간편하게 <code>iterator</code>를 구현 할 수
              있다.
            </p>
            <p><code>Generator</code> 함수는 일반 함수 정의와 달리 function 키워드 뒤에 <code>*</code>를 붙여야 한다.</p>
            <blockquote>
              <p>Arrow function 정의 방식을 통해서는 generator를 구현 할 수 없음</p>
            </blockquote>
            <p>
              <code>iterator</code>에서 <code>next</code> 메서드를 호출하는 것은 반복구문을 1회 수행한다는 것을 의미하는데 <code>Generator</code> 함수에서는
              <code>yield</code> 키워드를 통해 함수 반복구문의 범위를 설정 할 수 있다.
            </p>
            <p>아래 예제 코드를 보면 앞서 설명한 이야기를 조금 더 쉽게 이해 할 수 있다.</p>
            <pre><code class="language-javascript">function* adder() {
  let value = 0
  const increment = 2
  const limit = 10

  value += increment
  yield value

  value += increment
  yield value

  value += increment
  yield value

  value += increment
  yield value

  value += increment
  yield value
}

for (const value of adder()) {
  console.log(value)
}

/* 실행 결과:
  2
  4
  6
  8
  10
*/
</code></pre>
            <p><code>Generator</code> 함수 내부에서 루프문을 이용하면 조금더 쉽게 반복구문을 정의 할 수 있다.</p>
            <pre><code class="language-javascript">function* adder() {
  let value = 0
  const increment = 2
  const limit = 10

  while (value &lt; limit) {
    yield (value += increment)
  }
}

for (const value of adder()) {
  console.log(value)
}

/* 실행 결과:
  2
  4
  6
  8
  10
*/
</code></pre>
            <p>
              개인적으로 <code>Generator</code> 함수를 사용하여 실무에서 무언가 작업한 경험은 극히 드물다 . 반복적인 작업을 처리할 때 <code>Iterator</code>와
              <code>Generator</code>를 떠올리기 보단 <code>Array</code>를 통해 간단히 해결하는 것이 대부분인 것 같다. 그런데 순차적인 반복구문의 수행 그리고
              일정 범위에 도달 했을 때의 반복 불가와 같은 <code>Iterable</code>의 특징은 단방향의 절차적 흐름을 가지고 있는 데이터를 처리하는데 용이하다는
              생각이 든다.
            </p>
          </section>
        </article>
        <section class="MainAdsBanner_container__YWe5C">
          <ins
            class="adsbygoogle"
            style="display: block"
            data-ad-client="ca-pub-7134579063537339"
            data-ad-slot="5391522351"
            data-ad-format="auto"
            data-full-width-responsive="true"
          ></ins>
        </section>
        <section class="PostDetail_categoryGroup___S2ib">
          <h2>카테고리 더보기</h2>
          <ul class="CategoryPostGroup_container__MDFUe"></ul>
        </section>
        <section class="PostDetail_utterances__jZeOm">
          <h2>댓글</h2>
          <div class="Utterrances_utteranceContainer__qopWy"></div>
        </section>
      </main>
      <aside></aside>
      <footer class="Footer_footer__GLL0J"><p>ⓒ 2021. Jay Lee all rights reserved.</p></footer>
    </div>
    <script id="__NEXT_DATA__" type="application/json">
      {
        "props": {
          "pageProps": {
            "post": {
              "title": "Iterator and Generator",
              "description": "Javascript ES6 Iterator \u0026 Generator, 열거형, 제너레이터 함수, generator function, yield, function*",
              "fileName": "iterator-generator.md",
              "category": "javascript",
              "published": true,
              "publishedAt": "2021-10-17",
              "thumbnailName": "iterator-generator.png",
              "tags": ["es6", "function*", "generator", "iterable", "iterator", "javascript", "yield"],
              "order": 2
            },
            "content": "\u003ch2 id=\"table-of-contents\"\u003eTable of contents\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003e\u003ca href=\"#iterable-and-iterator\"\u003eIterable and Iterator\u003c/a\u003e\u003col\u003e\n\u003cli\u003e\u003ca href=\"#iterable\"\u003eIterable\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#iterator\"\u003eiterator\u003c/a\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#generator\"\u003eGenerator\u003c/a\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2 id=\"iterable-and-iterator\"\u003eIterable and Iterator\u003c/h2\u003e\n\u003cp\u003e개발을 하다 보면 이런 에러 메시지를 마주치곤 한다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003eTypeError: variable is not iterable\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003evariable이 반복될 수 없다는 의미인데, 정확히 iterable이 어떤 것인지 그리고 iterator는 어떤 것인지 정리한다.\u003c/p\u003e\n\u003ch3 id=\"iterable\"\u003eIterable\u003c/h3\u003e\n\u003cp\u003eArray, Map과 같이 \u003ccode\u003efor..of\u003c/code\u003e문 내에서 반복 되는 것 처럼 어떤 반복 동작이 가능한 경우 iterable이라 할 수 있다. javascript에는 이미 내장되어 있는 iterable한 객체들이 몇 있는데 이런 것을 내장 iterable이라 한다.\u003c/p\u003e\n\u003cp\u003e내장 iterable:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eString\u003c/li\u003e\n\u003cli\u003eArray\u003c/li\u003e\n\u003cli\u003eTypedArray\u003c/li\u003e\n\u003cli\u003eMap\u003c/li\u003e\n\u003cli\u003eSet\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e내장 iterable 외에 사용자가 iterable을 직접 정의해서 사용 할 수 있는데 사용자가 iterable을 직접 정의하기 위해서는 아래의 구조적인 규칙을 반드시 준수 해야한다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eiterable 객체는 \u003ccode\u003eSymbol.iterator\u003c/code\u003e를 키로하는 \u003ccode\u003e@@iterator\u003c/code\u003e 메서드를 갖고 있어야 함.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"iterator\"\u003eIterator\u003c/h3\u003e\n\u003cp\u003eIterator는 \u003ccode\u003eIterator protocol\u003c/code\u003e을 따르는 객체로, Iterator protocol은 아래의 규칙을 의미한다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003enext\u003c/code\u003e 메서드를 갖고 있어야 한다.\u003cul\u003e\n\u003cli\u003enext 메서드는 호출시 { done: boolean, value: any } 형태의 값을 반환해야 한다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eSymbol.iterator\u003c/code\u003e를 키로하고 \u003ccode\u003eiterator\u003c/code\u003e를 리턴하는 메서드를 갖고 있어야 한다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003econst adder = {\n  value: 0,\n  increment: 2,\n  limit: 10,\n  next: function () {\n    if (this.value \u0026gt;= this.limit) return { done: true }\n    return { done: false, value: (this.value += this.increment) }\n  },\n  [Symbol.iterator]: function () {\n    return this\n  },\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003eadder\u003c/code\u003e라는 객체를 정의 하였다. \u003ccode\u003eadder\u003c/code\u003e는 \u003ccode\u003evalue\u003c/code\u003e의 초기값 0을 기준으로 매번 반복동작이 수행 될 때 (\u003ccode\u003enext\u003c/code\u003e 메서드가 호출 될 때) 마다 \u003ccode\u003eincrement\u003c/code\u003e 만큼 값이 증가하고 \u003ccode\u003evalue\u003c/code\u003e가 \u003ccode\u003elimit\u003c/code\u003e 보다 크거나 같을 경우 더이상 반복동작을 수행 할 수 없다.\u003c/p\u003e\n\u003cp\u003e이와 같이 사용자가 직접 iterable한 객체를 정의 할 수 있다. 구조적으로 조건에 충족하는 iterator를 구현하면 아래와 같은 문법을 통해 해당 객체를 순회 할 수 있다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003efor (const value of adder) {\n  console.log(value)\n}\n\n/* 실행 결과:\n  2\n  4\n  6\n  8\n  10\n*/\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e당연히 iterator를 통해 값을 순회 할 경우 내부 변수의 값이 변경되기 때문에 순회를 이미 마친 객체는 일반적인 방법으로는 다시 처음의 값으로 되돌릴 수 없다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003efor (const value of adder) {\n  console.log(value)\n}\n\n/* 실행 결과:\n  2\n  4\n  6\n  8\n  10\n*/\n\nconsole.log(\u0026#39;Value\u0026#39;, ...adder)\n/* 실행 결과:  \n  Value\n*/\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"generator\"\u003eGenerator\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003eIterator\u003c/code\u003e를 직접 정의하여 사용 할 수 있지만 \u003ccode\u003eGenerator\u003c/code\u003e 함수를 이용하면 조금 더 간편하게 \u003ccode\u003eiterator\u003c/code\u003e를 구현 할 수 있다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eGenerator\u003c/code\u003e 함수는 일반 함수 정의와 달리 function 키워드 뒤에 \u003ccode\u003e*\u003c/code\u003e를 붙여야 한다.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eArrow function 정의 방식을 통해서는 generator를 구현 할 수 없음\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e\u003ccode\u003eiterator\u003c/code\u003e에서 \u003ccode\u003enext\u003c/code\u003e 메서드를 호출하는 것은 반복구문을 1회 수행한다는 것을 의미하는데 \u003ccode\u003eGenerator\u003c/code\u003e 함수에서는 \u003ccode\u003eyield\u003c/code\u003e 키워드를 통해 함수 반복구문의 범위를 설정 할 수 있다.\u003c/p\u003e\n\u003cp\u003e아래 예제 코드를 보면 앞서 설명한 이야기를 조금 더 쉽게 이해 할 수 있다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003efunction* adder() {\n  let value = 0\n  const increment = 2\n  const limit = 10\n\n  value += increment\n  yield value\n\n  value += increment\n  yield value\n\n  value += increment\n  yield value\n\n  value += increment\n  yield value\n\n  value += increment\n  yield value\n}\n\nfor (const value of adder()) {\n  console.log(value)\n}\n\n/* 실행 결과:\n  2\n  4\n  6\n  8\n  10\n*/\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003eGenerator\u003c/code\u003e 함수 내부에서 루프문을 이용하면 조금더 쉽게 반복구문을 정의 할 수 있다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003efunction* adder() {\n  let value = 0\n  const increment = 2\n  const limit = 10\n\n  while (value \u0026lt; limit) {\n    yield (value += increment)\n  }\n}\n\nfor (const value of adder()) {\n  console.log(value)\n}\n\n/* 실행 결과:\n  2\n  4\n  6\n  8\n  10\n*/\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e개인적으로 \u003ccode\u003eGenerator\u003c/code\u003e 함수를 사용하여 실무에서 무언가 작업한 경험은 극히 드물다 . 반복적인 작업을 처리할 때 \u003ccode\u003eIterator\u003c/code\u003e와 \u003ccode\u003eGenerator\u003c/code\u003e를 떠올리기 보단 \u003ccode\u003eArray\u003c/code\u003e를 통해 간단히 해결하는 것이 대부분인 것 같다. 그런데 순차적인 반복구문의 수행 그리고 일정 범위에 도달 했을 때의 반복 불가와 같은 \u003ccode\u003eIterable\u003c/code\u003e의 특징은 단방향의 절차적 흐름을 가지고 있는 데이터를 처리하는데 용이하다는 생각이 든다.\u003c/p\u003e\n",
            "postsByCategory": [
              {
                "title": "Proxy",
                "description": "Javascript ES6 Proxy, Proxy, Trap, 프락시를 이용한 객체 조작의 제어",
                "fileName": "proxy.md",
                "category": "javascript",
                "published": true,
                "publishedAt": "2021-10-25",
                "thumbnailName": "proxy.png",
                "tags": ["es6", "javascript", "proxy", "trap", "프록시"],
                "order": 3
              },
              {
                "title": "Tagged Template Literal",
                "description": "Javascript ES6 Tagged Template Literal",
                "fileName": "tagged-template-literal.md",
                "category": "javascript",
                "published": true,
                "publishedAt": "2021-10-11",
                "thumbnailName": "tagged-template-literal.png",
                "tags": ["es6", "javascript", "tagged template", "tagged template literal"],
                "order": 1
              }
            ]
          },
          "__N_SSG": true
        },
        "page": "/[title]",
        "query": { "title": "iterator-and-generator" },
        "buildId": "2oYJCirJN2ALp9MytDXct",
        "isFallback": false,
        "gsp": true,
        "scriptLoader": []
      }
    </script>
  </body>
</html>
