<!DOCTYPE html><html lang="ko"><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-1V105VZWBB"></script><script>
            window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-1V105VZWBB');
          </script><meta name="theme-color" content="#fff"/><link rel="apple-touch-icon" href="/icons/icon-192x-192.png"/><script>
      if ('serviceWorker' in navigator) {
        navigator.serviceWorker.register('/service-worker.js')
      }
    </script><link rel="manifest" href="/manifest.json"/><meta property="og:type" content="website"/><meta property="og:title" content="Code Logs | Scroll sequence animation"/><meta property="og:site_name" content="Code Logs"/><meta property="og:url" content="https://code-logs.github.io/scroll-sequence-animation"/><meta property="og:image" content="/assets/images/scroll-sequence.jpg"/><meta property="og:description" content="Apple 제품 페이지 같은 애니메이션을 구현해보자 - Scroll sequence animation"/><meta name="description" content="Apple 제품 페이지 같은 애니메이션을 구현해보자 - Scroll sequence animation"/><meta name="keyword" content="scroll sequence, scroll sequence animation, ui, ux"/><meta name="author" content="Jay Lee"/><title>Code Logs | Scroll sequence animation</title><link rel="canonical" href="https://code-logs.github.io/scroll-sequence-animation"/><meta name="next-head-count" content="8"/><link rel="preload" href="/_next/static/css/9df3b59472b89686.css" as="style"/><link rel="stylesheet" href="/_next/static/css/9df3b59472b89686.css" data-n-g=""/><link rel="preload" href="/_next/static/css/456c2ee87444a113.css" as="style"/><link rel="stylesheet" href="/_next/static/css/456c2ee87444a113.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script src="/_next/static/chunks/webpack-2e51481b1d484a05.js" defer=""></script><script src="/_next/static/chunks/framework-5f4595e5518b5600.js" defer=""></script><script src="/_next/static/chunks/main-a054bbf31fb90f6a.js" defer=""></script><script src="/_next/static/chunks/pages/_app-5e70abd07452e721.js" defer=""></script><script src="/_next/static/chunks/637-73741de646378e61.js" defer=""></script><script src="/_next/static/chunks/pages/%5Btitle%5D-848d20d3c0470f7c.js" defer=""></script><script src="/_next/static/Fih1bmwo9sXnBcCqz_UPk/_buildManifest.js" defer=""></script><script src="/_next/static/Fih1bmwo9sXnBcCqz_UPk/_ssgManifest.js" defer=""></script><script src="/_next/static/Fih1bmwo9sXnBcCqz_UPk/_middlewareManifest.js" defer=""></script></head><body><div id="__next" data-reactroot=""><header class="Header_header__RW35m"><p class="Header_title__GPS8b">Code Logs</p><ul class="Header_socialIcons__CBf_s"><li><a href="https://github.com/possible819" target="_blank" rel="noreferrer" aria-label="My Github"><style data-emotion="css vubbuv">.css-vubbuv{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;width:1em;height:1em;display:inline-block;fill:currentColor;-webkit-flex-shrink:0;-ms-flex-negative:0;flex-shrink:0;-webkit-transition:fill 200ms cubic-bezier(0.4, 0, 0.2, 1) 0ms;transition:fill 200ms cubic-bezier(0.4, 0, 0.2, 1) 0ms;font-size:1.5rem;}</style><svg class="MuiSvgIcon-root MuiSvgIcon-fontSizeMedium css-vubbuv" focusable="false" aria-hidden="true" viewBox="0 0 24 24" data-testid="GitHubIcon"><path d="M12 1.27a11 11 0 00-3.48 21.46c.55.09.73-.28.73-.55v-1.84c-3.03.64-3.67-1.46-3.67-1.46-.55-1.29-1.28-1.65-1.28-1.65-.92-.65.1-.65.1-.65 1.1 0 1.73 1.1 1.73 1.1.92 1.65 2.57 1.2 3.21.92a2 2 0 01.64-1.47c-2.47-.27-5.04-1.19-5.04-5.5 0-1.1.46-2.1 1.2-2.84a3.76 3.76 0 010-2.93s.91-.28 3.11 1.1c1.8-.49 3.7-.49 5.5 0 2.1-1.38 3.02-1.1 3.02-1.1a3.76 3.76 0 010 2.93c.83.74 1.2 1.74 1.2 2.94 0 4.21-2.57 5.13-5.04 5.4.45.37.82.92.82 2.02v3.03c0 .27.1.64.73.55A11 11 0 0012 1.27"></path></svg></a></li><li><a href="https://linkedin.com/in/jaylee819" target="_blank" rel="noreferrer" aria-label="My Linked in"><style data-emotion="css vubbuv">.css-vubbuv{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;width:1em;height:1em;display:inline-block;fill:currentColor;-webkit-flex-shrink:0;-ms-flex-negative:0;flex-shrink:0;-webkit-transition:fill 200ms cubic-bezier(0.4, 0, 0.2, 1) 0ms;transition:fill 200ms cubic-bezier(0.4, 0, 0.2, 1) 0ms;font-size:1.5rem;}</style><svg class="MuiSvgIcon-root MuiSvgIcon-fontSizeMedium css-vubbuv" focusable="false" aria-hidden="true" viewBox="0 0 24 24" data-testid="LinkedInIcon"><path d="M19 3a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h14m-.5 15.5v-5.3a3.26 3.26 0 0 0-3.26-3.26c-.85 0-1.84.52-2.32 1.3v-1.11h-2.79v8.37h2.79v-4.93c0-.77.62-1.4 1.39-1.4a1.4 1.4 0 0 1 1.4 1.4v4.93h2.79M6.88 8.56a1.68 1.68 0 0 0 1.68-1.68c0-.93-.75-1.69-1.68-1.69a1.69 1.69 0 0 0-1.69 1.69c0 .93.76 1.68 1.69 1.68m1.39 9.94v-8.37H5.5v8.37h2.77z"></path></svg></a></li></ul><nav class="NavBar_navBar__akqA3"><ul><li><a class="" href="https://code-logs.github.io/">Home</a></li><li><a class="" href="https://code-logs.github.io/posts/1">Posts</a></li><li><a class="" href="https://code-logs.github.io/about">About</a></li></ul></nav></header><main><article class="PostDetail_container__Ma_26"><section class="PostDetail_thumbnailWrapper__oALCg"><img src="/assets/images/scroll-sequence.jpg" alt="Apple 제품 페이지 같은 애니메이션을 구현해보자 - Scroll sequence animation"/></section><section><h1>Scroll sequence animation</h1><p class="PostDetail_description__l6wHC">Apple 제품 페이지 같은 애니메이션을 구현해보자 - Scroll sequence animation</p></section><section><h2 id="table-of-contents">Table of contents</h2>
<ol>
<li><p><a href="#scroll-sequence-animation">Scroll Sequence Animation</a></p>
</li>
<li><p><a href="#how-to-implement">How to implement</a></p>
<ol>
<li><a href="#dom-%EA%B5%AC%EC%A1%B0">DOM 구조</a></li>
<li><a href="#canvas-element-%EC%83%9D%EC%84%B1">Canvas element 생성</a></li>
<li><a href="#canvas-api%EB%A5%BC-%ED%86%B5%ED%95%9C-%EC%9D%B4%EB%AF%B8%EC%A7%80-%EA%B7%B8%EB%A6%AC%EA%B8%B0">Canvas API를 통한 이미지 그리기</a></li>
<li><a href="#scroll-%EC%9D%B4%EB%B2%A4%ED%8A%B8-%EB%93%B1%EB%A1%9D-%EB%B0%8F-%ED%98%84%EC%9E%AC-%ED%94%84%EB%A0%88%EC%9E%84-%EA%B3%84%EC%82%B0">Scroll 이벤트 등록 및 현재 프레임 계산</a></li>
<li><a href="#%EC%9D%B4%EB%AF%B8%EC%A7%80-%EB%B6%88%EB%9F%AC%EC%98%A4%EA%B8%B0%EC%99%80-%EC%B5%9C%EC%A0%81%ED%99%94">이미지 불러오기와 최적화</a></li>
<li><a href="#%EC%B4%88%EA%B8%B0-%EC%9D%B4%EB%AF%B8%EC%A7%80-%EA%B7%B8%EB%A6%AC%EA%B8%B0">초기 이미지 그리기</a></li>
<li><a href="#%EA%B7%B8-%EB%B0%96%EC%9D%98-%EC%B5%9C%EC%A0%81%ED%99%94">그 밖의 최적화</a></li>
</ol>
</li>
</ol>
<h2 id="scroll-sequence-animation">Scroll Sequence Animation</h2>
<div align=center>

<p><a href="/examples/scroll-sequence-animation/index.html">Sample Page</a></p>
</div>

<p>요즘 많은 사이트에서 <code>Scroll Sequence Animation</code>을 이용한 화면들을 접할 수 있다. 나도 처음 이런 애니메이션 기법을 봤을 때 &#39;오...&#39;라며 감탄했던 기억이 있다.</p>
<p>처음으로 이 애니메이션을 접한 사이트는 apple의 제품 소개 페이지였던 것으로 기억하는데 그 이후로 종종 다른 사이트에서도 볼 수 있었다.</p>
<p>동일한 화면을 구현할 일이 없어 &#39;나중에 필요할 때 해보지 뭐&#39;라며 넘겼었는데 며칠 전 문득 포스팅을 하면서 한번 뜯어 봐야겠다는 생각이 들었다.</p>
<p>대부분의 Apple 제품 소개 페이지에서 볼 수 있는 애니메이션으로 특별히 샘플 이미지나 영상을 첨부하지 않아도 어떤 것인지 기억 할 수 있으리라 생각한다.</p>
<p>간단히 말로 풀어 정리하면... 사용자가 스크롤을 내리거나 올리는 것을 통해 이미지의 프레임을 앞/뒤로 넘기고 프레임이 넘어감에 따라 이어지는 영상과 같은 효과를 내는 것이 <code>Scroll Sequence Animation</code>이다.</p>
<h2 id="how-to-implement">How to implement</h2>
<p>그럼 내친김에 한번 만들어 봐야겠다.</p>
<p>우선 <code>Scroll Sequence Animation</code>을 구현하기 위해 메커니즘을 정리하고 시작한다.</p>
<ol>
<li>고정된 포지션에 이미지가 노출된다.</li>
<li>노출된 이미지는 스크롤을 움직이더라도 처음 포지션을 그대로 유지한다.</li>
<li>스크롤이 내려가거나 올라감에 따라 노출된 이미지가 변경된다.<ul>
<li>스크롤 가능한 영역의 높이와 전체 이미지수를 통해 스크롤 대비 프레임 인덱스를 계산하고 이를 기준으로 이미지를 변경한다</li>
</ul>
</li>
<li>스크롤 가능한 범위를 넘어설 경우 이미지는 더이상 고정되지 않고 화면에서 사라진다<ul>
<li>이렇게 하지 않을 경우 페이지의 다음 내용을 출력할 수 없을 것이다.</li>
</ul>
</li>
</ol>
<p>이제 하나씩 순서대로 구현해 보자.</p>
<h3 id="dom-구조">DOM 구조</h3>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;ko&quot;&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot; /&gt;
    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;
    &lt;title&gt;Scroll Sequence Animation&lt;/title&gt;

    &lt;style&gt;
      html,
      body {
        margin: 0px;
        width: 100%;
        height: 100%;
      }

      main {
        height: 100%;
        overflow: auto;
      }

      .boundary {
        margin: 0px auto;
        height: 2400px;
      }

      .boundary.begin {
        background: rgb(2, 0, 36);
        background: linear-gradient(
          180deg,
          rgba(2, 0, 36, 1) 0%,
          rgba(250, 32, 74, 1) 50%,
          rgba(250, 32, 74, 1) 100%
        );
      }

      .boundary.end {
        background: rgb(2, 0, 36);
        background: linear-gradient(
          180deg,
          rgba(250, 32, 74, 1) 0%,
          rgba(250, 32, 74, 1) 50%,
          rgba(2, 0, 36, 1) 100%
        );
      }

      #wrapper {
        margin: 0px auto;
        height: 3600px;
        background-color: rgba(250, 32, 74, 1);
      }
    &lt;/style&gt;

    &lt;script defer src=&quot;./scroll-sequence.js&quot;&gt;&lt;/script&gt;
  &lt;/head&gt;

  &lt;body&gt;
    &lt;main&gt;
      &lt;div class=&quot;boundary begin&quot;&gt;&lt;/div&gt;
      &lt;div id=&quot;wrapper&quot;&gt;&lt;/div&gt;
      &lt;div class=&quot;boundary end&quot;&gt;&lt;/div&gt;
    &lt;/main&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<ul>
<li><code>&lt;main&gt;</code> 스크롤이 가능한 전체 영역</li>
<li><code>&lt;div class=&quot;boundary begin&quot;&gt;&lt;/div&gt;</code> 이미지에 앞서 나타나는 컨텐츠 영역</li>
<li><code>&lt;div id=&quot;wrapper&quot;&gt;&lt;/div&gt;</code> 이미지가 출력되는 영역으로 해당 영역 내부에서 <code>&lt;canvas&gt;</code>가 생성됨</li>
<li><code>&lt;div class=&quot;boundary end&quot;&gt;&lt;/div&gt;</code> 이미지에 이어 나타나는 컨텐츠 영역</li>
</ul>
<h3 id="canvas-element-생성">Canvas element 생성</h3>
<p>이제 <code>JavaScript</code> 파일 (<code>scroll-sequence.js</code>)을 생성한다.
<code>&lt;div id=&quot;wrapper&quot;&gt;&lt;/div&gt;</code> 아래에 <code>canvas</code> 엘리먼트를 생성해서 <code>append</code> 한다.
<code>canvas</code>의 너비와 높이는 <code>css</code>를 통해 설정하지 않고 <code>canvas</code> tag의 프로퍼티를 통해 결정한다.</p>
<blockquote>
<p><code>css</code>를 통해 너비와 높이를 설정 할 경우 이미지의 해상도가 깨지기 때문에 반드시 프로퍼티를 통해 설정해야함</p>
</blockquote>
<p><code>&lt;script&gt;&lt;/script&gt;</code> 태그에 <code>defer</code> 어트리뷰트를 설정 했기 때문에 <code>&lt;div id=&quot;wrapper&quot;&gt;&lt;/div&gt;</code>의 너비와 높이를 추출 할 수 있을 때 <code>script</code>가 실행된다.</p>
<blockquote>
<p><code>async</code> &amp; <code>defer</code></p>
<p>async</p>
<p>async 어트리뷰트를 가지고 있는 script 태그는 DOM parsing을 블록하지 않고 스크립트를 다운로드 받게된다.</p>
<p>스크립트의 다운로드가 완료되는 즉시 실행된다.</p>
<p>defer</p>
<p>defer 어트리뷰트를 가지고 있는 script 태그 또한 DOM parsing을 블록하지 않고 스크립트를 다운받는다.</p>
<p>defer script는 DOMContentLoaded 이벤트 이후에 실행되게 된다.</p>
</blockquote>
<p><code>&lt;div id=&quot;wrapper&quot;&gt;&lt;/div&gt;</code>의 현재 너비를 추출하여 <code>canvas</code>를 생성한다.</p>
<pre><code class="language-javascript">const wrapper = document.querySelector(&#39;#wrapper&#39;)
const canvas = document.createElement(&#39;canvas&#39;)
const context = canvas.getContext(&#39;2d&#39;) // get 2D context
canvas.width = wrapper.offsetWidth
canvas.height = (canvas.width / 3) * 2 // 예제에서 사용할 이미지가 3:2 비율을 갖고 있기 때문에 `canvas`의 높이를 이와 같이 계산함

canvas.style.position = &#39;sticky&#39; // wrapper 영역 내에서 상대 위치를 유지하기 위한 position
canvas.style.top = &#39;50%&#39; // 이미지가 정중앙에 표시되도록 하기 위한 style
canvas.style.transform = &#39;translateY(-50%)&#39; // 이미지가 정중앙에 표시되도록 하기 위한 style

wrapper.append(canvas)
</code></pre>
<h3 id="canvas-api를-통한-이미지-그리기">Canvas API를 통한 이미지 그리기</h3>
<p><code>Canvas API</code>는 <code>JavaScript</code>와 <code>HTML canvas</code> 엘리먼트를 통해 브라우저 상에서 그래픽을 그리기 위한 수단으로 제공된다. 자세한 내용은 <a href="https://developer.mozilla.org/ko/docs/Web/API/Canvas_API">이곳의 문서</a>를 통해 확인 할 수 있다.</p>
<p>이번에 사용할 <code>canvas api</code>는 2D 컨텍스트의 <code>canvas</code>에 그림을 그려 넣는 <code>(drawImage)</code> 것으로 충분하다.</p>
<pre><code class="language-javascript">const img = new Image()

img.onload = () =&gt; {
  context.drawImage(img, 0, 0, canvas.width, canvas.height)
}

img.src = &#39;PATH/TO/IMAGE.img&#39;
</code></pre>
<p>위의 <code>syntax</code>를 통해 이미지를 로드하고 <code>canvas</code> 엘리먼트의 컨택스트를 통해 내부에 이미지를 그려낼 수 있다.</p>
<h3 id="scroll-이벤트-등록-및-현재-프레임-계산">Scroll 이벤트 등록 및 현재 프레임 계산</h3>
<p>스크롤 가능한 영역 <code>&lt;main&gt;</code> 엘리먼트에 <code>scroll</code> 이벤트 리스너를 등록한다.</p>
<pre><code class="language-javascript">const main = document.querySelector(&#39;main&#39;)
main.onscroll = onScrollHandler
</code></pre>
<p><code>onScrollHandler</code> 함수에서는 <code>&lt;main&gt;</code> 엘리먼트의 <code>scrollTop</code>과 <code>startScrollY</code> 그리고 <code>standardHeight</code>를 통해 현재 출력돼야 하는 이미지의 index를 계산한다.</p>
<blockquote>
<p>startScrollY</p>
<p>스크롤에 의해 이미지 프레임을 증가/감소시킬 최소한의 y축 높이를 갖고 있는 변수</p>
<p>standardHeight</p>
<p>프레임을 1 증가/감소시키기 위한 최소 scroll 높이로 canvas의 높이를 총 프레임수 (이미지 수)로 나눈 것과 같다</p>
</blockquote>
<pre><code class="language-javascript">const computeStartScrollY = () =&gt; {
  let prevElementSibling = wrapper.previousElementSibling
  let height = 0
  while (prevElementSibling) {
    height += prevElementSibling.offsetHeight
    prevElementSibling = prevElementSibling.previousElementSibling
  }

  return height
}

const startScrollY = computeStartScrollY()
const standardHeight = canvas.height / imageSources.length

const currentFrameIndex = () =&gt; {
  const index = Math.floor((main.scrollTop - startScrollY) / standardHeight)
  if (index &lt; 0) return 0 // index가 음수일 경우 스크롤이 아직 startScrollY에 도달하지 못한 경우 =&gt; 첫번째 인덱스를 리턴
  if (!imageSources[index]) return imageSources.length - 1 // index를 통해 imageSource를 찾지 못하는경우 =&gt; 마지막 인덱스를 리턴

  return index
}

const render = () =&gt; {
  const frameIndex = currentFrameIndex()
  const image = new Image()
  image.src = imageSources[frameIndex]
  context.drawImage(image, 0, 0, canvas.width, canvas.height)
}

const onScrollHandler = () =&gt; {
  requestAnimationFrame(render)
}
</code></pre>
<blockquote>
<p><code>requestAnimationFrame</code></p>
<p><code>requestAnimationFrame</code>의 콜백으로 등록된 함수는 Browser가 리페인트를 수행하기전에 호출된다.
<code>requestAnimationFrame</code>에 콜백을 등록하는 것을 통해 <code>canvas</code>의 이미지를 안정적으로 갱신 할 수 있다</p>
<p><code>requestAnimationFrame</code>은 성능 및 베터리 수명을 고려하여 <code>hidden</code> 엘리먼트 또는 background 탭에서는 실행이 중단된다.</p>
</blockquote>
<h3 id="이미지-불러오기와-최적화">이미지 불러오기와 최적화</h3>
<p>이미지는 <code>imagesSources</code>라는 배열에 이미지를 참조하기 위한 경로를 저장하도록 한다.</p>
<pre><code class="language-javascript">const imageSources = Array(121)
  .fill(&#39;&#39;)
  .map((_, idx) =&gt; `./images/${String(idx + 1).padStart(3, &#39;0&#39;)}.png`)
</code></pre>
<blockquote>
<p>각 프레임에 해당하는 이미지는 일종의 규칙을 갖게 하여 코드를 통해 경로를 저장하도록 함</p>
<p>예제에서는 [001 ~ 121].png 까지 이미지 파일을 각 프레임으로 사용</p>
</blockquote>
<p>이미지를 변수에 담았으니 앞서 정의한 <code>render</code> 함수를 통해 <code>canvas</code>에 이미지를 그려주면 되는데
프레임이 변경될 때마다 이미지를 다운받고 그리게 되면 이미지가 모두 다운로드 되기 전에 이미 다음 프레임을 보여줘야 할 때가 되었을 가능성이 크다.</p>
<p>이미지를 <code>preloading</code>하여 사전에 이미지를 다운 받아두고 <code>render</code>가 호출 될 때에는 <code>cache</code>된 이미지를 그리도록 해야한다.</p>
<pre><code class="language-javascript">const preloadImages = () =&gt; {
  imageSources.forEach((imgSrc) =&gt; {
    const img = new Image()
    img.src = imgSrc
  })
}
</code></pre>
<h3 id="초기-이미지-그리기">초기 이미지 그리기</h3>
<p><code>canvas</code>에 이미지가 채워지는 시점은 <code>scroll</code> 이벤트가 발생 했을 때다. 만약 화면이 로딩되고 스크롤을 움직이지 않는다면 <code>canvas</code>는 비어 있는 상태일 것이다.
명시적으로 첫번째 이미지를 그리도록 하여 비어 있는 <code>canvas</code>가 노출 되지 않도록 한다.</p>
<pre><code class="language-javascript">const initFirstFrame = () =&gt; {
  const image = new Image()
  image.src = imageSources[0]
  image.onload = () =&gt;
    context.drawImage(image, 0, 0, canvas.width, canvas.height)
}
</code></pre>
<h3 id="그-밖의-최적화">그 밖의 최적화</h3>
<p>아무래도 여러개의 이미지 파일을 다운받아야 하기 때문에 UX 및 성능상의 이슈를 고려해야한다.</p>
<ul>
<li>네트워크 속도가 좋지 못하여 빠른 속도로 이미지를 다운 받지 못하는 환경</li>
<li>데이터 소모에 대해 거부감을 갖고 있는 사용자</li>
</ul>
<p>등의 경우에 따라 에니메이션 효과를 적용하는 것이 아닌 대표 이미지만 나타내도록 하는 것이 방법이 될 것 같다.</p>
</section></article><section class="PostDetail_utterances__jZeOm"><h2>Comments</h2><div></div></section></main><footer class="Footer_footer__GLL0J"><p>ⓒ 2021. Jay Lee  all rights reserved.</p></footer></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"Scroll sequence animation","fileName":"scroll-sequence-animation.md","description":"Apple 제품 페이지 같은 애니메이션을 구현해보자 - Scroll sequence animation","category":"UI and UX","published":true,"publishedAt":"2021-10-31","tags":["scroll sequence","scroll sequence animation","ui","ux"],"thumbnailName":"scroll-sequence.jpg"},"content":"\u003ch2 id=\"table-of-contents\"\u003eTable of contents\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003e\u003cp\u003e\u003ca href=\"#scroll-sequence-animation\"\u003eScroll Sequence Animation\u003c/a\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cp\u003e\u003ca href=\"#how-to-implement\"\u003eHow to implement\u003c/a\u003e\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003ca href=\"#dom-%EA%B5%AC%EC%A1%B0\"\u003eDOM 구조\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#canvas-element-%EC%83%9D%EC%84%B1\"\u003eCanvas element 생성\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#canvas-api%EB%A5%BC-%ED%86%B5%ED%95%9C-%EC%9D%B4%EB%AF%B8%EC%A7%80-%EA%B7%B8%EB%A6%AC%EA%B8%B0\"\u003eCanvas API를 통한 이미지 그리기\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#scroll-%EC%9D%B4%EB%B2%A4%ED%8A%B8-%EB%93%B1%EB%A1%9D-%EB%B0%8F-%ED%98%84%EC%9E%AC-%ED%94%84%EB%A0%88%EC%9E%84-%EA%B3%84%EC%82%B0\"\u003eScroll 이벤트 등록 및 현재 프레임 계산\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#%EC%9D%B4%EB%AF%B8%EC%A7%80-%EB%B6%88%EB%9F%AC%EC%98%A4%EA%B8%B0%EC%99%80-%EC%B5%9C%EC%A0%81%ED%99%94\"\u003e이미지 불러오기와 최적화\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#%EC%B4%88%EA%B8%B0-%EC%9D%B4%EB%AF%B8%EC%A7%80-%EA%B7%B8%EB%A6%AC%EA%B8%B0\"\u003e초기 이미지 그리기\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#%EA%B7%B8-%EB%B0%96%EC%9D%98-%EC%B5%9C%EC%A0%81%ED%99%94\"\u003e그 밖의 최적화\u003c/a\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2 id=\"scroll-sequence-animation\"\u003eScroll Sequence Animation\u003c/h2\u003e\n\u003cdiv align=center\u003e\n\n\u003cp\u003e\u003ca href=\"/examples/scroll-sequence-animation/index.html\"\u003eSample Page\u003c/a\u003e\u003c/p\u003e\n\u003c/div\u003e\n\n\u003cp\u003e요즘 많은 사이트에서 \u003ccode\u003eScroll Sequence Animation\u003c/code\u003e을 이용한 화면들을 접할 수 있다. 나도 처음 이런 애니메이션 기법을 봤을 때 \u0026#39;오...\u0026#39;라며 감탄했던 기억이 있다.\u003c/p\u003e\n\u003cp\u003e처음으로 이 애니메이션을 접한 사이트는 apple의 제품 소개 페이지였던 것으로 기억하는데 그 이후로 종종 다른 사이트에서도 볼 수 있었다.\u003c/p\u003e\n\u003cp\u003e동일한 화면을 구현할 일이 없어 \u0026#39;나중에 필요할 때 해보지 뭐\u0026#39;라며 넘겼었는데 며칠 전 문득 포스팅을 하면서 한번 뜯어 봐야겠다는 생각이 들었다.\u003c/p\u003e\n\u003cp\u003e대부분의 Apple 제품 소개 페이지에서 볼 수 있는 애니메이션으로 특별히 샘플 이미지나 영상을 첨부하지 않아도 어떤 것인지 기억 할 수 있으리라 생각한다.\u003c/p\u003e\n\u003cp\u003e간단히 말로 풀어 정리하면... 사용자가 스크롤을 내리거나 올리는 것을 통해 이미지의 프레임을 앞/뒤로 넘기고 프레임이 넘어감에 따라 이어지는 영상과 같은 효과를 내는 것이 \u003ccode\u003eScroll Sequence Animation\u003c/code\u003e이다.\u003c/p\u003e\n\u003ch2 id=\"how-to-implement\"\u003eHow to implement\u003c/h2\u003e\n\u003cp\u003e그럼 내친김에 한번 만들어 봐야겠다.\u003c/p\u003e\n\u003cp\u003e우선 \u003ccode\u003eScroll Sequence Animation\u003c/code\u003e을 구현하기 위해 메커니즘을 정리하고 시작한다.\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e고정된 포지션에 이미지가 노출된다.\u003c/li\u003e\n\u003cli\u003e노출된 이미지는 스크롤을 움직이더라도 처음 포지션을 그대로 유지한다.\u003c/li\u003e\n\u003cli\u003e스크롤이 내려가거나 올라감에 따라 노출된 이미지가 변경된다.\u003cul\u003e\n\u003cli\u003e스크롤 가능한 영역의 높이와 전체 이미지수를 통해 스크롤 대비 프레임 인덱스를 계산하고 이를 기준으로 이미지를 변경한다\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e스크롤 가능한 범위를 넘어설 경우 이미지는 더이상 고정되지 않고 화면에서 사라진다\u003cul\u003e\n\u003cli\u003e이렇게 하지 않을 경우 페이지의 다음 내용을 출력할 수 없을 것이다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e이제 하나씩 순서대로 구현해 보자.\u003c/p\u003e\n\u003ch3 id=\"dom-구조\"\u003eDOM 구조\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-html\"\u003e\u0026lt;!DOCTYPE html\u0026gt;\n\u0026lt;html lang=\u0026quot;ko\u0026quot;\u0026gt;\n  \u0026lt;head\u0026gt;\n    \u0026lt;meta charset=\u0026quot;UTF-8\u0026quot; /\u0026gt;\n    \u0026lt;meta http-equiv=\u0026quot;X-UA-Compatible\u0026quot; content=\u0026quot;IE=edge\u0026quot; /\u0026gt;\n    \u0026lt;meta name=\u0026quot;viewport\u0026quot; content=\u0026quot;width=device-width, initial-scale=1.0\u0026quot; /\u0026gt;\n    \u0026lt;title\u0026gt;Scroll Sequence Animation\u0026lt;/title\u0026gt;\n\n    \u0026lt;style\u0026gt;\n      html,\n      body {\n        margin: 0px;\n        width: 100%;\n        height: 100%;\n      }\n\n      main {\n        height: 100%;\n        overflow: auto;\n      }\n\n      .boundary {\n        margin: 0px auto;\n        height: 2400px;\n      }\n\n      .boundary.begin {\n        background: rgb(2, 0, 36);\n        background: linear-gradient(\n          180deg,\n          rgba(2, 0, 36, 1) 0%,\n          rgba(250, 32, 74, 1) 50%,\n          rgba(250, 32, 74, 1) 100%\n        );\n      }\n\n      .boundary.end {\n        background: rgb(2, 0, 36);\n        background: linear-gradient(\n          180deg,\n          rgba(250, 32, 74, 1) 0%,\n          rgba(250, 32, 74, 1) 50%,\n          rgba(2, 0, 36, 1) 100%\n        );\n      }\n\n      #wrapper {\n        margin: 0px auto;\n        height: 3600px;\n        background-color: rgba(250, 32, 74, 1);\n      }\n    \u0026lt;/style\u0026gt;\n\n    \u0026lt;script defer src=\u0026quot;./scroll-sequence.js\u0026quot;\u0026gt;\u0026lt;/script\u0026gt;\n  \u0026lt;/head\u0026gt;\n\n  \u0026lt;body\u0026gt;\n    \u0026lt;main\u0026gt;\n      \u0026lt;div class=\u0026quot;boundary begin\u0026quot;\u0026gt;\u0026lt;/div\u0026gt;\n      \u0026lt;div id=\u0026quot;wrapper\u0026quot;\u0026gt;\u0026lt;/div\u0026gt;\n      \u0026lt;div class=\u0026quot;boundary end\u0026quot;\u0026gt;\u0026lt;/div\u0026gt;\n    \u0026lt;/main\u0026gt;\n  \u0026lt;/body\u0026gt;\n\u0026lt;/html\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003e\u0026lt;main\u0026gt;\u003c/code\u003e 스크롤이 가능한 전체 영역\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e\u0026lt;div class=\u0026quot;boundary begin\u0026quot;\u0026gt;\u0026lt;/div\u0026gt;\u003c/code\u003e 이미지에 앞서 나타나는 컨텐츠 영역\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e\u0026lt;div id=\u0026quot;wrapper\u0026quot;\u0026gt;\u0026lt;/div\u0026gt;\u003c/code\u003e 이미지가 출력되는 영역으로 해당 영역 내부에서 \u003ccode\u003e\u0026lt;canvas\u0026gt;\u003c/code\u003e가 생성됨\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e\u0026lt;div class=\u0026quot;boundary end\u0026quot;\u0026gt;\u0026lt;/div\u0026gt;\u003c/code\u003e 이미지에 이어 나타나는 컨텐츠 영역\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"canvas-element-생성\"\u003eCanvas element 생성\u003c/h3\u003e\n\u003cp\u003e이제 \u003ccode\u003eJavaScript\u003c/code\u003e 파일 (\u003ccode\u003escroll-sequence.js\u003c/code\u003e)을 생성한다.\n\u003ccode\u003e\u0026lt;div id=\u0026quot;wrapper\u0026quot;\u0026gt;\u0026lt;/div\u0026gt;\u003c/code\u003e 아래에 \u003ccode\u003ecanvas\u003c/code\u003e 엘리먼트를 생성해서 \u003ccode\u003eappend\u003c/code\u003e 한다.\n\u003ccode\u003ecanvas\u003c/code\u003e의 너비와 높이는 \u003ccode\u003ecss\u003c/code\u003e를 통해 설정하지 않고 \u003ccode\u003ecanvas\u003c/code\u003e tag의 프로퍼티를 통해 결정한다.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003ccode\u003ecss\u003c/code\u003e를 통해 너비와 높이를 설정 할 경우 이미지의 해상도가 깨지기 때문에 반드시 프로퍼티를 통해 설정해야함\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e\u003ccode\u003e\u0026lt;script\u0026gt;\u0026lt;/script\u0026gt;\u003c/code\u003e 태그에 \u003ccode\u003edefer\u003c/code\u003e 어트리뷰트를 설정 했기 때문에 \u003ccode\u003e\u0026lt;div id=\u0026quot;wrapper\u0026quot;\u0026gt;\u0026lt;/div\u0026gt;\u003c/code\u003e의 너비와 높이를 추출 할 수 있을 때 \u003ccode\u003escript\u003c/code\u003e가 실행된다.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003ccode\u003easync\u003c/code\u003e \u0026amp; \u003ccode\u003edefer\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003easync\u003c/p\u003e\n\u003cp\u003easync 어트리뷰트를 가지고 있는 script 태그는 DOM parsing을 블록하지 않고 스크립트를 다운로드 받게된다.\u003c/p\u003e\n\u003cp\u003e스크립트의 다운로드가 완료되는 즉시 실행된다.\u003c/p\u003e\n\u003cp\u003edefer\u003c/p\u003e\n\u003cp\u003edefer 어트리뷰트를 가지고 있는 script 태그 또한 DOM parsing을 블록하지 않고 스크립트를 다운받는다.\u003c/p\u003e\n\u003cp\u003edefer script는 DOMContentLoaded 이벤트 이후에 실행되게 된다.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e\u003ccode\u003e\u0026lt;div id=\u0026quot;wrapper\u0026quot;\u0026gt;\u0026lt;/div\u0026gt;\u003c/code\u003e의 현재 너비를 추출하여 \u003ccode\u003ecanvas\u003c/code\u003e를 생성한다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003econst wrapper = document.querySelector(\u0026#39;#wrapper\u0026#39;)\nconst canvas = document.createElement(\u0026#39;canvas\u0026#39;)\nconst context = canvas.getContext(\u0026#39;2d\u0026#39;) // get 2D context\ncanvas.width = wrapper.offsetWidth\ncanvas.height = (canvas.width / 3) * 2 // 예제에서 사용할 이미지가 3:2 비율을 갖고 있기 때문에 `canvas`의 높이를 이와 같이 계산함\n\ncanvas.style.position = \u0026#39;sticky\u0026#39; // wrapper 영역 내에서 상대 위치를 유지하기 위한 position\ncanvas.style.top = \u0026#39;50%\u0026#39; // 이미지가 정중앙에 표시되도록 하기 위한 style\ncanvas.style.transform = \u0026#39;translateY(-50%)\u0026#39; // 이미지가 정중앙에 표시되도록 하기 위한 style\n\nwrapper.append(canvas)\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"canvas-api를-통한-이미지-그리기\"\u003eCanvas API를 통한 이미지 그리기\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003eCanvas API\u003c/code\u003e는 \u003ccode\u003eJavaScript\u003c/code\u003e와 \u003ccode\u003eHTML canvas\u003c/code\u003e 엘리먼트를 통해 브라우저 상에서 그래픽을 그리기 위한 수단으로 제공된다. 자세한 내용은 \u003ca href=\"https://developer.mozilla.org/ko/docs/Web/API/Canvas_API\"\u003e이곳의 문서\u003c/a\u003e를 통해 확인 할 수 있다.\u003c/p\u003e\n\u003cp\u003e이번에 사용할 \u003ccode\u003ecanvas api\u003c/code\u003e는 2D 컨텍스트의 \u003ccode\u003ecanvas\u003c/code\u003e에 그림을 그려 넣는 \u003ccode\u003e(drawImage)\u003c/code\u003e 것으로 충분하다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003econst img = new Image()\n\nimg.onload = () =\u0026gt; {\n  context.drawImage(img, 0, 0, canvas.width, canvas.height)\n}\n\nimg.src = \u0026#39;PATH/TO/IMAGE.img\u0026#39;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e위의 \u003ccode\u003esyntax\u003c/code\u003e를 통해 이미지를 로드하고 \u003ccode\u003ecanvas\u003c/code\u003e 엘리먼트의 컨택스트를 통해 내부에 이미지를 그려낼 수 있다.\u003c/p\u003e\n\u003ch3 id=\"scroll-이벤트-등록-및-현재-프레임-계산\"\u003eScroll 이벤트 등록 및 현재 프레임 계산\u003c/h3\u003e\n\u003cp\u003e스크롤 가능한 영역 \u003ccode\u003e\u0026lt;main\u0026gt;\u003c/code\u003e 엘리먼트에 \u003ccode\u003escroll\u003c/code\u003e 이벤트 리스너를 등록한다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003econst main = document.querySelector(\u0026#39;main\u0026#39;)\nmain.onscroll = onScrollHandler\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003eonScrollHandler\u003c/code\u003e 함수에서는 \u003ccode\u003e\u0026lt;main\u0026gt;\u003c/code\u003e 엘리먼트의 \u003ccode\u003escrollTop\u003c/code\u003e과 \u003ccode\u003estartScrollY\u003c/code\u003e 그리고 \u003ccode\u003estandardHeight\u003c/code\u003e를 통해 현재 출력돼야 하는 이미지의 index를 계산한다.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003estartScrollY\u003c/p\u003e\n\u003cp\u003e스크롤에 의해 이미지 프레임을 증가/감소시킬 최소한의 y축 높이를 갖고 있는 변수\u003c/p\u003e\n\u003cp\u003estandardHeight\u003c/p\u003e\n\u003cp\u003e프레임을 1 증가/감소시키기 위한 최소 scroll 높이로 canvas의 높이를 총 프레임수 (이미지 수)로 나눈 것과 같다\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003econst computeStartScrollY = () =\u0026gt; {\n  let prevElementSibling = wrapper.previousElementSibling\n  let height = 0\n  while (prevElementSibling) {\n    height += prevElementSibling.offsetHeight\n    prevElementSibling = prevElementSibling.previousElementSibling\n  }\n\n  return height\n}\n\nconst startScrollY = computeStartScrollY()\nconst standardHeight = canvas.height / imageSources.length\n\nconst currentFrameIndex = () =\u0026gt; {\n  const index = Math.floor((main.scrollTop - startScrollY) / standardHeight)\n  if (index \u0026lt; 0) return 0 // index가 음수일 경우 스크롤이 아직 startScrollY에 도달하지 못한 경우 =\u0026gt; 첫번째 인덱스를 리턴\n  if (!imageSources[index]) return imageSources.length - 1 // index를 통해 imageSource를 찾지 못하는경우 =\u0026gt; 마지막 인덱스를 리턴\n\n  return index\n}\n\nconst render = () =\u0026gt; {\n  const frameIndex = currentFrameIndex()\n  const image = new Image()\n  image.src = imageSources[frameIndex]\n  context.drawImage(image, 0, 0, canvas.width, canvas.height)\n}\n\nconst onScrollHandler = () =\u0026gt; {\n  requestAnimationFrame(render)\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003ccode\u003erequestAnimationFrame\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003erequestAnimationFrame\u003c/code\u003e의 콜백으로 등록된 함수는 Browser가 리페인트를 수행하기전에 호출된다.\n\u003ccode\u003erequestAnimationFrame\u003c/code\u003e에 콜백을 등록하는 것을 통해 \u003ccode\u003ecanvas\u003c/code\u003e의 이미지를 안정적으로 갱신 할 수 있다\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003erequestAnimationFrame\u003c/code\u003e은 성능 및 베터리 수명을 고려하여 \u003ccode\u003ehidden\u003c/code\u003e 엘리먼트 또는 background 탭에서는 실행이 중단된다.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch3 id=\"이미지-불러오기와-최적화\"\u003e이미지 불러오기와 최적화\u003c/h3\u003e\n\u003cp\u003e이미지는 \u003ccode\u003eimagesSources\u003c/code\u003e라는 배열에 이미지를 참조하기 위한 경로를 저장하도록 한다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003econst imageSources = Array(121)\n  .fill(\u0026#39;\u0026#39;)\n  .map((_, idx) =\u0026gt; `./images/${String(idx + 1).padStart(3, \u0026#39;0\u0026#39;)}.png`)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cblockquote\u003e\n\u003cp\u003e각 프레임에 해당하는 이미지는 일종의 규칙을 갖게 하여 코드를 통해 경로를 저장하도록 함\u003c/p\u003e\n\u003cp\u003e예제에서는 [001 ~ 121].png 까지 이미지 파일을 각 프레임으로 사용\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e이미지를 변수에 담았으니 앞서 정의한 \u003ccode\u003erender\u003c/code\u003e 함수를 통해 \u003ccode\u003ecanvas\u003c/code\u003e에 이미지를 그려주면 되는데\n프레임이 변경될 때마다 이미지를 다운받고 그리게 되면 이미지가 모두 다운로드 되기 전에 이미 다음 프레임을 보여줘야 할 때가 되었을 가능성이 크다.\u003c/p\u003e\n\u003cp\u003e이미지를 \u003ccode\u003epreloading\u003c/code\u003e하여 사전에 이미지를 다운 받아두고 \u003ccode\u003erender\u003c/code\u003e가 호출 될 때에는 \u003ccode\u003ecache\u003c/code\u003e된 이미지를 그리도록 해야한다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003econst preloadImages = () =\u0026gt; {\n  imageSources.forEach((imgSrc) =\u0026gt; {\n    const img = new Image()\n    img.src = imgSrc\n  })\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"초기-이미지-그리기\"\u003e초기 이미지 그리기\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003ecanvas\u003c/code\u003e에 이미지가 채워지는 시점은 \u003ccode\u003escroll\u003c/code\u003e 이벤트가 발생 했을 때다. 만약 화면이 로딩되고 스크롤을 움직이지 않는다면 \u003ccode\u003ecanvas\u003c/code\u003e는 비어 있는 상태일 것이다.\n명시적으로 첫번째 이미지를 그리도록 하여 비어 있는 \u003ccode\u003ecanvas\u003c/code\u003e가 노출 되지 않도록 한다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003econst initFirstFrame = () =\u0026gt; {\n  const image = new Image()\n  image.src = imageSources[0]\n  image.onload = () =\u0026gt;\n    context.drawImage(image, 0, 0, canvas.width, canvas.height)\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"그-밖의-최적화\"\u003e그 밖의 최적화\u003c/h3\u003e\n\u003cp\u003e아무래도 여러개의 이미지 파일을 다운받아야 하기 때문에 UX 및 성능상의 이슈를 고려해야한다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e네트워크 속도가 좋지 못하여 빠른 속도로 이미지를 다운 받지 못하는 환경\u003c/li\u003e\n\u003cli\u003e데이터 소모에 대해 거부감을 갖고 있는 사용자\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e등의 경우에 따라 에니메이션 효과를 적용하는 것이 아닌 대표 이미지만 나타내도록 하는 것이 방법이 될 것 같다.\u003c/p\u003e\n"},"__N_SSG":true},"page":"/[title]","query":{"title":"scroll-sequence-animation"},"buildId":"Fih1bmwo9sXnBcCqz_UPk","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>