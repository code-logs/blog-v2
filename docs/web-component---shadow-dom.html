<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="utf-8" />
    <link rel="canonical" href="https://code-logs.github.io/web-component---shadow-dom" />
    <link rel="apple-touch-icon" href="/icons/icon-192x-192.png" />
    <link rel="manifest" href="/manifest.json" />
    <meta name="theme-color" content="#fff" />
    <meta property="og:type" content="website" />
    <meta property="og:site_name" content="Code Logs" />
    <meta name="author" content="Jay Lee" />
    <meta name="viewport" content="width=device-width, user-scalable=no" />
    <meta
      name="keyword"
      content="Shadow DOM, custom element, encapsulation, shadow, shadow tree, web component, 쉐도우, 쉐도우 돔, 쉐도우 트리, 웹 컴포넌트, 은닉화, 커스텀 엘리먼트, Web component - Shadow DOM, Web component의 핵심인 encapsulation은 어떻게 이루어질까?
Shadow DOM의 이해, web-component"
    />
    <meta
      name="description"
      content="Code Logs Web component - Shadow DOM - Web component의 핵심인 encapsulation은 어떻게 이루어질까?
Shadow DOM의 이해 | web-component, Shadow DOM, custom element, encapsulation, shadow, shadow tree, web component, 쉐도우, 쉐도우 돔, 쉐도우 트리, 웹 컴포넌트, 은닉화, 커스텀 엘리먼트"
    />
    <meta
      property="og:description"
      content="Code Logs Web component - Shadow DOM - Web component의 핵심인 encapsulation은 어떻게 이루어질까?
Shadow DOM의 이해 | web-component, Shadow DOM, custom element, encapsulation, shadow, shadow tree, web component, 쉐도우, 쉐도우 돔, 쉐도우 트리, 웹 컴포넌트, 은닉화, 커스텀 엘리먼트"
    />
    <meta property="og:title" content="Web component - Shadow DOM | Code Logs" />
    <meta property="og:url" content="https://code-logs.github.io/web-component---shadow-dom" />
    <meta property="og:image" content="/assets/images/ab751eb302db9d348765b3134068a6aa" />
    <title>Web component - Shadow DOM | Code Logs</title>
    <meta name="next-head-count" content="16" />
    <link rel="preload" href="/_next/static/css/83895298d26eeaa2.css" as="style" />
    <link rel="stylesheet" href="/_next/static/css/83895298d26eeaa2.css" data-n-g="" />
    <link rel="preload" href="/_next/static/css/6b0df19ac3d4a989.css" as="style" />
    <link rel="stylesheet" href="/_next/static/css/6b0df19ac3d4a989.css" data-n-p="" />
    <noscript data-n-css=""></noscript>
    <script defer="" nomodule="" src="/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script>
    <script src="/_next/static/chunks/webpack-2e51481b1d484a05.js" defer=""></script>
    <script src="/_next/static/chunks/framework-5f4595e5518b5600.js" defer=""></script>
    <script src="/_next/static/chunks/main-a4d9e436b9a532ca.js" defer=""></script>
    <script src="/_next/static/chunks/pages/_app-179eda94ba87778a.js" defer=""></script>
    <script src="/_next/static/chunks/294-6603e2d70ff7953e.js" defer=""></script>
    <script src="/_next/static/chunks/117-d35cede103fa43e1.js" defer=""></script>
    <script src="/_next/static/chunks/pages/%5Btitle%5D-1adcf6ed6b9cad08.js" defer=""></script>
    <script src="/_next/static/AZTFjl0iXmv1GfgA-IOvJ/_buildManifest.js" defer=""></script>
    <script src="/_next/static/AZTFjl0iXmv1GfgA-IOvJ/_ssgManifest.js" defer=""></script>
    <script src="/_next/static/AZTFjl0iXmv1GfgA-IOvJ/_middlewareManifest.js" defer=""></script>
  </head>
  <body>
    <div id="__next" data-reactroot="">
      <header class="Header_header__RW35m">
        <span class="Header_title__GPS8b">Code Logs</span>
        <ul class="Header_socialIcons__CBf_s">
          <li>
            <a href="https://github.com/possible819" target="_blank" rel="noreferrer" aria-label="My Github"
              ><style data-emotion="css vubbuv">
                .css-vubbuv {
                  -webkit-user-select: none;
                  -moz-user-select: none;
                  -ms-user-select: none;
                  user-select: none;
                  width: 1em;
                  height: 1em;
                  display: inline-block;
                  fill: currentColor;
                  -webkit-flex-shrink: 0;
                  -ms-flex-negative: 0;
                  flex-shrink: 0;
                  -webkit-transition: fill 200ms cubic-bezier(0.4, 0, 0.2, 1) 0ms;
                  transition: fill 200ms cubic-bezier(0.4, 0, 0.2, 1) 0ms;
                  font-size: 1.5rem;
                }</style
              ><svg
                class="MuiSvgIcon-root MuiSvgIcon-fontSizeMedium css-vubbuv"
                focusable="false"
                aria-hidden="true"
                viewBox="0 0 24 24"
                data-testid="GitHubIcon"
              >
                <path
                  d="M12 1.27a11 11 0 00-3.48 21.46c.55.09.73-.28.73-.55v-1.84c-3.03.64-3.67-1.46-3.67-1.46-.55-1.29-1.28-1.65-1.28-1.65-.92-.65.1-.65.1-.65 1.1 0 1.73 1.1 1.73 1.1.92 1.65 2.57 1.2 3.21.92a2 2 0 01.64-1.47c-2.47-.27-5.04-1.19-5.04-5.5 0-1.1.46-2.1 1.2-2.84a3.76 3.76 0 010-2.93s.91-.28 3.11 1.1c1.8-.49 3.7-.49 5.5 0 2.1-1.38 3.02-1.1 3.02-1.1a3.76 3.76 0 010 2.93c.83.74 1.2 1.74 1.2 2.94 0 4.21-2.57 5.13-5.04 5.4.45.37.82.92.82 2.02v3.03c0 .27.1.64.73.55A11 11 0 0012 1.27"
                ></path></svg
            ></a>
          </li>
        </ul>
        <nav class="NavBar_navBar__akqA3">
          <ul>
            <li class="clickable"><a href="/" class="MarkedAnchor_anchor__QCmkL">Home</a></li>
            <li class="clickable"><a href="/posts/1" class="MarkedAnchor_anchor__QCmkL">Posts</a></li>
            <li class="clickable"><a href="/about" class="MarkedAnchor_anchor__QCmkL">About</a></li>
          </ul>
        </nav>
      </header>
      <main>
        <article class="PostDetail_container__Ma_26">
          <p class="PostDetail_publishedAt__7GOQm"><span></span></p>
          <section class="PostDetail_thumbnailWrapper__oALCg">
            <img
              src="/assets/images/ab751eb302db9d348765b3134068a6aa"
              alt="Web component의 핵심인 encapsulation은 어떻게 이루어질까?
Shadow DOM의 이해"
            />
          </section>
          <section>
            <h1>Web component - Shadow DOM</h1>
            <p class="PostDetail_description__l6wHC">Web component의 핵심인 encapsulation은 어떻게 이루어질까? Shadow DOM의 이해</p>
          </section>
          <section>
            <h2 id="table-of-contents">Table of contents</h2>
            <ol>
              <li><a href="#shadow-dom">Shadow DOM</a></li>
              <li>
                <a href="#document-tree%EC%97%90-shadow-root-%EC%82%BD%EC%9E%85%ED%95%98%EA%B8%B0">Document tree에 Shadow root 삽입하기</a>
                <ol>
                  <li><a href="#open-mode-shadow-root">Open mode shadow root</a></li>
                  <li><a href="#closed-mode-shadow-root">Closed mode shadow root</a></li>
                  <li><a href="#delegatesfocus%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-focus-%EC%A7%80%EC%A0%95">delegatesFocus를 이용한 focus 지정</a></li>
                </ol>
              </li>
              <li>
                <a href="#composed-%EC%86%8D%EC%84%B1%EC%9D%84-%EC%9D%B4%EC%9A%A9%ED%95%9C-custom-event-%EC%A0%84%ED%8C%8C"
                  >Composed 속성을 이용한 Custom Event 전파</a
                >
              </li>
            </ol>
            <h2 id="shadow-dom">Shadow DOM</h2>
            <p>
              웹 컴포넌트로 제작된 커스텀 엘리먼트는 <code>Shadow DOM</code> 영역에 존재하며 외부의 스타일 정의로 부터 독립적으로 동작할 수 있도록 돕고 컴포넌트
              내부에서 발생하는 커스텀 이벤트의 버블링이 <code>Shadow DOM</code> 바깥의 영역까지 전파되어 발생 할 수 있는 side effect를 방지 할 수 있도록
              돕는다.
            </p>
            <p>이렇게 <code>encapsulation</code> 처리가된 커스텀 엘리먼트는 어떤 DOM Tree에 존재하더라도 항상 동일한 생김새와 기능을 보장 할 수 있다.</p>
            <p><code>Shadow DOM</code>은 구조적으로 아래의 용어로 세분화 할 수 있다.</p>
            <ul>
              <li>
                Shadow root
                <ul>
                  <li><code>Shadow root</code>는 <code>Shadow tree</code>의 관점에서 바라본 <code>root</code> 노드를 의미한다.</li>
                </ul>
              </li>
              <li>
                Shadow host
                <ul>
                  <li><code>Shadow host</code>는 <code>Document tree</code>의 관점에서 바라본 <code>Shadow tree</code>의 <code>root</code> 노드를 의미한다.</li>
                </ul>
              </li>
              <li>
                Shadow tree
                <ul>
                  <li>
                    <code>Shadow tree</code>는 <code>Document tree</code>와 상응하는 개념으로 <code>Shadow root</code>를 포함한 모든 하위 노드의 트리를
                    의미한다.
                  </li>
                </ul>
              </li>
              <li>
                Shadow boundary
                <ul>
                  <li><code>Shadow boundary</code>는 <code>Shadow DOM</code>과 <code>Document tree</code>의 경계를 의미한다.</li>
                </ul>
              </li>
            </ul>
            <h2 id="document-tree에-shadow-root-삽입하기">Document tree에 Shadow root 삽입하기</h2>
            <p><code>Shadow root</code>를 생성하기 위해 <code>Element</code>의 <code>attachShadow</code> 메서드를 사용한다.</p>
            <pre><code class="language-javascript">const container = document.querySelector(&#39;div#container&#39;)
container.attachShadow({ mode: &#39;open&#39; })
</code></pre>
            <blockquote>
              <p>모든 엘리먼트에 Shadow DOM을 삽입 할 수 있을까?</p>
              <p>
                보안상의 이유로 일부 엘리먼트에는 <code>shadow dom</code>을 삽입 할 수 없다. (ex. <code>anchor</code>) <code>shadow dom</code>을 삽입 할 수 있는
                엘리먼트는 커스텀 엘리먼트와 <code>article</code>, <code>aside</code>, <code>blockquote</code>, <code>body</code>, <code>div</code>,
                <code>footer</code>, <code>h1~h6</code>, <code>header</code>, <code>main</code>, <code>nav</code>, <code>p</code>, <code>section</code>,
                <code>span</code>이 있다.
              </p>
            </blockquote>
            <p><code>attachShadow</code> 메서드는 <code>option</code>을 객체 형태의 매개변수로 전달 받는다. <code>option</code> 객체는 아래의 형식을 갖는다</p>
            <pre><code class="language-typescript">interface ShadowRootInit {
  mode: &#39;closed&#39; | &#39;open&#39;
  delegatesFocus?: boolean
}
</code></pre>
            <h3 id="open-mode-shadow-root">Open mode shadow root</h3>
            <p>
              <code>shadow dom</code>이 삽입 될 때 <code>mode</code> 프로퍼티를 <code>open</code>으로 설정하면 <code>JavaScript</code>를 통해
              <code>shadowRoot</code>에 접근 할 수 있도록 허용한다. <code>mode</code> 프로퍼티는 앞서 이야기한 캡슐화와 관계 없는 옵션으로
              <code>open</code> 모드를 사용하더라도 캡슐화는 여전히 유효하다.
            </p>
            <pre><code class="language-javascript">document.body.attachShadow({ mode: &#39;open&#39; })
console.log(document.body.shadowRoot) // #shadow-root (open)
</code></pre>
            <h3 id="closed-mode-shadow-root">Closed mode shadow root</h3>
            <p>
              <code>shadow dom</code>이 삽입 될 때 <code>mode</code> 프로퍼티를 <code>closed</code>로 설정하면 <code>JavaScript</code>를 통해
              <code>shadowRoot</code>에 접근 할 수 없게된다.
            </p>
            <pre><code class="language-javascript">document.body.attachShadow({ mode: &#39;closed&#39; })
console.log(document.body.shadowRoot) // null
</code></pre>
            <blockquote>
              <p>
                Closed 모드를 사용하는 것은 엔드유저가 할 수 있는 일에 상당한 제약을 준다. 더불어 <code>closed</code> 모드를 사용하더라도
                <code>shadow dom</code>에 우회적으로 접근할 수 있다. 특별한 이유가 없다면 <code>open</code> 모드를 사용하는 것이 좋다.
              </p>
            </blockquote>
            <blockquote>
              <p>Closed 모드인 shadow dom에 접근하는 방법</p>
              <pre><code class="language-javascript">Element.prototype._attachShadow = Element.prototype.attachShadow
Element.prototype.attachShadow = function () {
  return this._attachShadow({ mode: &#39;open&#39; })
}
</code></pre>
            </blockquote>
            <h3 id="delegatesfocus를-이용한-focus-지정">delegatesFocus를 이용한 focus 지정</h3>
            <p>
              <code>shadow dom</code>은 또 다른 <code>shadow dom</code> 아래에 삽입 될 수 있다. 중첩된 <code>shadow dom</code> 중 상위 요소를 클릭 했을 때
              focus가 대체될 대상 <code>shadow dom</code>을 생성하기 위해 <code>delegatesFocus</code> 속성을 사용한다.
            </p>
            <pre><code class="language-javascript">document.body.attachShadow({ mode: &#39;open&#39; })

const shadowRoot = document.body.shadowRoot
shadowRoot.innerHTML = `
  &lt;style&gt;
    div {
      padding: 20px;
      background-color: tomato;
    }
  &lt;/style&gt;
  &lt;div&gt;&lt;/div&gt;
`
const div = shadowRoot.querySelector(&#39;div&#39;)
const focusableInput = div.attachShadow({
  mode: &#39;open&#39;,
  delegatesFocus: true,
})
focusableInput.innerHTML = `&lt;input placeholder=&quot;focusable&quot; /&gt;`
</code></pre>
            <p>
              위와 같은 형식으로 <code>DOM</code>과 <code>shadow DOM</code>이 구성되어 있다면 <code>input</code> 엘리먼트를 감싸고 있는 <code>div</code>의 여백
              영역을 클릭하면 <code>input</code>으로 포커스가 이동하게 된다.
            </p>
            <h2 id="composed-속성을-이용한-custom-event-전파">Composed 속성을 이용한 Custom Event 전파</h2>
            <p>
              커스텀 엘리먼트를 만들게되면 <code>Event</code>를 통해 외부 요소와 커뮤니케이션 해야하는 일들이 빈번히 발생한다. <code>click</code>,
              <code>touch</code>, <code>mouseover</code>와 같은 모든 UI 이벤트는 기본적으로 <code>composed</code> 속성이 설정되어 있고, 다시 말해
              <code>shadow boundary</code>를 넘어 외부 <code>DOM</code> 요소로 이벤트가 전파된다. 하지만 <code>Custom Event</code>를 사용할 경우 기본적으로
              <code>composed</code>가 <code>false</code>로 설정되어 있다. 다시 말해 <code>shadow boundary</code> 내부에서 생성된 <code>Custom Event</code>는
              기본적으로 외부에서 이벤트를 위임할 수 없다는 의미가 된다.
            </p>
            <p>
              예측할 수 없는 커스텀 엘리먼트의 이벤트 전파로 인해 발생할 수 있는 부작용을 차단하기 위함이지만 경우에 따라 버블링을 통한 이벤트 전파 및 위임이
              필요하기도 하다.
            </p>
            <pre><code class="language-javascript">shadowElement.dispatchEvent(new CustomEvent(&#39;notify&#39;, {
  bubbles: true,
  composed: true
})
</code></pre>
            <p>
              <code>composed</code> 속성은 반드시 <code>bubbles</code> 속성이 <code>true</code>일 때 의도와 같이 설정되고 마침내 상위 엘리먼트에서 하위의
              <code>shadow dom</code>에서 발생한 custom event를 전파 받을 수 있게된다.
            </p>
            <blockquote>
              <p>Event capturing과 shadow DOM</p>
              <p>
                Event capturing은 shadow DOM에서 상위 엘리멘트로의 이벤트 전파가 아니기 때문에 <code>shadow DOM</code>의 존재 유무와 관계 없이 일반적인 형태로
                흐른다.
              </p>
            </blockquote>
          </section>
        </article>
        <section class="MainAdsBanner_container__YWe5C">
          <ins
            class="adsbygoogle"
            style="display: block"
            data-ad-client="ca-pub-7134579063537339"
            data-ad-slot="5391522351"
            data-ad-format="auto"
            data-full-width-responsive="true"
          ></ins>
        </section>
        <section class="PostDetail_relatedPosting__VlXXV">
          <h2>연관 포스팅</h2>
          <ol class="PostSeriesLink_container__jtRUh">
            <li>
              <h3><span>이전글 - </span>Web component - custom element</h3>
              <a href="/web-component---custom-element">웹 컴포넌트로 만드는 나만의 custom element</a>
            </li>
          </ol>
        </section>
        <section class="PostDetail_categoryGroup___S2ib">
          <h2>카테고리 더보기</h2>
          <ul class="CategoryPostGroup_container__MDFUe"></ul>
        </section>
        <section class="PostDetail_references__EU_hH">
          <h2>참고</h2>
          <ul class="PostDetail_references__EU_hH">
            <li>
              <a href="https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FAPI%2FEvent%2Fcomposed" target="_blank" rel="noreferrer">MDN - Composed</a>
            </li>
            <li>
              <a href="https%3A%2F%2Fdeveloper.mozilla.org%2Fko%2Fdocs%2FWeb%2FWeb_Components%2FUsing_shadow_DOM" target="_blank" rel="noreferrer"
                >MDN - Using shadow DOM</a
              >
            </li>
          </ul>
        </section>
        <section class="PostDetail_utterances__jZeOm">
          <h2>댓글</h2>
          <div class="Utterrances_utteranceContainer__qopWy"></div>
        </section>
      </main>
      <aside></aside>
      <footer class="Footer_footer__GLL0J"><p>ⓒ 2021. Jay Lee all rights reserved.</p></footer>
    </div>
    <script id="__NEXT_DATA__" type="application/json">
      {
        "props": {
          "pageProps": {
            "post": {
              "title": "Web component - Shadow DOM",
              "description": "Web component의 핵심인 encapsulation은 어떻게 이루어질까?\nShadow DOM의 이해",
              "fileName": "web-component-web-component---shadow-dom.md",
              "category": "web-component",
              "published": true,
              "publishedAt": "2022-08-10",
              "thumbnailName": "ab751eb302db9d348765b3134068a6aa",
              "tags": [
                "Shadow DOM",
                "custom element",
                "encapsulation",
                "shadow",
                "shadow tree",
                "web component",
                "쉐도우",
                "쉐도우 돔",
                "쉐도우 트리",
                "웹 컴포넌트",
                "은닉화",
                "커스텀 엘리먼트"
              ],
              "references": [
                { "title": "MDN - Composed", "url": "https://developer.mozilla.org/en-US/docs/Web/API/Event/composed" },
                { "title": "MDN - Using shadow DOM", "url": "https://developer.mozilla.org/ko/docs/Web/Web_Components/Using_shadow_DOM" }
              ],
              "series": { "prevPostTitle": "Web component - custom element" },
              "order": 22
            },
            "content": "\u003ch2 id=\"table-of-contents\"\u003eTable of contents\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003e\u003ca href=\"#shadow-dom\"\u003eShadow DOM\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#document-tree%EC%97%90-shadow-root-%EC%82%BD%EC%9E%85%ED%95%98%EA%B8%B0\"\u003eDocument tree에 Shadow root 삽입하기\u003c/a\u003e\u003col\u003e\n\u003cli\u003e\u003ca href=\"#open-mode-shadow-root\"\u003eOpen mode shadow root\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#closed-mode-shadow-root\"\u003eClosed mode shadow root\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#delegatesfocus%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-focus-%EC%A7%80%EC%A0%95\"\u003edelegatesFocus를 이용한 focus 지정\u003c/a\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#composed-%EC%86%8D%EC%84%B1%EC%9D%84-%EC%9D%B4%EC%9A%A9%ED%95%9C-custom-event-%EC%A0%84%ED%8C%8C\"\u003eComposed 속성을 이용한 Custom Event 전파\u003c/a\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2 id=\"shadow-dom\"\u003eShadow DOM\u003c/h2\u003e\n\u003cp\u003e웹 컴포넌트로 제작된 커스텀 엘리먼트는 \u003ccode\u003eShadow DOM\u003c/code\u003e 영역에 존재하며 외부의 스타일 정의로 부터 독립적으로 동작할 수 있도록 돕고 컴포넌트 내부에서 발생하는 커스텀 이벤트의 버블링이 \u003ccode\u003eShadow DOM\u003c/code\u003e 바깥의 영역까지 전파되어 발생 할 수 있는 side effect를 방지 할 수 있도록 돕는다.\u003c/p\u003e\n\u003cp\u003e이렇게 \u003ccode\u003eencapsulation\u003c/code\u003e 처리가된 커스텀 엘리먼트는 어떤 DOM Tree에 존재하더라도 항상 동일한 생김새와 기능을 보장 할 수 있다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eShadow DOM\u003c/code\u003e은 구조적으로 아래의 용어로 세분화 할 수 있다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eShadow root\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eShadow root\u003c/code\u003e는 \u003ccode\u003eShadow tree\u003c/code\u003e의 관점에서 바라본 \u003ccode\u003eroot\u003c/code\u003e 노드를 의미한다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eShadow host\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eShadow host\u003c/code\u003e는 \u003ccode\u003eDocument tree\u003c/code\u003e의 관점에서 바라본 \u003ccode\u003eShadow tree\u003c/code\u003e의 \u003ccode\u003eroot\u003c/code\u003e 노드를 의미한다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eShadow tree\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eShadow tree\u003c/code\u003e는 \u003ccode\u003eDocument tree\u003c/code\u003e와 상응하는 개념으로 \u003ccode\u003eShadow root\u003c/code\u003e를 포함한 모든 하위 노드의 트리를 의미한다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eShadow boundary\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eShadow boundary\u003c/code\u003e는 \u003ccode\u003eShadow DOM\u003c/code\u003e과 \u003ccode\u003eDocument tree\u003c/code\u003e의 경계를 의미한다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"document-tree에-shadow-root-삽입하기\"\u003eDocument tree에 Shadow root 삽입하기\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003eShadow root\u003c/code\u003e를 생성하기 위해 \u003ccode\u003eElement\u003c/code\u003e의 \u003ccode\u003eattachShadow\u003c/code\u003e 메서드를 사용한다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003econst container = document.querySelector(\u0026#39;div#container\u0026#39;)\ncontainer.attachShadow({ mode: \u0026#39;open\u0026#39; })\n\u003c/code\u003e\u003c/pre\u003e\n\u003cblockquote\u003e\n\u003cp\u003e모든 엘리먼트에 Shadow DOM을 삽입 할 수 있을까?\u003c/p\u003e\n\u003cp\u003e보안상의 이유로 일부 엘리먼트에는 \u003ccode\u003eshadow dom\u003c/code\u003e을 삽입 할 수 없다. (ex. \u003ccode\u003eanchor\u003c/code\u003e)\n\u003ccode\u003eshadow dom\u003c/code\u003e을 삽입 할 수 있는 엘리먼트는\n커스텀 엘리먼트와 \u003ccode\u003earticle\u003c/code\u003e, \u003ccode\u003easide\u003c/code\u003e, \u003ccode\u003eblockquote\u003c/code\u003e, \u003ccode\u003ebody\u003c/code\u003e, \u003ccode\u003ediv\u003c/code\u003e, \u003ccode\u003efooter\u003c/code\u003e, \u003ccode\u003eh1~h6\u003c/code\u003e, \u003ccode\u003eheader\u003c/code\u003e, \u003ccode\u003emain\u003c/code\u003e, \u003ccode\u003enav\u003c/code\u003e, \u003ccode\u003ep\u003c/code\u003e, \u003ccode\u003esection\u003c/code\u003e, \u003ccode\u003espan\u003c/code\u003e이 있다.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e\u003ccode\u003eattachShadow\u003c/code\u003e 메서드는 \u003ccode\u003eoption\u003c/code\u003e을 객체 형태의 매개변수로 전달 받는다. \u003ccode\u003eoption\u003c/code\u003e 객체는 아래의 형식을 갖는다\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-typescript\"\u003einterface ShadowRootInit {\n  mode: \u0026#39;closed\u0026#39; | \u0026#39;open\u0026#39;\n  delegatesFocus?: boolean\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"open-mode-shadow-root\"\u003eOpen mode shadow root\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003eshadow dom\u003c/code\u003e이 삽입 될 때 \u003ccode\u003emode\u003c/code\u003e 프로퍼티를 \u003ccode\u003eopen\u003c/code\u003e으로 설정하면 \u003ccode\u003eJavaScript\u003c/code\u003e를 통해 \u003ccode\u003eshadowRoot\u003c/code\u003e에 접근 할 수 있도록 허용한다.\n\u003ccode\u003emode\u003c/code\u003e 프로퍼티는 앞서 이야기한 캡슐화와 관계 없는 옵션으로 \u003ccode\u003eopen\u003c/code\u003e 모드를 사용하더라도 캡슐화는 여전히 유효하다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003edocument.body.attachShadow({ mode: \u0026#39;open\u0026#39; })\nconsole.log(document.body.shadowRoot) // #shadow-root (open)\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"closed-mode-shadow-root\"\u003eClosed mode shadow root\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003eshadow dom\u003c/code\u003e이 삽입 될 때 \u003ccode\u003emode\u003c/code\u003e 프로퍼티를 \u003ccode\u003eclosed\u003c/code\u003e로 설정하면 \u003ccode\u003eJavaScript\u003c/code\u003e를 통해 \u003ccode\u003eshadowRoot\u003c/code\u003e에 접근 할 수 없게된다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003edocument.body.attachShadow({ mode: \u0026#39;closed\u0026#39; })\nconsole.log(document.body.shadowRoot) // null\n\u003c/code\u003e\u003c/pre\u003e\n\u003cblockquote\u003e\n\u003cp\u003eClosed 모드를 사용하는 것은 엔드유저가 할 수 있는 일에 상당한 제약을 준다. 더불어 \u003ccode\u003eclosed\u003c/code\u003e 모드를 사용하더라도 \u003ccode\u003eshadow dom\u003c/code\u003e에 우회적으로 접근할 수 있다.\n특별한 이유가 없다면 \u003ccode\u003eopen\u003c/code\u003e 모드를 사용하는 것이 좋다.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cblockquote\u003e\n\u003cp\u003eClosed 모드인 shadow dom에 접근하는 방법\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003eElement.prototype._attachShadow = Element.prototype.attachShadow\nElement.prototype.attachShadow = function () {\n  return this._attachShadow({ mode: \u0026#39;open\u0026#39; })\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/blockquote\u003e\n\u003ch3 id=\"delegatesfocus를-이용한-focus-지정\"\u003edelegatesFocus를 이용한 focus 지정\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003eshadow dom\u003c/code\u003e은 또 다른 \u003ccode\u003eshadow dom\u003c/code\u003e 아래에 삽입 될 수 있다. 중첩된 \u003ccode\u003eshadow dom\u003c/code\u003e 중 상위 요소를 클릭 했을 때 focus가 대체될 대상 \u003ccode\u003eshadow dom\u003c/code\u003e을 생성하기 위해 \u003ccode\u003edelegatesFocus\u003c/code\u003e 속성을 사용한다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003edocument.body.attachShadow({ mode: \u0026#39;open\u0026#39; })\n\nconst shadowRoot = document.body.shadowRoot\nshadowRoot.innerHTML = `\n  \u0026lt;style\u0026gt;\n    div {\n      padding: 20px;\n      background-color: tomato;\n    }\n  \u0026lt;/style\u0026gt;\n  \u0026lt;div\u0026gt;\u0026lt;/div\u0026gt;\n`\nconst div = shadowRoot.querySelector(\u0026#39;div\u0026#39;)\nconst focusableInput = div.attachShadow({\n  mode: \u0026#39;open\u0026#39;,\n  delegatesFocus: true,\n})\nfocusableInput.innerHTML = `\u0026lt;input placeholder=\u0026quot;focusable\u0026quot; /\u0026gt;`\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e위와 같은 형식으로 \u003ccode\u003eDOM\u003c/code\u003e과 \u003ccode\u003eshadow DOM\u003c/code\u003e이 구성되어 있다면 \u003ccode\u003einput\u003c/code\u003e 엘리먼트를 감싸고 있는 \u003ccode\u003ediv\u003c/code\u003e의 여백 영역을 클릭하면 \u003ccode\u003einput\u003c/code\u003e으로 포커스가 이동하게 된다.\u003c/p\u003e\n\u003ch2 id=\"composed-속성을-이용한-custom-event-전파\"\u003eComposed 속성을 이용한 Custom Event 전파\u003c/h2\u003e\n\u003cp\u003e커스텀 엘리먼트를 만들게되면 \u003ccode\u003eEvent\u003c/code\u003e를 통해 외부 요소와 커뮤니케이션 해야하는 일들이 빈번히 발생한다.\n\u003ccode\u003eclick\u003c/code\u003e, \u003ccode\u003etouch\u003c/code\u003e, \u003ccode\u003emouseover\u003c/code\u003e와 같은 모든 UI 이벤트는 기본적으로 \u003ccode\u003ecomposed\u003c/code\u003e 속성이 설정되어 있고, 다시 말해 \u003ccode\u003eshadow boundary\u003c/code\u003e를 넘어 외부 \u003ccode\u003eDOM\u003c/code\u003e 요소로 이벤트가 전파된다. 하지만 \u003ccode\u003eCustom Event\u003c/code\u003e를 사용할 경우 기본적으로 \u003ccode\u003ecomposed\u003c/code\u003e가 \u003ccode\u003efalse\u003c/code\u003e로 설정되어 있다. 다시 말해 \u003ccode\u003eshadow boundary\u003c/code\u003e 내부에서 생성된 \u003ccode\u003eCustom Event\u003c/code\u003e는 기본적으로 외부에서 이벤트를 위임할 수 없다는 의미가 된다.\u003c/p\u003e\n\u003cp\u003e예측할 수 없는 커스텀 엘리먼트의 이벤트 전파로 인해 발생할 수 있는 부작용을 차단하기 위함이지만 경우에 따라 버블링을 통한 이벤트 전파 및 위임이 필요하기도 하다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003eshadowElement.dispatchEvent(new CustomEvent(\u0026#39;notify\u0026#39;, {\n  bubbles: true,\n  composed: true\n})\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003ecomposed\u003c/code\u003e 속성은 반드시 \u003ccode\u003ebubbles\u003c/code\u003e 속성이 \u003ccode\u003etrue\u003c/code\u003e일 때 의도와 같이 설정되고 마침내 상위 엘리먼트에서 하위의 \u003ccode\u003eshadow dom\u003c/code\u003e에서 발생한 custom event를 전파 받을 수 있게된다.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eEvent capturing과 shadow DOM\u003c/p\u003e\n\u003cp\u003eEvent capturing은 shadow DOM에서 상위 엘리멘트로의 이벤트 전파가 아니기 때문에 \u003ccode\u003eshadow DOM\u003c/code\u003e의 존재 유무와 관계 없이 일반적인 형태로 흐른다.\u003c/p\u003e\n\u003c/blockquote\u003e\n",
            "postsByCategory": [
              {
                "title": "Web component - custom element",
                "description": "웹 컴포넌트로 만드는 나만의 custom element",
                "fileName": "web-component-web-component---custom-element.md",
                "category": "web-component",
                "published": true,
                "publishedAt": "2022-07-31",
                "thumbnailName": "e0e40e28cf11f896033c8650f19188b7",
                "tags": [],
                "references": [
                  { "title": "Custom element naming convention", "url": "https://html.spec.whatwg.org/#valid-custom-element-name" },
                  { "title": "WebComponent org", "url": "https://www.webcomponents.org/" },
                  {
                    "title": "https://web.dev/custom-elements-v1/#custom-element-reactions",
                    "url": "https://web.dev/custom-elements-v1/#custom-element-reactions"
                  }
                ],
                "series": { "nextPostTitle": "Web component - Shadow DOM" },
                "order": 18
              }
            ]
          },
          "__N_SSG": true
        },
        "page": "/[title]",
        "query": { "title": "web-component---shadow-dom" },
        "buildId": "AZTFjl0iXmv1GfgA-IOvJ",
        "isFallback": false,
        "gsp": true,
        "scriptLoader": []
      }
    </script>
  </body>
</html>
