<!DOCTYPE html><html lang="ko"><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><link rel="canonical" href="https://code-logs.github.io/proxy"/><link rel="apple-touch-icon" href="/icons/icon-192x-192.png"/><link rel="manifest" href="/manifest.json"/><meta name="theme-color" content="#fff"/><meta property="og:type" content="website"/><meta property="og:site_name" content="Code Logs"/><meta name="author" content="Jay Lee"/><meta name="keyword" content="javascript, proxy, trap, es6, 프록시, Proxy, Javascript ES6 Proxy, Proxy, Trap, 프락시를 이용한 객체 조작의 제어, javascript"/><meta name="description" content="Javascript ES6 Proxy, Proxy, Trap, 프락시를 이용한 객체 조작의 제어"/><meta property="og:description" content="Javascript ES6 Proxy, Proxy, Trap, 프락시를 이용한 객체 조작의 제어"/><meta property="og:title" content="Proxy | Code Logs"/><meta property="og:url" content="https://code-logs.github.io/proxy"/><meta property="og:image" content="/assets/images/proxy.jpg"/><title>Proxy | Code Logs</title><meta name="next-head-count" content="16"/><link rel="preload" href="/_next/static/css/87e3edeaa2ab3cca.css" as="style"/><link rel="stylesheet" href="/_next/static/css/87e3edeaa2ab3cca.css" data-n-g=""/><link rel="preload" href="/_next/static/css/9f2fc622355c4ebf.css" as="style"/><link rel="stylesheet" href="/_next/static/css/9f2fc622355c4ebf.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script src="/_next/static/chunks/webpack-2e51481b1d484a05.js" defer=""></script><script src="/_next/static/chunks/framework-5f4595e5518b5600.js" defer=""></script><script src="/_next/static/chunks/main-a4d9e436b9a532ca.js" defer=""></script><script src="/_next/static/chunks/pages/_app-b2577c7b15f5f7c8.js" defer=""></script><script src="/_next/static/chunks/294-c1b4c50337db4bdd.js" defer=""></script><script src="/_next/static/chunks/pages/%5Btitle%5D-9d0c4f775712767e.js" defer=""></script><script src="/_next/static/kqCKj8rnrZPYjk1LoH_-m/_buildManifest.js" defer=""></script><script src="/_next/static/kqCKj8rnrZPYjk1LoH_-m/_ssgManifest.js" defer=""></script><script src="/_next/static/kqCKj8rnrZPYjk1LoH_-m/_middlewareManifest.js" defer=""></script></head><body><div id="__next" data-reactroot=""><header class="Header_header__RW35m"><p class="Header_title__GPS8b">Code Logs</p><ul class="Header_socialIcons__CBf_s"><li><a href="https://github.com/possible819" target="_blank" rel="noreferrer" aria-label="My Github"><style data-emotion="css vubbuv">.css-vubbuv{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;width:1em;height:1em;display:inline-block;fill:currentColor;-webkit-flex-shrink:0;-ms-flex-negative:0;flex-shrink:0;-webkit-transition:fill 200ms cubic-bezier(0.4, 0, 0.2, 1) 0ms;transition:fill 200ms cubic-bezier(0.4, 0, 0.2, 1) 0ms;font-size:1.5rem;}</style><svg class="MuiSvgIcon-root MuiSvgIcon-fontSizeMedium css-vubbuv" focusable="false" aria-hidden="true" viewBox="0 0 24 24" data-testid="GitHubIcon"><path d="M12 1.27a11 11 0 00-3.48 21.46c.55.09.73-.28.73-.55v-1.84c-3.03.64-3.67-1.46-3.67-1.46-.55-1.29-1.28-1.65-1.28-1.65-.92-.65.1-.65.1-.65 1.1 0 1.73 1.1 1.73 1.1.92 1.65 2.57 1.2 3.21.92a2 2 0 01.64-1.47c-2.47-.27-5.04-1.19-5.04-5.5 0-1.1.46-2.1 1.2-2.84a3.76 3.76 0 010-2.93s.91-.28 3.11 1.1c1.8-.49 3.7-.49 5.5 0 2.1-1.38 3.02-1.1 3.02-1.1a3.76 3.76 0 010 2.93c.83.74 1.2 1.74 1.2 2.94 0 4.21-2.57 5.13-5.04 5.4.45.37.82.92.82 2.02v3.03c0 .27.1.64.73.55A11 11 0 0012 1.27"></path></svg></a></li></ul><nav class="NavBar_navBar__akqA3"><ul><li><a class="MarkedAnchor_anchor__QCmkL" href="https://code-logs.github.io/">Home</a></li><li><a class="MarkedAnchor_anchor__QCmkL" href="https://code-logs.github.io/posts/1">Posts</a></li><li><a class="MarkedAnchor_anchor__QCmkL" href="https://code-logs.github.io/about">About</a></li></ul></nav></header><main><article class="PostDetail_container__Ma_26"><p class="PostDetail_publishedAt__7GOQm"><span></span></p><section class="PostDetail_thumbnailWrapper__oALCg"><img src="/assets/images/proxy.jpg" alt="Javascript ES6 Proxy, Proxy, Trap, 프락시를 이용한 객체 조작의 제어"/></section><section><h1>Proxy</h1><p class="PostDetail_description__l6wHC">Javascript ES6 Proxy, Proxy, Trap, 프락시를 이용한 객체 조작의 제어</p></section><section><h2 id="table-of-contents">Table of contents</h2>
<ol>
<li><a href="#proxy">Proxy?</a></li>
<li><a href="#%EC%9A%A9%EB%B2%95">용법</a><ol>
<li><a href="#trap%EC%9D%98-%EC%A2%85%EB%A5%98">Trap의 종류</a></li>
</ol>
</li>
<li><a href="#sample">Sample</a><ol>
<li><a href="#get">Get</a></li>
<li><a href="#set">Set</a></li>
<li><a href="#apply">Apply</a></li>
<li><a href="#construct">Construct</a></li>
</ol>
</li>
<li><a href="#revocable-proxy">Revocable proxy</a></li>
<li><a href="#%EB%A7%88%EC%B9%98%EB%A9%B0">마치며</a></li>
</ol>
<h2 id="proxy">Proxy?</h2>
<p>프락시라는 말은 오늘 기록하려고 하는 javascript에서뿐 아니라 다양한 분야에서 범용적으로 사용되는 용어인듯하다.
나에게 익숙한 용어는 <code>Proxy server</code>인데 웹서버 구성시 Reverse proxy 설정을 유용히 사용하면서 익숙해졌다.</p>
<blockquote>
<p>Reverse proxy?</p>
<p>클라이언트로부터의 요청을 프락시 서버가 직접 받아 내부 네트워크에서 자원을 다운받고 응답하는 네트워크 구조</p>
<p>WAS가 요청을 처리하는 것이 아닌 요청과 응답 사이에 대리인 (Proxy)이 개입하여 이를 중계함</p>
</blockquote>
<p><code>Proxy</code>의 사전적 의미는 &#39;대리&#39;로 중계의 역할을 수행하는 것에 보통 사용된다.</p>
<p>javascript에서의 프락시 또한 어떤 객체의 조작이 발생할 때 이를 가로채서 <code>Proxy</code> 내부의 로직을 통해 대상 객체를 조작하는 것을 말한다.</p>
<h2 id="용법">용법</h2>
<pre><code class="language-javascript">const target = {}
const handler = {
  get(target, prop) {
    if (prop in target) {
      return target[prop]
    } else {
      return `타겟 오브젝트에 해당 프로퍼티 (${prop})가 존재하지 않습니다.`
    }
  },
}

const proxy = new Proxy(target, handler)
console.log(
  proxy.name
) /* 타겟 오브젝트에 해당 프로퍼티 (name)가 존재하지 않습니다. */
</code></pre>
<p><code>Proxy</code> 객체는 두개의 파라미터를 인자로 받는다. 첫번째는 <code>Proxy</code>를 적용할 대상 객체이고 두번째는 대상 객체를 조작할 때 호출될 핸들러 객체이다.
핸들러는 <code>trap</code>이라고 불리는 매서드를 가질 수 있으며, <code>trap</code>은 대상 객체의 조작이 발생 할 경우 그것을 가로채어 처리하는 역할을 한다.</p>
<p>생성된 <code>proxy</code>에 조작이 발생 했을때 handler 내부에 해당 조작을 가로챌 <code>trap</code>이 존재한다면 <code>trap</code> 매서드가 호출된다.</p>
<p>예제에서 본 것과 같이 <code>trap</code>은 정해진 명칭을 통해 구현해야한다.</p>
<h3 id="trap의-종류">Trap의 종류</h3>
<table>
<thead>
<tr>
<th align="center">내부 메서드</th>
<th align="center">핸들러 메서드 명칭</th>
<th>트리거</th>
<th>구현 규칙</th>
</tr>
</thead>
<tbody><tr>
<td align="center">[[Get]]</td>
<td align="center">get</td>
<td>프로퍼티 읽기</td>
<td></td>
</tr>
<tr>
<td align="center">[[Set]]</td>
<td align="center">set</td>
<td>프로퍼티 쓰기</td>
<td>프로퍼티 쓰기 성공여부를 true/false로 리턴 해야함</td>
</tr>
<tr>
<td align="center">[[HasProperty]]</td>
<td align="center">has</td>
<td>in 연산자 사용</td>
<td></td>
</tr>
<tr>
<td align="center">[[Delete]]</td>
<td align="center">deleteProperty</td>
<td>프로퍼티 삭제</td>
<td>프로퍼티 삭제 성공여부를 true/false로 리턴 해야함</td>
</tr>
<tr>
<td align="center">[[Call]]</td>
<td align="center">apply</td>
<td>함수 호출</td>
<td></td>
</tr>
<tr>
<td align="center">[[Construct]]</td>
<td align="center">construct</td>
<td>new 연산자 사용</td>
<td>반드시 생성자를 통해 호출된 객체를 리턴 해야함</td>
</tr>
<tr>
<td align="center">[[GetPrototypeOf]]</td>
<td align="center">getPrototypeOf</td>
<td>Object.getPrototypeOf</td>
<td></td>
</tr>
<tr>
<td align="center">[[SetPrototypeOf]]</td>
<td align="center">setPrototypeOf</td>
<td>Object.setPrototypeOf</td>
<td></td>
</tr>
<tr>
<td align="center">[[IsExtensible]]</td>
<td align="center">isExtensible</td>
<td>Object.isExtensible</td>
<td></td>
</tr>
<tr>
<td align="center">[[PreventExtensions]]</td>
<td align="center">preventExtensions</td>
<td>Object.preventExtensions</td>
<td></td>
</tr>
<tr>
<td align="center">[[DefineOwnProperty]]</td>
<td align="center">defineProperty</td>
<td>Object.defineProperty, Object.defineProperties</td>
<td></td>
</tr>
<tr>
<td align="center">[[GetOwnProperty]]</td>
<td align="center">getOwnPropertyDescriptor</td>
<td>Object.getOwnPropertyDescriptor, for..in, Object.keys, Object.values, Object.entries</td>
<td></td>
</tr>
<tr>
<td align="center">[[OwnPropertyKeys]]</td>
<td align="center">ownKeys</td>
<td>Object.getOwnPropertyNames, Object.getOwnPropertySymbols, for..in, Object.keys, Object.values, Object.entries</td>
<td></td>
</tr>
</tbody></table>
<blockquote>
<p>Trap의 기본적인 규칙은 Proxy를 통해 호출되지 않았을 때와 동일한 유형의 값을 return 해야 한다는데 있다.</p>
</blockquote>
<h2 id="sample">Sample</h2>
<h3 id="get">Get</h3>
<p>다음 예제는 <code>Proxy</code>를 이용하여 객체의 프로퍼티를 조회할 때 해당 프로퍼티가 없을 경우 기본값을 반환하도록 한다.</p>
<pre><code class="language-javascript">const defaultValueProxy = (target, defaultValue) =&gt; {
  const handler = {
    get(target, prop) {
      if (prop in target) {
        return prop[target]
      } else {
        return defaultValue
      }
    },
  }

  return new Proxy(target, handler)
}

const target = { prop1: &#39;value 1&#39; }
const defaultValueTarget = defaultValueProxy(target, &#39;default value&#39;)
console.log(defaultValueTarget.prop1) /* value 1 */
console.log(defaultValueTarget.prop2) /* default value */
</code></pre>
<h3 id="set">Set</h3>
<p>다음 예제는 <code>Proxy</code>를 이용하여 객체의 프로퍼티를 쓰기 전 Validation을 수행한다.</p>
<pre><code class="language-javascript">const validatorProxy = (target, validator) =&gt; {
  const handler = {
    set(target, prop, value) {
      try {
        if (prop in validator) {
          validator[prop](value)
        }

        target[prop] = value
        return true
      } catch (e) {
        console.error(e.message)
        return false
      }
    },
  }

  return new Proxy(target, handler)
}

const profile = validatorProxy(
  {},
  {
    age(age) {
      if (typeof age !== &#39;number&#39;)
        throw new Error(&#39;나이는 반드시 숫자 유형이여야 합니다.&#39;)
      if (age &lt; 0) throw new Error(&#39;나이는 0 보다 작을 수 없습니다.&#39;)
    },
  }
)

profile.name = &#39;홍길동&#39;
profile.age = &#39;스물&#39;
console.log(`Age: ${profile.age}`) /* Age: undefined */
profile.age = -20
console.log(`Age: ${profile.age}`) /* Age: undefined */
profile.age = 20
console.log(`Age: ${profile.age}`) /* Age: 20 */
</code></pre>
<h3 id="apply">Apply</h3>
<p>다음 예제는 함수 호출시 함수 동작 시간을 출력한다.</p>
<pre><code class="language-javascript">const timestampProxy = (target) =&gt; {
  const handler = {
    apply(target, thisArgs, args) {
      console.time(&#39;소요시간&#39;)
      target.apply(thisArgs, args)
      console.timeEnd(&#39;소요시간&#39;)
    },
  }
  return new Proxy(target, handler)
}

const sleep = (second) =&gt; {
  const startedAt = Date.now()
  while ((Date.now() - startedAt) / 1000 &lt; second) {} // sleep

  console.log(&#39;Done&#39;)
}

const sleepTimestamp = timestampProxy(sleep)
sleepTimestamp(3)
/*
  Done
  소요시간: 3000ms 
*/
</code></pre>
<blockquote>
<p>Proxy의 대상은 객체이기 때문에 함수도 그 대상이 될 수 있다.</p>
</blockquote>
<h3 id="construct">Construct</h3>
<pre><code class="language-javascript">const strictConstructor = (target, paramCount) =&gt; {
  const handler = {
    construct(target, args) {
      if (args.length &lt; paramCount)
        throw new Error(
          &#39;생성자 호출을 위해 필요한 모든 파라미터를 전달 받지 못했습니다.&#39;
        )
      return new target(...args)
    },
  }

  return new Proxy(target, handler)
}

class Person {
  constructor(name, age, nickname, hobby) {
    this.name = name
    this.age = age
    this.nickname = nickname
    this.hobby = hobby
  }

  profile() {
    console.table(this)
  }
}

const person = new Person()
person.profile()
/*
  | (index)  |  Values   |
  ------------------------
  |   name   | undefined |
  |   age    | undefined |
  | nickname | undefined |
  |  hobby   | undefined |
*/
</code></pre>
<pre><code class="language-javascript">const StrictPerson = strictConstructor(Person, 2)
new StrictPerson(&#39;John&#39;)
/*
  Error: 생성자 호출을 위해 필요한 모든 파라미터를 전달 받지 못했습니다.
*/
</code></pre>
<pre><code class="language-javascript">const strictPerson = new StrictPerson(&#39;John&#39;, 20)
strictPerson.profile()
/*
  | (index)  |  Values   |
  ------------------------
  |   name   |  &#39;John&#39;   |
  |   age    |    20     |
  | nickname | undefined |
  |  hobby   | undefined |
*/
</code></pre>
<h2 id="revocable-proxy">Revocable proxy</h2>
<p><code>Proxy</code>를 통해 생성된 객체는 <code>GC</code>의 대상에서 제외된다. 이것을 <code>GC</code>의 대상으로 포함시키기 위해서는 아래와 같은 방식으로 <code>Proxy</code>를 생성해야한다.</p>
<blockquote>
<p>GC (Garbage Collection)</p>
<p>메모리 관리 기법 중의 하나로, 프로그램이 동적으로 할당했던 메모리 영역 중에서 필요없게 된 영역을 해제하는 기능 - <a href="https://ko.wikipedia.org/wiki/%EC%93%B0%EB%A0%88%EA%B8%B0_%EC%88%98%EC%A7%91_(%EC%BB%B4%ED%93%A8%ED%84%B0_%EA%B3%BC%ED%95%99)">wiki</a></p>
</blockquote>
<pre><code class="language-javascript">const target = {}
const handler = {}
const revocableProxy = Proxy.revocable(target, handler)
</code></pre>
<p>new 연산자를 통해 <code>Proxy</code>를 생성하는 것이 아닌 static method인 <code>revocable</code>을 호출하는 것으로 <code>Proxy</code> 객체를 생성하면 된다.
그 외의 사용법은 new 연산자를 통해 생성한 <code>Proxy</code>와 동일하다.</p>
<p><code>revocable proxy</code>의 경우 <code>proxy</code> 프로퍼티를 통해 대상 객체의 인자에 접근 할 수 있다.
<code>revocable proxy</code>의 사용이 완료되고 <code>GC</code>의 대상으로 포함시키기 위해서는 아래와 같이 명시적으로 <code>revoke</code>를 호출해주면 된다.
<code>revoke</code>가 호출된 이후 대상 객체에 대한 조작을 시도하면 <code>TypeError</code>를 발생시키고 <code>revocable proxy</code>는 <code>GC</code>의 대상이 되어 폐기된다.</p>
<pre><code class="language-javascript">const revocableProxy = (target) =&gt; {
  const handler = {
    get(target, prop) {
      console.log(&#39;Proxy Getter&#39;)
      return target[prop]
    },
  }

  return Proxy.revocable(target, handler)
}

const revocable = revocableProxy({ name: &#39;홍길동&#39; })
revocable.proxy.name
/*
  Proxy Getter
  홍길동
*/
revocable.revoke()
revocable.proxy.name
/*
  TypeError: Cannot perform &#39;get&#39; on a proxy that has been revoked
*/
</code></pre>
<h2 id="마치며">마치며</h2>
<p><code>Proxy</code>는 객체 내부 인자에 대한 조작을 감지 할 수 있다는 것 자체로도 많은 잠재력을 가지고 있다. 상황에 맞게 <code>Proxy</code>를 이용하면 객체의 상태 감지를 통한 특별한 작업들을 할 수 있다. (상태 관리 도구와 같은)</p>
</section></article><section class="PostDetail_utterances__jZeOm"><h2>Comments</h2><div></div></section></main><aside></aside><footer class="Footer_footer__GLL0J"><p>ⓒ 2021. Jay Lee  all rights reserved.</p></footer></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"Proxy","fileName":"proxy.md","description":"Javascript ES6 Proxy, Proxy, Trap, 프락시를 이용한 객체 조작의 제어","category":"javascript","published":true,"publishedAt":"2021-10-25","tags":["javascript","proxy","trap","es6","프록시"],"thumbnailName":"proxy.jpg"},"content":"\u003ch2 id=\"table-of-contents\"\u003eTable of contents\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003e\u003ca href=\"#proxy\"\u003eProxy?\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#%EC%9A%A9%EB%B2%95\"\u003e용법\u003c/a\u003e\u003col\u003e\n\u003cli\u003e\u003ca href=\"#trap%EC%9D%98-%EC%A2%85%EB%A5%98\"\u003eTrap의 종류\u003c/a\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#sample\"\u003eSample\u003c/a\u003e\u003col\u003e\n\u003cli\u003e\u003ca href=\"#get\"\u003eGet\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#set\"\u003eSet\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#apply\"\u003eApply\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#construct\"\u003eConstruct\u003c/a\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#revocable-proxy\"\u003eRevocable proxy\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#%EB%A7%88%EC%B9%98%EB%A9%B0\"\u003e마치며\u003c/a\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2 id=\"proxy\"\u003eProxy?\u003c/h2\u003e\n\u003cp\u003e프락시라는 말은 오늘 기록하려고 하는 javascript에서뿐 아니라 다양한 분야에서 범용적으로 사용되는 용어인듯하다.\n나에게 익숙한 용어는 \u003ccode\u003eProxy server\u003c/code\u003e인데 웹서버 구성시 Reverse proxy 설정을 유용히 사용하면서 익숙해졌다.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eReverse proxy?\u003c/p\u003e\n\u003cp\u003e클라이언트로부터의 요청을 프락시 서버가 직접 받아 내부 네트워크에서 자원을 다운받고 응답하는 네트워크 구조\u003c/p\u003e\n\u003cp\u003eWAS가 요청을 처리하는 것이 아닌 요청과 응답 사이에 대리인 (Proxy)이 개입하여 이를 중계함\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e\u003ccode\u003eProxy\u003c/code\u003e의 사전적 의미는 \u0026#39;대리\u0026#39;로 중계의 역할을 수행하는 것에 보통 사용된다.\u003c/p\u003e\n\u003cp\u003ejavascript에서의 프락시 또한 어떤 객체의 조작이 발생할 때 이를 가로채서 \u003ccode\u003eProxy\u003c/code\u003e 내부의 로직을 통해 대상 객체를 조작하는 것을 말한다.\u003c/p\u003e\n\u003ch2 id=\"용법\"\u003e용법\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003econst target = {}\nconst handler = {\n  get(target, prop) {\n    if (prop in target) {\n      return target[prop]\n    } else {\n      return `타겟 오브젝트에 해당 프로퍼티 (${prop})가 존재하지 않습니다.`\n    }\n  },\n}\n\nconst proxy = new Proxy(target, handler)\nconsole.log(\n  proxy.name\n) /* 타겟 오브젝트에 해당 프로퍼티 (name)가 존재하지 않습니다. */\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003eProxy\u003c/code\u003e 객체는 두개의 파라미터를 인자로 받는다. 첫번째는 \u003ccode\u003eProxy\u003c/code\u003e를 적용할 대상 객체이고 두번째는 대상 객체를 조작할 때 호출될 핸들러 객체이다.\n핸들러는 \u003ccode\u003etrap\u003c/code\u003e이라고 불리는 매서드를 가질 수 있으며, \u003ccode\u003etrap\u003c/code\u003e은 대상 객체의 조작이 발생 할 경우 그것을 가로채어 처리하는 역할을 한다.\u003c/p\u003e\n\u003cp\u003e생성된 \u003ccode\u003eproxy\u003c/code\u003e에 조작이 발생 했을때 handler 내부에 해당 조작을 가로챌 \u003ccode\u003etrap\u003c/code\u003e이 존재한다면 \u003ccode\u003etrap\u003c/code\u003e 매서드가 호출된다.\u003c/p\u003e\n\u003cp\u003e예제에서 본 것과 같이 \u003ccode\u003etrap\u003c/code\u003e은 정해진 명칭을 통해 구현해야한다.\u003c/p\u003e\n\u003ch3 id=\"trap의-종류\"\u003eTrap의 종류\u003c/h3\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth align=\"center\"\u003e내부 메서드\u003c/th\u003e\n\u003cth align=\"center\"\u003e핸들러 메서드 명칭\u003c/th\u003e\n\u003cth\u003e트리거\u003c/th\u003e\n\u003cth\u003e구현 규칙\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd align=\"center\"\u003e[[Get]]\u003c/td\u003e\n\u003ctd align=\"center\"\u003eget\u003c/td\u003e\n\u003ctd\u003e프로퍼티 읽기\u003c/td\u003e\n\u003ctd\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd align=\"center\"\u003e[[Set]]\u003c/td\u003e\n\u003ctd align=\"center\"\u003eset\u003c/td\u003e\n\u003ctd\u003e프로퍼티 쓰기\u003c/td\u003e\n\u003ctd\u003e프로퍼티 쓰기 성공여부를 true/false로 리턴 해야함\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd align=\"center\"\u003e[[HasProperty]]\u003c/td\u003e\n\u003ctd align=\"center\"\u003ehas\u003c/td\u003e\n\u003ctd\u003ein 연산자 사용\u003c/td\u003e\n\u003ctd\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd align=\"center\"\u003e[[Delete]]\u003c/td\u003e\n\u003ctd align=\"center\"\u003edeleteProperty\u003c/td\u003e\n\u003ctd\u003e프로퍼티 삭제\u003c/td\u003e\n\u003ctd\u003e프로퍼티 삭제 성공여부를 true/false로 리턴 해야함\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd align=\"center\"\u003e[[Call]]\u003c/td\u003e\n\u003ctd align=\"center\"\u003eapply\u003c/td\u003e\n\u003ctd\u003e함수 호출\u003c/td\u003e\n\u003ctd\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd align=\"center\"\u003e[[Construct]]\u003c/td\u003e\n\u003ctd align=\"center\"\u003econstruct\u003c/td\u003e\n\u003ctd\u003enew 연산자 사용\u003c/td\u003e\n\u003ctd\u003e반드시 생성자를 통해 호출된 객체를 리턴 해야함\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd align=\"center\"\u003e[[GetPrototypeOf]]\u003c/td\u003e\n\u003ctd align=\"center\"\u003egetPrototypeOf\u003c/td\u003e\n\u003ctd\u003eObject.getPrototypeOf\u003c/td\u003e\n\u003ctd\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd align=\"center\"\u003e[[SetPrototypeOf]]\u003c/td\u003e\n\u003ctd align=\"center\"\u003esetPrototypeOf\u003c/td\u003e\n\u003ctd\u003eObject.setPrototypeOf\u003c/td\u003e\n\u003ctd\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd align=\"center\"\u003e[[IsExtensible]]\u003c/td\u003e\n\u003ctd align=\"center\"\u003eisExtensible\u003c/td\u003e\n\u003ctd\u003eObject.isExtensible\u003c/td\u003e\n\u003ctd\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd align=\"center\"\u003e[[PreventExtensions]]\u003c/td\u003e\n\u003ctd align=\"center\"\u003epreventExtensions\u003c/td\u003e\n\u003ctd\u003eObject.preventExtensions\u003c/td\u003e\n\u003ctd\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd align=\"center\"\u003e[[DefineOwnProperty]]\u003c/td\u003e\n\u003ctd align=\"center\"\u003edefineProperty\u003c/td\u003e\n\u003ctd\u003eObject.defineProperty, Object.defineProperties\u003c/td\u003e\n\u003ctd\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd align=\"center\"\u003e[[GetOwnProperty]]\u003c/td\u003e\n\u003ctd align=\"center\"\u003egetOwnPropertyDescriptor\u003c/td\u003e\n\u003ctd\u003eObject.getOwnPropertyDescriptor, for..in, Object.keys, Object.values, Object.entries\u003c/td\u003e\n\u003ctd\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd align=\"center\"\u003e[[OwnPropertyKeys]]\u003c/td\u003e\n\u003ctd align=\"center\"\u003eownKeys\u003c/td\u003e\n\u003ctd\u003eObject.getOwnPropertyNames, Object.getOwnPropertySymbols, for..in, Object.keys, Object.values, Object.entries\u003c/td\u003e\n\u003ctd\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003cblockquote\u003e\n\u003cp\u003eTrap의 기본적인 규칙은 Proxy를 통해 호출되지 않았을 때와 동일한 유형의 값을 return 해야 한다는데 있다.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch2 id=\"sample\"\u003eSample\u003c/h2\u003e\n\u003ch3 id=\"get\"\u003eGet\u003c/h3\u003e\n\u003cp\u003e다음 예제는 \u003ccode\u003eProxy\u003c/code\u003e를 이용하여 객체의 프로퍼티를 조회할 때 해당 프로퍼티가 없을 경우 기본값을 반환하도록 한다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003econst defaultValueProxy = (target, defaultValue) =\u0026gt; {\n  const handler = {\n    get(target, prop) {\n      if (prop in target) {\n        return prop[target]\n      } else {\n        return defaultValue\n      }\n    },\n  }\n\n  return new Proxy(target, handler)\n}\n\nconst target = { prop1: \u0026#39;value 1\u0026#39; }\nconst defaultValueTarget = defaultValueProxy(target, \u0026#39;default value\u0026#39;)\nconsole.log(defaultValueTarget.prop1) /* value 1 */\nconsole.log(defaultValueTarget.prop2) /* default value */\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"set\"\u003eSet\u003c/h3\u003e\n\u003cp\u003e다음 예제는 \u003ccode\u003eProxy\u003c/code\u003e를 이용하여 객체의 프로퍼티를 쓰기 전 Validation을 수행한다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003econst validatorProxy = (target, validator) =\u0026gt; {\n  const handler = {\n    set(target, prop, value) {\n      try {\n        if (prop in validator) {\n          validator[prop](value)\n        }\n\n        target[prop] = value\n        return true\n      } catch (e) {\n        console.error(e.message)\n        return false\n      }\n    },\n  }\n\n  return new Proxy(target, handler)\n}\n\nconst profile = validatorProxy(\n  {},\n  {\n    age(age) {\n      if (typeof age !== \u0026#39;number\u0026#39;)\n        throw new Error(\u0026#39;나이는 반드시 숫자 유형이여야 합니다.\u0026#39;)\n      if (age \u0026lt; 0) throw new Error(\u0026#39;나이는 0 보다 작을 수 없습니다.\u0026#39;)\n    },\n  }\n)\n\nprofile.name = \u0026#39;홍길동\u0026#39;\nprofile.age = \u0026#39;스물\u0026#39;\nconsole.log(`Age: ${profile.age}`) /* Age: undefined */\nprofile.age = -20\nconsole.log(`Age: ${profile.age}`) /* Age: undefined */\nprofile.age = 20\nconsole.log(`Age: ${profile.age}`) /* Age: 20 */\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"apply\"\u003eApply\u003c/h3\u003e\n\u003cp\u003e다음 예제는 함수 호출시 함수 동작 시간을 출력한다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003econst timestampProxy = (target) =\u0026gt; {\n  const handler = {\n    apply(target, thisArgs, args) {\n      console.time(\u0026#39;소요시간\u0026#39;)\n      target.apply(thisArgs, args)\n      console.timeEnd(\u0026#39;소요시간\u0026#39;)\n    },\n  }\n  return new Proxy(target, handler)\n}\n\nconst sleep = (second) =\u0026gt; {\n  const startedAt = Date.now()\n  while ((Date.now() - startedAt) / 1000 \u0026lt; second) {} // sleep\n\n  console.log(\u0026#39;Done\u0026#39;)\n}\n\nconst sleepTimestamp = timestampProxy(sleep)\nsleepTimestamp(3)\n/*\n  Done\n  소요시간: 3000ms \n*/\n\u003c/code\u003e\u003c/pre\u003e\n\u003cblockquote\u003e\n\u003cp\u003eProxy의 대상은 객체이기 때문에 함수도 그 대상이 될 수 있다.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch3 id=\"construct\"\u003eConstruct\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003econst strictConstructor = (target, paramCount) =\u0026gt; {\n  const handler = {\n    construct(target, args) {\n      if (args.length \u0026lt; paramCount)\n        throw new Error(\n          \u0026#39;생성자 호출을 위해 필요한 모든 파라미터를 전달 받지 못했습니다.\u0026#39;\n        )\n      return new target(...args)\n    },\n  }\n\n  return new Proxy(target, handler)\n}\n\nclass Person {\n  constructor(name, age, nickname, hobby) {\n    this.name = name\n    this.age = age\n    this.nickname = nickname\n    this.hobby = hobby\n  }\n\n  profile() {\n    console.table(this)\n  }\n}\n\nconst person = new Person()\nperson.profile()\n/*\n  | (index)  |  Values   |\n  ------------------------\n  |   name   | undefined |\n  |   age    | undefined |\n  | nickname | undefined |\n  |  hobby   | undefined |\n*/\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003econst StrictPerson = strictConstructor(Person, 2)\nnew StrictPerson(\u0026#39;John\u0026#39;)\n/*\n  Error: 생성자 호출을 위해 필요한 모든 파라미터를 전달 받지 못했습니다.\n*/\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003econst strictPerson = new StrictPerson(\u0026#39;John\u0026#39;, 20)\nstrictPerson.profile()\n/*\n  | (index)  |  Values   |\n  ------------------------\n  |   name   |  \u0026#39;John\u0026#39;   |\n  |   age    |    20     |\n  | nickname | undefined |\n  |  hobby   | undefined |\n*/\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"revocable-proxy\"\u003eRevocable proxy\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003eProxy\u003c/code\u003e를 통해 생성된 객체는 \u003ccode\u003eGC\u003c/code\u003e의 대상에서 제외된다. 이것을 \u003ccode\u003eGC\u003c/code\u003e의 대상으로 포함시키기 위해서는 아래와 같은 방식으로 \u003ccode\u003eProxy\u003c/code\u003e를 생성해야한다.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eGC (Garbage Collection)\u003c/p\u003e\n\u003cp\u003e메모리 관리 기법 중의 하나로, 프로그램이 동적으로 할당했던 메모리 영역 중에서 필요없게 된 영역을 해제하는 기능 - \u003ca href=\"https://ko.wikipedia.org/wiki/%EC%93%B0%EB%A0%88%EA%B8%B0_%EC%88%98%EC%A7%91_(%EC%BB%B4%ED%93%A8%ED%84%B0_%EA%B3%BC%ED%95%99)\"\u003ewiki\u003c/a\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003econst target = {}\nconst handler = {}\nconst revocableProxy = Proxy.revocable(target, handler)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003enew 연산자를 통해 \u003ccode\u003eProxy\u003c/code\u003e를 생성하는 것이 아닌 static method인 \u003ccode\u003erevocable\u003c/code\u003e을 호출하는 것으로 \u003ccode\u003eProxy\u003c/code\u003e 객체를 생성하면 된다.\n그 외의 사용법은 new 연산자를 통해 생성한 \u003ccode\u003eProxy\u003c/code\u003e와 동일하다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003erevocable proxy\u003c/code\u003e의 경우 \u003ccode\u003eproxy\u003c/code\u003e 프로퍼티를 통해 대상 객체의 인자에 접근 할 수 있다.\n\u003ccode\u003erevocable proxy\u003c/code\u003e의 사용이 완료되고 \u003ccode\u003eGC\u003c/code\u003e의 대상으로 포함시키기 위해서는 아래와 같이 명시적으로 \u003ccode\u003erevoke\u003c/code\u003e를 호출해주면 된다.\n\u003ccode\u003erevoke\u003c/code\u003e가 호출된 이후 대상 객체에 대한 조작을 시도하면 \u003ccode\u003eTypeError\u003c/code\u003e를 발생시키고 \u003ccode\u003erevocable proxy\u003c/code\u003e는 \u003ccode\u003eGC\u003c/code\u003e의 대상이 되어 폐기된다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003econst revocableProxy = (target) =\u0026gt; {\n  const handler = {\n    get(target, prop) {\n      console.log(\u0026#39;Proxy Getter\u0026#39;)\n      return target[prop]\n    },\n  }\n\n  return Proxy.revocable(target, handler)\n}\n\nconst revocable = revocableProxy({ name: \u0026#39;홍길동\u0026#39; })\nrevocable.proxy.name\n/*\n  Proxy Getter\n  홍길동\n*/\nrevocable.revoke()\nrevocable.proxy.name\n/*\n  TypeError: Cannot perform \u0026#39;get\u0026#39; on a proxy that has been revoked\n*/\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"마치며\"\u003e마치며\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003eProxy\u003c/code\u003e는 객체 내부 인자에 대한 조작을 감지 할 수 있다는 것 자체로도 많은 잠재력을 가지고 있다. 상황에 맞게 \u003ccode\u003eProxy\u003c/code\u003e를 이용하면 객체의 상태 감지를 통한 특별한 작업들을 할 수 있다. (상태 관리 도구와 같은)\u003c/p\u003e\n"},"__N_SSG":true},"page":"/[title]","query":{"title":"proxy"},"buildId":"kqCKj8rnrZPYjk1LoH_-m","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>