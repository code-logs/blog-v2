<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><link rel="canonical" href="https://code-logs.github.io/web-component---slot"/><link rel="apple-touch-icon" href="/icons/icon-192x-192.png"/><link rel="manifest" href="/manifest.json"/><meta name="theme-color" content="#fff"/><meta property="og:type" content="website"/><meta property="og:site_name" content="Code Logs"/><meta name="author" content="Jay Lee"/><meta name="viewport" content="width=device-width, user-scalable=no"/><meta name="keyword" content="custom dialog, custom element, dialog, slot, web component, 웹 컴포넌트, 커스텀 엘리먼트, Web component - slot, &lt;slot&gt; 태그를 이용해 커스텀 엘리먼트에 자식 엘리먼트를 주입할 수 있는 방법을 소개 합니다.
&lt;slot&gt; 태그를 이용해 조금더 유연한 형태의 dialog 커스텀 엘리먼트를 만들기
, web-component"/><meta name="description" content="Code Logs Web component - slot - &lt;slot&gt; 태그를 이용해 커스텀 엘리먼트에 자식 엘리먼트를 주입할 수 있는 방법을 소개 합니다.
&lt;slot&gt; 태그를 이용해 조금더 유연한 형태의 dialog 커스텀 엘리먼트를 만들기
 | web-component, custom dialog, custom element, dialog, slot, web component, 웹 컴포넌트, 커스텀 엘리먼트"/><meta property="og:description" content="Code Logs Web component - slot - &lt;slot&gt; 태그를 이용해 커스텀 엘리먼트에 자식 엘리먼트를 주입할 수 있는 방법을 소개 합니다.
&lt;slot&gt; 태그를 이용해 조금더 유연한 형태의 dialog 커스텀 엘리먼트를 만들기
 | web-component, custom dialog, custom element, dialog, slot, web component, 웹 컴포넌트, 커스텀 엘리먼트"/><meta property="og:title" content="Web component - slot | Code Logs"/><meta property="og:url" content="https://code-logs.github.io/web-component---slot"/><meta property="og:image" content="/assets/images/c96f4eff2512178b9b4e02d5aad66827"/><title>Web component - slot | Code Logs</title><meta name="next-head-count" content="16"/><link rel="preload" href="/_next/static/css/0a1b0215810f4c7c.css" as="style"/><link rel="stylesheet" href="/_next/static/css/0a1b0215810f4c7c.css" data-n-g=""/><link rel="preload" href="/_next/static/css/925c974c05474375.css" as="style"/><link rel="stylesheet" href="/_next/static/css/925c974c05474375.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script src="/_next/static/chunks/webpack-2e51481b1d484a05.js" defer=""></script><script src="/_next/static/chunks/framework-5f4595e5518b5600.js" defer=""></script><script src="/_next/static/chunks/main-a4d9e436b9a532ca.js" defer=""></script><script src="/_next/static/chunks/pages/_app-c230ee1bd3903484.js" defer=""></script><script src="/_next/static/chunks/294-afe3b80e3fd60e21.js" defer=""></script><script src="/_next/static/chunks/474-b38e51107a7e89fa.js" defer=""></script><script src="/_next/static/chunks/pages/%5Btitle%5D-20576d36c3c52ac5.js" defer=""></script><script src="/_next/static/4WD65o-815mDn_Wz8OGpu/_buildManifest.js" defer=""></script><script src="/_next/static/4WD65o-815mDn_Wz8OGpu/_ssgManifest.js" defer=""></script><script src="/_next/static/4WD65o-815mDn_Wz8OGpu/_middlewareManifest.js" defer=""></script></head><body><div id="__next" data-reactroot=""><header class="style_header__5q4mN"><span class="style_title__1cU2T">Code Logs</span><ul class="style_socialIcons__h5kLi"><li><a href="https://github.com/possible819" target="_blank" rel="noreferrer" aria-label="My Github"><style data-emotion="css vubbuv">.css-vubbuv{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;width:1em;height:1em;display:inline-block;fill:currentColor;-webkit-flex-shrink:0;-ms-flex-negative:0;flex-shrink:0;-webkit-transition:fill 200ms cubic-bezier(0.4, 0, 0.2, 1) 0ms;transition:fill 200ms cubic-bezier(0.4, 0, 0.2, 1) 0ms;font-size:1.5rem;}</style><svg class="MuiSvgIcon-root MuiSvgIcon-fontSizeMedium css-vubbuv" focusable="false" aria-hidden="true" viewBox="0 0 24 24" data-testid="GitHubIcon"><path d="M12 1.27a11 11 0 00-3.48 21.46c.55.09.73-.28.73-.55v-1.84c-3.03.64-3.67-1.46-3.67-1.46-.55-1.29-1.28-1.65-1.28-1.65-.92-.65.1-.65.1-.65 1.1 0 1.73 1.1 1.73 1.1.92 1.65 2.57 1.2 3.21.92a2 2 0 01.64-1.47c-2.47-.27-5.04-1.19-5.04-5.5 0-1.1.46-2.1 1.2-2.84a3.76 3.76 0 010-2.93s.91-.28 3.11 1.1c1.8-.49 3.7-.49 5.5 0 2.1-1.38 3.02-1.1 3.02-1.1a3.76 3.76 0 010 2.93c.83.74 1.2 1.74 1.2 2.94 0 4.21-2.57 5.13-5.04 5.4.45.37.82.92.82 2.02v3.03c0 .27.1.64.73.55A11 11 0 0012 1.27"></path></svg></a></li></ul><nav class="style_navBar__5k9HL"><ul><li class="clickable"><a href="/" class="style_anchor__MiP75">Home</a></li><li class="clickable"><a href="/posts/1" class="style_anchor__MiP75">Posts</a></li><li class="clickable"><a href="/projects/1" class="style_anchor__MiP75">Projects</a></li><li class="clickable"><a href="/about" class="style_anchor__MiP75">About</a></li></ul></nav></header><main><article class="PostDetail_container__Ma_26"><p class="PostDetail_publishedAt__7GOQm"><span>22.08.18</span></p><section class="PostDetail_thumbnailWrapper__oALCg"><img src="/assets/images/c96f4eff2512178b9b4e02d5aad66827" alt="&lt;slot&gt; 태그를 이용해 커스텀 엘리먼트에 자식 엘리먼트를 주입할 수 있는 방법을 소개 합니다.
&lt;slot&gt; 태그를 이용해 조금더 유연한 형태의 dialog 커스텀 엘리먼트를 만들기
" width="400" height="300"/></section><div class="style_bannerContainer__nH6mm"><a href="https://m.youtube.com/@cat_bread." target="_blank" rel="noreferrer"><img src="/assets/banners/cat-bread.webp" alt="고양이 빵 Cat bread - 세마리의 고양이와 홈베이킹 이야기" width="400" height="131"/></a></div><section><h1>Web component - slot</h1><p class="PostDetail_description__l6wHC">&lt;slot&gt; 태그를 이용해 커스텀 엘리먼트에 자식 엘리먼트를 주입할 수 있는 방법을 소개 합니다.
&lt;slot&gt; 태그를 이용해 조금더 유연한 형태의 dialog 커스텀 엘리먼트를 만들기
</p></section><section id="content"><h2 id="table-of-contents">Table of contents</h2>
<ol>
<li><a href="#slot">Slot</a><ol>
<li><a href="#slot-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0">Slot 사용하기</a></li>
<li><a href="#styling">Styling</a></li>
</ol>
</li>
<li><a href="#dialog-%EB%A7%8C%EB%93%A4%EA%B8%B0">Dialog 만들기</a></li>
</ol>
<h2 id="slot">Slot</h2>
<p><code>&lt;slot&gt;</code> 태그는 웹 컴포넌트 내 특정 영역의 <code>마크업</code>을 외부로 부터 주입 받기 위해 사용되는 태그다.</p>
<p>예를들면 <code>dialog</code> 컴포넌트 처럼 팝업이 나타나고 닫기 버튼을 통해 다시 팝업을 닫는 것과 같은 기능은 컴포넌트 내부에서 구현되지만 팝업의 내용을 채우기 위해서는 외부로 부터 <code>DOM</code>을 주입 받아야 하는데 이럴때 사용할 수 있는 태그가 <code>&lt;slot&gt;</code>이다.</p>
<h3 id="slot-사용하기">Slot 사용하기</h3>
<p><code>&lt;slot&gt;</code> 태그를 통해 커스텀 엘리먼트의 내부로 <code>DOM</code>을 넣는 예제는 아래와 같다.</p>
<pre><code class="language-javascript">customElements.define(
  &#39;custom-slot&#39;,
  class extends HTMLElement {
    constructor() {
      super()
      this.attachShadow({ mode: &#39;open&#39; })
      this.shadowRoot.innerHTML = `
        &lt;style&gt;
          #container {
            padding: 20px 10px;
            background-color: skyblue;
          }
        &lt;/style&gt;

        &lt;div id=&quot;container&quot;&gt;
          &lt;slot&gt;&lt;/slot&gt;
        &lt;/div&gt;
      `
    }
  }
)
</code></pre>
<pre><code class="language-html">...
&lt;custom-slot&gt;
  &lt;p&gt;Slotted&lt;/p&gt;
&lt;/custom-slot&gt;
...
</code></pre>
<p><code>&lt;slot&gt;</code>은 <code>name</code> attribute를 통해 식별할 수 있다. 만약 <code>&lt;slot&gt;</code> 태그에 <code>name</code> attribute가 설정되어 있다면 외부에서 대상 <code>&lt;slot&gt;</code>을 식별 할 수 있도록 <code>slot</code> attribute를 통해 반드시 대상 <code>&lt;slot&gt;</code>의 <code>name</code>을 입력해야 한다.</p>
<pre><code class="language-javascript">customElements.define(
  &#39;custom-slot&#39;,
  class extends HTMLElement {
    constructor() {
      super()
      this.attachShadow({ mode: &#39;open&#39; })
      this.shadowRoot.innerHTML = `
        &lt;style&gt;
          #container {
            padding: 20px 10px;
            background-color: skyblue;
          }
        &lt;/style&gt;

        &lt;div id=&quot;container&quot;&gt;
          &lt;slot name=&quot;first-slot&quot;&gt;&lt;/slot&gt;
          &lt;slot name=&quot;second-slot&quot;&gt;&lt;/slot&gt;
        &lt;/div&gt;
      `
    }
  }
)
</code></pre>
<pre><code class="language-html">...
&lt;custom-slot&gt;
  &lt;p&gt;Slotted&lt;/p&gt;
  &lt;p slot=&quot;second-slot&quot;&gt;Second Slotted&lt;/p&gt;
  &lt;p slot=&quot;first-slot&quot;&gt;First Slotted&lt;/p&gt;
&lt;/custom-slot&gt;
...
</code></pre>
<p>위 예제와 같이 <code>&lt;slot&gt;</code>을 주입하고 <code>name</code>, <code>slot</code> attribute를 설정하면 아래와 같은 형태로 화면에 출력된다.</p>
<ul>
<li><code>&lt;p&gt;Slotted&lt;/p&gt;</code>는 <code>slot</code> attribute가 없어 대상 <code>&lt;slot&gt;</code>을 찾을 수 없기 때문에 화면에 출력되지 않음</li>
<li><code>&lt;p slot=&quot;second-slot&quot;&gt;Second Slotted&lt;/p&gt;</code>과 <code>&lt;p slot=&quot;first-slot&quot;&gt;First Slotted&lt;/p&gt;</code>은 <code>slot</code> attribute를 통해 대상 <code>&lt;slot&gt;</code>을 찾아 화면에 출력됨</li>
<li>화면에 출력된 두 <code>&lt;p&gt;</code> 태그는 주입시 순서와 달리 <code>&lt;custom-slot&gt;</code> 컴포넌트가 지정한 <code>&lt;slot&gt;</code>의 위치에 따라 순서가 바뀐 상태로 출력됨</li>
</ul>
<blockquote>
<p><code>&lt;slot&gt;</code> 태그에 <code>name</code>이 설정되어 있지 않다면 <code>&lt;slot&gt;</code> 태그에 주입되는 자식 요소중 <code>slot</code> attribute가 설정되지 않은 <em>모든 엘리먼트</em>를 <code>&lt;slot&gt;</code>에 삽입한다.</p>
<p><code>&lt;slot&gt;</code> 태그에 <code>name</code> attribute가 설정되어 있다면 <code>slot</code> attribute에 <code>name</code>과 동일한 값을 가지고 있는 <em>모든 엘리먼트</em>가 <code>&lt;slot&gt;</code>에 삽입 된다.</p>
</blockquote>
<h3 id="styling">Styling</h3>
<p><code>&lt;slot&gt;</code> 태그를 통해 외부에서 주입 받은 엘리먼트에 대한 스타일을 정의하기 위해 <code>::slotted</code> <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/Pseudo-elements">pseudo-elements</a>를 사용한다.</p>
<p><code>::slotted</code>를 이용한 <code>CSS</code>는 반드시 <code>shadow DOM</code> 내부에 정의해야 한다. 이렇게 정의된 <code>selector</code>는 <code>text node</code>를 제외한 <code>&lt;slot&gt;</code> 내부의 모든 엘리먼트를 대상으로 한다.</p>
<pre><code class="language-javascript">customElements.define(
  &#39;custom-slot&#39;,
  class extends HTMLElement {
    constructor() {
      super()
      this.attachShadow({ mode: &#39;open&#39; })
      this.shadowRoot.innerHTML = `
        &lt;style&gt;
          #container {
            padding: 20px 10px;
            background-color: skyblue;
          }
          ::slotted(*) {
            font-size: 20px;
          }
          ::slotted([slot=first-slot]) {
            color: tomato;
          }
          ::slotted([slot=second-slot]) {
            color: green;
          }
        &lt;/style&gt;

        &lt;div id=&quot;container&quot;&gt;
          &lt;slot name=&quot;first-slot&quot;&gt;&lt;/slot&gt;
          &lt;slot name=&quot;second-slot&quot;&gt;&lt;/slot&gt;
        &lt;/div&gt;
      `
    }
  }
)
</code></pre>
<p>예제와 같은 style 정의를 통해 외부에서 전달 받은 엘리먼트에 대한 스타일을 적용할 수 있다.</p>
<blockquote>
<p><code>[slot=second-slot]</code> 에서 확인 할 수 있듯 특정 attribute를 통해 대상 엘리먼트를 <code>select</code> 할 경우 외부에서 정의한 엘리먼트의 attribute를 참조한다.</p>
</blockquote>
<h2 id="dialog-만들기">Dialog 만들기</h2>
<p><code>&lt;slot&gt;</code> 태그와 <code>::slotted</code> <code>pseudo element</code>를 이용해 외부에서 컨텐츠 영역의 <code>DOM</code>을 주입 할 수 있는 <code>custom dialog</code> 컴포넌트를 만든다.</p>
<pre><code class="language-javascript">customElements.define(
  &#39;custom-dialog&#39;,
  class extends HTMLElement {
    constructor() {
      super()
      this.attachShadow({ mode: &#39;open&#39; })
      this.shadowRoot.innerHTML = `
        &lt;style&gt;
          :host {
            display: none;
          }
          :host([open]) {
            display: initial;
          }
          #modal {
            position: absolute;
            top: 0;
            right: 0;
            bottom: 0;
            left: 0;
            background-color: black;
            opacity: 0.5;
            z-index: 1;
          }
          #dialog {
            position: absolute;
            background-color: white;
            border-radius: 6px;
            z-index: 2;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
          }
          #dialog &gt; header {
            padding: 5px;
            display: flex;
            gap: 10px;
          }
          #close-button {
            margin: auto 0;
            border: none;
            background-color: transparent;
          }
          #content {
            padding: 10px;
          }
          ::slotted([slot=title]) {
            flex: 1;
            font-size: 1rem;
            font-weight: bold;
            padding: 10px 0;
            margin: 0;
          }
        &lt;/style&gt;

        &lt;div id=&quot;modal&quot;&gt;&lt;/div&gt;
        &lt;section id=&quot;dialog&quot;&gt;
          &lt;header&gt;
            &lt;slot name=&quot;title&quot;&gt;&lt;/slot&gt;
            &lt;button id=&quot;close-button&quot;&gt;X&lt;/button&gt;
          &lt;/header&gt;
          &lt;section id=&quot;content&quot;&gt;
            &lt;slot name=&quot;content&quot;&gt;&lt;/slot&gt;
          &lt;/section&gt;
        &lt;/section&gt;
      `
    }

    connectedCallback() {
      const closeButton = this.shadowRoot.querySelector(&#39;#close-button&#39;)
      closeButton.onclick = this.close.bind(this)
    }

    open() {
      this.setAttribute(&#39;open&#39;, &#39;&#39;)
    }

    close() {
      this.removeAttribute(&#39;open&#39;)
    }
  }
)
</code></pre>
<p><code>&lt;custom-dialog&gt;</code> 컴포넌트는 <code>title</code> 과 <code>content</code> 두개의 <code>slot</code> 영역을 가지고 있다. 각 영역에 기본적으로 적용되야 할 스타일은 <code>::slotted</code> <code>pseudo-elements</code>를 통해 정의되었고 <code>open</code>과 <code>close</code> 두개의 메서드를 제공한다.</p>
</section></article><section class="style_container__X0hSU"><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-7134579063537339" data-ad-slot="5391522351" data-ad-format="auto" data-full-width-responsive="true"></ins></section><section class="PostDetail_relatedPosting__VlXXV"><h2>연관 포스팅</h2><ol class="style_container__ZNxCY"><li><h3><span>이전글 - </span>Web component - Shadow DOM</h3><a href="/web-component---shadow-dom">Web component의 핵심인 encapsulation은 어떻게 이루어질까?
Shadow DOM의 이해</a></li></ol></section><section class="PostDetail_categoryGroup___S2ib"><h2>카테고리 더보기</h2><ul class="style_container__CWY94"></ul></section><section class="PostDetail_references__EU_hH"><h2>참고</h2><ul class="PostDetail_references__EU_hH"><li><a href="https://developer.mozilla.org/en-US/docs/Web/Web_Components/Using_templates_and_slots" target="_blank" rel="noreferrer">MDN - Using templates and slots</a></li><li><a href="https://developer.mozilla.org/ko/docs/Web/HTML/Element/slot" target="_blank" rel="noreferrer">MDN - slot</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/Pseudo-elements" target="_blank" rel="noreferrer">MDN - pseudo-elements</a></li></ul></section><section class="PostDetail_utterances__jZeOm"><h2>댓글</h2><div class="style_utteranceContainer__4Lu3B"></div></section></main><aside></aside><footer class="style_footer__IKWh6"><p>ⓒ 2021. Jay Lee  all rights reserved.</p></footer></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"Web component - slot","description":"\u003cslot\u003e 태그를 이용해 커스텀 엘리먼트에 자식 엘리먼트를 주입할 수 있는 방법을 소개 합니다.\n\u003cslot\u003e 태그를 이용해 조금더 유연한 형태의 dialog 커스텀 엘리먼트를 만들기\n","fileName":"web-component-web-component---slot.md","category":"web-component","published":true,"publishedAt":"2022-08-18","thumbnailName":"c96f4eff2512178b9b4e02d5aad66827","tags":["custom dialog","custom element","dialog","slot","web component","웹 컴포넌트","커스텀 엘리먼트"],"references":[{"title":"MDN - Using templates and slots","url":"https://developer.mozilla.org/en-US/docs/Web/Web_Components/Using_templates_and_slots"},{"title":"MDN - slot","url":"https://developer.mozilla.org/ko/docs/Web/HTML/Element/slot"},{"title":"MDN - pseudo-elements","url":"https://developer.mozilla.org/en-US/docs/Web/CSS/Pseudo-elements"}],"series":{"prevPostTitle":"Web component - Shadow DOM"},"order":23},"content":"\u003ch2 id=\"table-of-contents\"\u003eTable of contents\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003e\u003ca href=\"#slot\"\u003eSlot\u003c/a\u003e\u003col\u003e\n\u003cli\u003e\u003ca href=\"#slot-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0\"\u003eSlot 사용하기\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#styling\"\u003eStyling\u003c/a\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#dialog-%EB%A7%8C%EB%93%A4%EA%B8%B0\"\u003eDialog 만들기\u003c/a\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2 id=\"slot\"\u003eSlot\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003e\u0026lt;slot\u0026gt;\u003c/code\u003e 태그는 웹 컴포넌트 내 특정 영역의 \u003ccode\u003e마크업\u003c/code\u003e을 외부로 부터 주입 받기 위해 사용되는 태그다.\u003c/p\u003e\n\u003cp\u003e예를들면 \u003ccode\u003edialog\u003c/code\u003e 컴포넌트 처럼 팝업이 나타나고 닫기 버튼을 통해 다시 팝업을 닫는 것과 같은 기능은 컴포넌트 내부에서 구현되지만 팝업의 내용을 채우기 위해서는 외부로 부터 \u003ccode\u003eDOM\u003c/code\u003e을 주입 받아야 하는데 이럴때 사용할 수 있는 태그가 \u003ccode\u003e\u0026lt;slot\u0026gt;\u003c/code\u003e이다.\u003c/p\u003e\n\u003ch3 id=\"slot-사용하기\"\u003eSlot 사용하기\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003e\u0026lt;slot\u0026gt;\u003c/code\u003e 태그를 통해 커스텀 엘리먼트의 내부로 \u003ccode\u003eDOM\u003c/code\u003e을 넣는 예제는 아래와 같다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003ecustomElements.define(\n  \u0026#39;custom-slot\u0026#39;,\n  class extends HTMLElement {\n    constructor() {\n      super()\n      this.attachShadow({ mode: \u0026#39;open\u0026#39; })\n      this.shadowRoot.innerHTML = `\n        \u0026lt;style\u0026gt;\n          #container {\n            padding: 20px 10px;\n            background-color: skyblue;\n          }\n        \u0026lt;/style\u0026gt;\n\n        \u0026lt;div id=\u0026quot;container\u0026quot;\u0026gt;\n          \u0026lt;slot\u0026gt;\u0026lt;/slot\u0026gt;\n        \u0026lt;/div\u0026gt;\n      `\n    }\n  }\n)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode class=\"language-html\"\u003e...\n\u0026lt;custom-slot\u0026gt;\n  \u0026lt;p\u0026gt;Slotted\u0026lt;/p\u0026gt;\n\u0026lt;/custom-slot\u0026gt;\n...\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003e\u0026lt;slot\u0026gt;\u003c/code\u003e은 \u003ccode\u003ename\u003c/code\u003e attribute를 통해 식별할 수 있다. 만약 \u003ccode\u003e\u0026lt;slot\u0026gt;\u003c/code\u003e 태그에 \u003ccode\u003ename\u003c/code\u003e attribute가 설정되어 있다면 외부에서 대상 \u003ccode\u003e\u0026lt;slot\u0026gt;\u003c/code\u003e을 식별 할 수 있도록 \u003ccode\u003eslot\u003c/code\u003e attribute를 통해 반드시 대상 \u003ccode\u003e\u0026lt;slot\u0026gt;\u003c/code\u003e의 \u003ccode\u003ename\u003c/code\u003e을 입력해야 한다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003ecustomElements.define(\n  \u0026#39;custom-slot\u0026#39;,\n  class extends HTMLElement {\n    constructor() {\n      super()\n      this.attachShadow({ mode: \u0026#39;open\u0026#39; })\n      this.shadowRoot.innerHTML = `\n        \u0026lt;style\u0026gt;\n          #container {\n            padding: 20px 10px;\n            background-color: skyblue;\n          }\n        \u0026lt;/style\u0026gt;\n\n        \u0026lt;div id=\u0026quot;container\u0026quot;\u0026gt;\n          \u0026lt;slot name=\u0026quot;first-slot\u0026quot;\u0026gt;\u0026lt;/slot\u0026gt;\n          \u0026lt;slot name=\u0026quot;second-slot\u0026quot;\u0026gt;\u0026lt;/slot\u0026gt;\n        \u0026lt;/div\u0026gt;\n      `\n    }\n  }\n)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode class=\"language-html\"\u003e...\n\u0026lt;custom-slot\u0026gt;\n  \u0026lt;p\u0026gt;Slotted\u0026lt;/p\u0026gt;\n  \u0026lt;p slot=\u0026quot;second-slot\u0026quot;\u0026gt;Second Slotted\u0026lt;/p\u0026gt;\n  \u0026lt;p slot=\u0026quot;first-slot\u0026quot;\u0026gt;First Slotted\u0026lt;/p\u0026gt;\n\u0026lt;/custom-slot\u0026gt;\n...\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e위 예제와 같이 \u003ccode\u003e\u0026lt;slot\u0026gt;\u003c/code\u003e을 주입하고 \u003ccode\u003ename\u003c/code\u003e, \u003ccode\u003eslot\u003c/code\u003e attribute를 설정하면 아래와 같은 형태로 화면에 출력된다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003e\u0026lt;p\u0026gt;Slotted\u0026lt;/p\u0026gt;\u003c/code\u003e는 \u003ccode\u003eslot\u003c/code\u003e attribute가 없어 대상 \u003ccode\u003e\u0026lt;slot\u0026gt;\u003c/code\u003e을 찾을 수 없기 때문에 화면에 출력되지 않음\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e\u0026lt;p slot=\u0026quot;second-slot\u0026quot;\u0026gt;Second Slotted\u0026lt;/p\u0026gt;\u003c/code\u003e과 \u003ccode\u003e\u0026lt;p slot=\u0026quot;first-slot\u0026quot;\u0026gt;First Slotted\u0026lt;/p\u0026gt;\u003c/code\u003e은 \u003ccode\u003eslot\u003c/code\u003e attribute를 통해 대상 \u003ccode\u003e\u0026lt;slot\u0026gt;\u003c/code\u003e을 찾아 화면에 출력됨\u003c/li\u003e\n\u003cli\u003e화면에 출력된 두 \u003ccode\u003e\u0026lt;p\u0026gt;\u003c/code\u003e 태그는 주입시 순서와 달리 \u003ccode\u003e\u0026lt;custom-slot\u0026gt;\u003c/code\u003e 컴포넌트가 지정한 \u003ccode\u003e\u0026lt;slot\u0026gt;\u003c/code\u003e의 위치에 따라 순서가 바뀐 상태로 출력됨\u003c/li\u003e\n\u003c/ul\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003ccode\u003e\u0026lt;slot\u0026gt;\u003c/code\u003e 태그에 \u003ccode\u003ename\u003c/code\u003e이 설정되어 있지 않다면 \u003ccode\u003e\u0026lt;slot\u0026gt;\u003c/code\u003e 태그에 주입되는 자식 요소중 \u003ccode\u003eslot\u003c/code\u003e attribute가 설정되지 않은 \u003cem\u003e모든 엘리먼트\u003c/em\u003e를 \u003ccode\u003e\u0026lt;slot\u0026gt;\u003c/code\u003e에 삽입한다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003e\u0026lt;slot\u0026gt;\u003c/code\u003e 태그에 \u003ccode\u003ename\u003c/code\u003e attribute가 설정되어 있다면 \u003ccode\u003eslot\u003c/code\u003e attribute에 \u003ccode\u003ename\u003c/code\u003e과 동일한 값을 가지고 있는 \u003cem\u003e모든 엘리먼트\u003c/em\u003e가 \u003ccode\u003e\u0026lt;slot\u0026gt;\u003c/code\u003e에 삽입 된다.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch3 id=\"styling\"\u003eStyling\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003e\u0026lt;slot\u0026gt;\u003c/code\u003e 태그를 통해 외부에서 주입 받은 엘리먼트에 대한 스타일을 정의하기 위해 \u003ccode\u003e::slotted\u003c/code\u003e \u003ca href=\"https://developer.mozilla.org/en-US/docs/Web/CSS/Pseudo-elements\"\u003epseudo-elements\u003c/a\u003e를 사용한다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003e::slotted\u003c/code\u003e를 이용한 \u003ccode\u003eCSS\u003c/code\u003e는 반드시 \u003ccode\u003eshadow DOM\u003c/code\u003e 내부에 정의해야 한다. 이렇게 정의된 \u003ccode\u003eselector\u003c/code\u003e는 \u003ccode\u003etext node\u003c/code\u003e를 제외한 \u003ccode\u003e\u0026lt;slot\u0026gt;\u003c/code\u003e 내부의 모든 엘리먼트를 대상으로 한다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003ecustomElements.define(\n  \u0026#39;custom-slot\u0026#39;,\n  class extends HTMLElement {\n    constructor() {\n      super()\n      this.attachShadow({ mode: \u0026#39;open\u0026#39; })\n      this.shadowRoot.innerHTML = `\n        \u0026lt;style\u0026gt;\n          #container {\n            padding: 20px 10px;\n            background-color: skyblue;\n          }\n          ::slotted(*) {\n            font-size: 20px;\n          }\n          ::slotted([slot=first-slot]) {\n            color: tomato;\n          }\n          ::slotted([slot=second-slot]) {\n            color: green;\n          }\n        \u0026lt;/style\u0026gt;\n\n        \u0026lt;div id=\u0026quot;container\u0026quot;\u0026gt;\n          \u0026lt;slot name=\u0026quot;first-slot\u0026quot;\u0026gt;\u0026lt;/slot\u0026gt;\n          \u0026lt;slot name=\u0026quot;second-slot\u0026quot;\u0026gt;\u0026lt;/slot\u0026gt;\n        \u0026lt;/div\u0026gt;\n      `\n    }\n  }\n)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e예제와 같은 style 정의를 통해 외부에서 전달 받은 엘리먼트에 대한 스타일을 적용할 수 있다.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003ccode\u003e[slot=second-slot]\u003c/code\u003e 에서 확인 할 수 있듯 특정 attribute를 통해 대상 엘리먼트를 \u003ccode\u003eselect\u003c/code\u003e 할 경우 외부에서 정의한 엘리먼트의 attribute를 참조한다.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch2 id=\"dialog-만들기\"\u003eDialog 만들기\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003e\u0026lt;slot\u0026gt;\u003c/code\u003e 태그와 \u003ccode\u003e::slotted\u003c/code\u003e \u003ccode\u003epseudo element\u003c/code\u003e를 이용해 외부에서 컨텐츠 영역의 \u003ccode\u003eDOM\u003c/code\u003e을 주입 할 수 있는 \u003ccode\u003ecustom dialog\u003c/code\u003e 컴포넌트를 만든다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003ecustomElements.define(\n  \u0026#39;custom-dialog\u0026#39;,\n  class extends HTMLElement {\n    constructor() {\n      super()\n      this.attachShadow({ mode: \u0026#39;open\u0026#39; })\n      this.shadowRoot.innerHTML = `\n        \u0026lt;style\u0026gt;\n          :host {\n            display: none;\n          }\n          :host([open]) {\n            display: initial;\n          }\n          #modal {\n            position: absolute;\n            top: 0;\n            right: 0;\n            bottom: 0;\n            left: 0;\n            background-color: black;\n            opacity: 0.5;\n            z-index: 1;\n          }\n          #dialog {\n            position: absolute;\n            background-color: white;\n            border-radius: 6px;\n            z-index: 2;\n            left: 50%;\n            top: 50%;\n            transform: translate(-50%, -50%);\n          }\n          #dialog \u0026gt; header {\n            padding: 5px;\n            display: flex;\n            gap: 10px;\n          }\n          #close-button {\n            margin: auto 0;\n            border: none;\n            background-color: transparent;\n          }\n          #content {\n            padding: 10px;\n          }\n          ::slotted([slot=title]) {\n            flex: 1;\n            font-size: 1rem;\n            font-weight: bold;\n            padding: 10px 0;\n            margin: 0;\n          }\n        \u0026lt;/style\u0026gt;\n\n        \u0026lt;div id=\u0026quot;modal\u0026quot;\u0026gt;\u0026lt;/div\u0026gt;\n        \u0026lt;section id=\u0026quot;dialog\u0026quot;\u0026gt;\n          \u0026lt;header\u0026gt;\n            \u0026lt;slot name=\u0026quot;title\u0026quot;\u0026gt;\u0026lt;/slot\u0026gt;\n            \u0026lt;button id=\u0026quot;close-button\u0026quot;\u0026gt;X\u0026lt;/button\u0026gt;\n          \u0026lt;/header\u0026gt;\n          \u0026lt;section id=\u0026quot;content\u0026quot;\u0026gt;\n            \u0026lt;slot name=\u0026quot;content\u0026quot;\u0026gt;\u0026lt;/slot\u0026gt;\n          \u0026lt;/section\u0026gt;\n        \u0026lt;/section\u0026gt;\n      `\n    }\n\n    connectedCallback() {\n      const closeButton = this.shadowRoot.querySelector(\u0026#39;#close-button\u0026#39;)\n      closeButton.onclick = this.close.bind(this)\n    }\n\n    open() {\n      this.setAttribute(\u0026#39;open\u0026#39;, \u0026#39;\u0026#39;)\n    }\n\n    close() {\n      this.removeAttribute(\u0026#39;open\u0026#39;)\n    }\n  }\n)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003e\u0026lt;custom-dialog\u0026gt;\u003c/code\u003e 컴포넌트는 \u003ccode\u003etitle\u003c/code\u003e 과 \u003ccode\u003econtent\u003c/code\u003e 두개의 \u003ccode\u003eslot\u003c/code\u003e 영역을 가지고 있다. 각 영역에 기본적으로 적용되야 할 스타일은 \u003ccode\u003e::slotted\u003c/code\u003e \u003ccode\u003epseudo-elements\u003c/code\u003e를 통해 정의되었고 \u003ccode\u003eopen\u003c/code\u003e과 \u003ccode\u003eclose\u003c/code\u003e 두개의 메서드를 제공한다.\u003c/p\u003e\n","postsByCategory":[{"title":"Web component - Shadow DOM","description":"Web component의 핵심인 encapsulation은 어떻게 이루어질까?\nShadow DOM의 이해","fileName":"web-component-web-component---shadow-dom.md","category":"web-component","published":true,"publishedAt":"2022-08-10","thumbnailName":"752fbf06b172dc96f8f10c87b1d91872","tags":["Shadow DOM","custom element","encapsulation","shadow","shadow tree","web component","쉐도우","쉐도우 돔","쉐도우 트리","웹 컴포넌트","은닉화","커스텀 엘리먼트"],"references":[{"title":"MDN - Composed","url":"https://developer.mozilla.org/en-US/docs/Web/API/Event/composed"},{"title":"MDN - Using shadow DOM","url":"https://developer.mozilla.org/ko/docs/Web/Web_Components/Using_shadow_DOM"}],"series":{"prevPostTitle":"Web component - custom element","nextPostTitle":"Web component - slot"},"order":22},{"title":"Web component - custom element","description":"웹 컴포넌트로 만드는 나만의 custom element","fileName":"web-component-web-component---custom-element.md","category":"web-component","published":true,"publishedAt":"2022-07-31","thumbnailName":"1b85d15d3e19b99e3d6350d8b69cc39a","tags":["Shadow DOM","shadow"],"references":[{"title":"Custom element naming convention","url":"https://html.spec.whatwg.org/#valid-custom-element-name"},{"title":"WebComponent org","url":"https://www.webcomponents.org/"},{"title":"https://web.dev/custom-elements-v1/#custom-element-reactions","url":"https://web.dev/custom-elements-v1/#custom-element-reactions"}],"series":{"nextPostTitle":"Web component - Shadow DOM"},"order":18}],"enableContentExplorer":true},"__N_SSG":true},"page":"/[title]","query":{"title":"web-component---slot"},"buildId":"4WD65o-815mDn_Wz8OGpu","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>