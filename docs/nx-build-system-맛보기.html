<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta name="viewport" content="width=device-width" />
    <meta charset="utf-8" />
    <link rel="canonical" href="https://code-logs.github.io/nx-build-system-맛보기" />
    <link rel="apple-touch-icon" href="/icons/icon-192x-192.png" />
    <link rel="manifest" href="/manifest.json" />
    <meta name="theme-color" content="#fff" />
    <meta property="og:type" content="website" />
    <meta property="og:site_name" content="Code Logs" />
    <meta name="author" content="Jay Lee" />
    <meta
      name="keyword"
      content="build, build system, monorepo, nx, 모노리포, 빌드, 빌드 시스템, Nx build system 맛보기, Nx build system을 이용한 Monorepo 구성하기, infrastructure"
    />
    <meta name="description" content="Nx build system을 이용한 Monorepo 구성하기" />
    <meta property="og:description" content="Nx build system을 이용한 Monorepo 구성하기" />
    <meta property="og:title" content="Nx build system 맛보기 | Code Logs" />
    <meta property="og:url" content="https://code-logs.github.io/nx-build-system-맛보기" />
    <meta property="og:image" content="/assets/images/monorepo-with-nx.png" />
    <title>Nx build system 맛보기 | Code Logs</title>
    <meta name="next-head-count" content="16" />
    <link rel="preload" href="/_next/static/css/e67f92fc328a3d57.css" as="style" />
    <link rel="stylesheet" href="/_next/static/css/e67f92fc328a3d57.css" data-n-g="" />
    <link rel="preload" href="/_next/static/css/b5e8827db00c1c2b.css" as="style" />
    <link rel="stylesheet" href="/_next/static/css/b5e8827db00c1c2b.css" data-n-p="" />
    <noscript data-n-css=""></noscript>
    <script defer="" nomodule="" src="/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script>
    <script src="/_next/static/chunks/webpack-2e51481b1d484a05.js" defer=""></script>
    <script src="/_next/static/chunks/framework-5f4595e5518b5600.js" defer=""></script>
    <script src="/_next/static/chunks/main-a4d9e436b9a532ca.js" defer=""></script>
    <script src="/_next/static/chunks/pages/_app-302687a3b3726e89.js" defer=""></script>
    <script src="/_next/static/chunks/294-6603e2d70ff7953e.js" defer=""></script>
    <script src="/_next/static/chunks/377-2cd7ec4f035eaf33.js" defer=""></script>
    <script src="/_next/static/chunks/pages/%5Btitle%5D-637c57b2312d7084.js" defer=""></script>
    <script src="/_next/static/skUPIFWrM9tb05QUQJtZ7/_buildManifest.js" defer=""></script>
    <script src="/_next/static/skUPIFWrM9tb05QUQJtZ7/_ssgManifest.js" defer=""></script>
    <script src="/_next/static/skUPIFWrM9tb05QUQJtZ7/_middlewareManifest.js" defer=""></script>
  </head>
  <body>
    <div id="__next" data-reactroot="">
      <header class="Header_header__RW35m">
        <p class="Header_title__GPS8b">Code Logs</p>
        <ul class="Header_socialIcons__CBf_s">
          <li>
            <a href="https://github.com/possible819" target="_blank" rel="noreferrer" aria-label="My Github"
              ><style data-emotion="css vubbuv">
                .css-vubbuv {
                  -webkit-user-select: none;
                  -moz-user-select: none;
                  -ms-user-select: none;
                  user-select: none;
                  width: 1em;
                  height: 1em;
                  display: inline-block;
                  fill: currentColor;
                  -webkit-flex-shrink: 0;
                  -ms-flex-negative: 0;
                  flex-shrink: 0;
                  -webkit-transition: fill 200ms cubic-bezier(0.4, 0, 0.2, 1) 0ms;
                  transition: fill 200ms cubic-bezier(0.4, 0, 0.2, 1) 0ms;
                  font-size: 1.5rem;
                }</style
              ><svg
                class="MuiSvgIcon-root MuiSvgIcon-fontSizeMedium css-vubbuv"
                focusable="false"
                aria-hidden="true"
                viewBox="0 0 24 24"
                data-testid="GitHubIcon"
              >
                <path
                  d="M12 1.27a11 11 0 00-3.48 21.46c.55.09.73-.28.73-.55v-1.84c-3.03.64-3.67-1.46-3.67-1.46-.55-1.29-1.28-1.65-1.28-1.65-.92-.65.1-.65.1-.65 1.1 0 1.73 1.1 1.73 1.1.92 1.65 2.57 1.2 3.21.92a2 2 0 01.64-1.47c-2.47-.27-5.04-1.19-5.04-5.5 0-1.1.46-2.1 1.2-2.84a3.76 3.76 0 010-2.93s.91-.28 3.11 1.1c1.8-.49 3.7-.49 5.5 0 2.1-1.38 3.02-1.1 3.02-1.1a3.76 3.76 0 010 2.93c.83.74 1.2 1.74 1.2 2.94 0 4.21-2.57 5.13-5.04 5.4.45.37.82.92.82 2.02v3.03c0 .27.1.64.73.55A11 11 0 0012 1.27"
                ></path></svg
            ></a>
          </li>
        </ul>
        <nav class="NavBar_navBar__akqA3">
          <ul>
            <li><a class="MarkedAnchor_anchor__QCmkL" href="https://code-logs.github.io/">Home</a></li>
            <li><a class="MarkedAnchor_anchor__QCmkL" href="https://code-logs.github.io/posts/1">Posts</a></li>
            <li><a class="MarkedAnchor_anchor__QCmkL" href="https://code-logs.github.io/about">About</a></li>
          </ul>
        </nav>
      </header>
      <main>
        <article class="PostDetail_container__Ma_26">
          <p class="PostDetail_publishedAt__7GOQm"><span></span></p>
          <section class="PostDetail_thumbnailWrapper__oALCg">
            <img src="/assets/images/monorepo-with-nx.png" alt="Nx build system을 이용한 Monorepo 구성하기" />
          </section>
          <section>
            <h1>Nx build system 맛보기</h1>
            <p class="PostDetail_description__l6wHC">Nx build system을 이용한 Monorepo 구성하기</p>
          </section>
          <section>
            <h2 id="table-of-contents">Table of contents</h2>
            <ol>
              <li><a href="#monorepo">Monorepo</a></li>
              <li><a href="#nx">Nx</a></li>
              <li>
                <a href="#nx-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-%EA%B5%AC%EC%84%B1%ED%95%98%EA%B8%B0">Nx 프로젝트 구성하기</a>
                <ol>
                  <li><a href="#%EC%83%88%EB%A1%9C%EC%9A%B4-workspace-%EC%83%9D%EC%84%B1">새로운 Workspace 생성</a></li>
                  <li><a href="#npm-package-%EC%83%9D%EC%84%B1">NPM Package 생성</a></li>
                  <li><a href="#package-%EB%82%B4%EB%B6%80-script-%EC%8B%A4%ED%96%89">Package 내부 script 실행</a></li>
                  <li><a href="#%EC%97%AC%EB%9F%AC-package-%EB%82%B4%EB%B6%80-script-%EC%8B%A4%ED%96%89">여러 Package 내부 script 실행</a></li>
                  <li><a href="#package%EA%B0%84-%EC%B0%B8%EC%A1%B0-%EC%84%A4%EC%A0%95">Package간 참조 설정</a></li>
                  <li><a href="#nx-graph">NX Graph</a></li>
                </ol>
              </li>
              <li>
                <a href="#generator">Generator</a>
                <ol>
                  <li><a href="#typescript-library-generator">Typescript Library Generator</a></li>
                  <li><a href="#react-library-generator">React Library Generator</a></li>
                </ol>
              </li>
              <li><a href="#%EB%A7%88%EC%B9%98%EB%A9%B0">마치며</a></li>
            </ol>
            <h2 id="monorepo">Monorepo</h2>
            <p>
              <code>Monorepo</code>는 방대한 양의 프로젝트 코드를 단일 Repository에서 관리하는 전략이다. 개인적으로 4년 전쯤 (2022년 기준) 처음 도입해서
              사용했는데, 프론트엔드 개발자로서 컴퍼넌트 개발을 많이했고 각 컴퍼넌트들이 분산된 저장소에서 관리됨으로 발생하는 문제점들을 획기적으로 개선하는
              경험을 했다.
            </p>
            <p>그 이후 라이브러리 성향의 프로젝트를 구성할 경우에는 <code>Monorepo</code>를 필수적으로 체택하게 되었다.</p>
            <p>
              처음 <code>Monorepo</code>를 도입한 뒤 감동은 말 그대로 <code>신세계</code>를 보는 듯 했으나 이것도 사실 20년도
              <a href="https://en.wikipedia.org/wiki/Monorepo">&quot;As of 2017, this software engineering practice was over two decades old&quot; - wiki</a>
              훌쩍 넘긴 것이라 하니 여전히 공부해야 할 것들이 넘쳐난다는 생각이 든다
            </p>
            <h2 id="nx">Nx</h2>
            <p>
              나에게 익숙한 <code>Monorepo</code> 구성은 <code>lerna</code>를 이용한 구성이였는데 이번 포스팅에서는 <code>Monorepo</code> 구성뿐 아니라 프로젝트
              빌드의 전반적인 프로세스를 돕는 <code>Nx</code> 빌드 시스템을 살펴본다.
            </p>
            <div style="text-align: center"><a href="https://nx.dev" target="_blank">Nx 홈페이지 바로가기</a></div>

            <p><code>Nx</code>는 <code>Nrwl (Narwhal Technologies Inc)</code>에 의해 만들어진 시스템이다.</p>
            <p>
              <code>Nrwl</code>은 Google의 Angular 팀 멤버에 의해 만들어진 법인으로 세계 여러 국가의 IT 컨설팅 외 다수의 작업을 하는 것으로 보인다.
              <a href="https://nrwl.io/">Nrwl</a>
            </p>
            <h2 id="nx-프로젝트-구성하기">Nx 프로젝트 구성하기</h2>
            <h3 id="새로운-workspace-생성">새로운 Workspace 생성</h3>
            <p>아래의 커맨드를 통해 새로운 workspace를 생성한다</p>
            <pre><code class="language-sh">npx create-nx-workspace@latest --preset=core
</code></pre>
            <blockquote>
              <p><code>--preset=core</code> 옵션은 npm 패키지를 위한 빈 (yarn workspace와 유사한) 워크스페이스를 생성한다.</p>
              <p>상기 옵션 없이 커맨드를 실행 할 경우 몇가지 옵션을 선택 할 수 있고 구성하려는 프로젝트의 성향에 맞게 preset을 선택 할 수 있다.</p>
            </blockquote>
            <p>커맨드를 실행하면 디렉토리를 생성하고 필요한 설정이 담긴 파일들이 만들어진다.</p>
            <p>생성된 파일중 <code>nx.json</code> 파일을 통해 <code>nx</code>의 설정을 진행 할 수 있다.</p>
            <h3 id="npm-package-생성">NPM Package 생성</h3>
            <p>아래의 커맨드를 통해 새로운 패키지(sample)를 workspace에 추가 할 수 있다.</p>
            <pre><code class="language-sh">nx g npm-package sample
</code></pre>
            <p>이렇게 생성된 패키지의 <code>package.json</code> 파일을 열어 보면</p>
            <pre><code class="language-json">{
  &quot;name&quot;: &quot;@nx-sample-workspace/sample&quot;,
  &quot;version&quot;: &quot;0.0.0&quot;,
  &quot;scripts&quot;: {
    &quot;test&quot;: &quot;node index.js&quot;
  }
}
</code></pre>
            <p>
              패키지의 명칭이 @nx-sample-worspace로 설정되어 있다. 처음 Workspace를 생성할 때 입력이 organization으로 결정되니 Workspace 생성 시점에 이를
              고려해야한다.
            </p>
            <h3 id="package-내부-script-실행">Package 내부 script 실행</h3>
            <p>패키지 내부에 정의된 script를 실행하기 위해 아래의 커맨드를 입력한다.</p>
            <pre><code class="language-sh">nx ${script} ${package}
</code></pre>
            <blockquote>
              <p><code>yarn</code>과 <code>lerna</code>로 구성한 monorepo에서는</p>
              <p><code>yarn workspace ${package} ${script}</code></p>
              <p>
                형식으로 스크립트를 실행 할 수 있는데 <code>${package}</code>를 <code>@nx-sample-workspace/sample</code>과 같이 패키지의 이름 전체를 입력해야
                한다.
              </p>
            </blockquote>
            <h3 id="여러-package-내부-script-실행">여러 Package 내부 script 실행</h3>
            <p>빌드를 실행하거나 테스트 커맨드를 실행하는 등 전체 또는 복수의 package를 대상으로 script를 실행하려면 아래의 커맨드를 입력한다.</p>
            <pre><code class="language-sh">nx run-many --target=${script} --all
</code></pre>
            <blockquote>
              <p>특정 패키지를 대상으로 스크립트를 실행하려면 <code>--all</code> 옵션 대신 <code>--projects=package1,package2</code> 옵션을 추가한다.</p>
            </blockquote>
            <p>이렇게 실행한 scripts는 비동기적으로 평행하게 수행된다.</p>
            <h3 id="package간-참조-설정">Package간 참조 설정</h3>
            <p>
              <code>Monorepo</code> 구성 내부에서 컴퍼넌트를 개발하다 보면 종종 컴퍼넌트간의 참조가 발생한다. <code>Monorepo</code>의 도입을 통해 얻을 수 있는
              장점중 하나가 참조하고 있는 컴퍼넌트의 완전한 <code>publishing</code> 없이 변경 사항을 적용하고 테스트 할 수 있다는 것이기도 하다.
            </p>
            <blockquote>
              <p>
                만약 A 모듈이 B 모듈을 참조하고 있을때 이 둘이 각기 별도의 Repository로 구성되어 있을 경우 A 모듈을 수정하던중 B 모듈의 문제점을 발견하게 되면
              </p>
              <p>
                <code>B 모듈을 수정 -&gt; B 모듈 Publishing -&gt; A 모듈의 디펜던시 최신화 -&gt; A 모듈 작업 재개</code>의 순으로 작업을 하게 되는데 (<code
                  >yarn link</code
                >를 사용하는 방법도 있지만) <code>monorepo</code> 내부에서 패키지간의 참조는 별도의 publishing 없이도 최신화된 로컬 소스를 참조 할 수 있다.
              </p>
            </blockquote>
            <p>패키지간의 참조 설정을 위해 또 다른 패키지를 생성한다.</p>
            <pre><code class="language-sh">nx g npm-package rely-on-sample
</code></pre>
            <p><code>packages/rely-on-sample/index.js</code>를 열어 <code>sample</code> 패키지를 참조하도록 아래와 같이 수정한다.</p>
            <pre><code class="language-js">// index.js
import &#39;@nx-sample-workspace/sample&#39;

console.log(&#39;Hello World&#39;)
</code></pre>
            <p>참조 대상을 불러오기 위해 <code>rely-on-sample</code> 패키지의 <code>package.json</code>에 디펜던시를 추가한다.</p>
            <blockquote>
              <p><code>@nx-sample-worspace/sample</code> 패키지는 아직 publishing 되지 않은 상태이기 때문에 커맨드를 통해 추가 할 수 없다.</p>
              <p>직접 <code>package.json</code> 파일을 수정한 뒤 <code>yarn install</code> 또는 <code>npm install</code>을 통해 패키지를 최신화해야 한다.</p>
            </blockquote>
            <h2 id="nx-graph">NX Graph</h2>
            <p>아래의 커맨드를 실행하면 헌재 Workspace에 존재하는 패키지간의 상관관계를 볼 수 있는 dashboard를 실행 할 수 있다.</p>
            <pre><code class="language-sh">nx graph
</code></pre>
            <h2 id="generator">Generator</h2>
            <p>
              <code>Nx</code>는 Generator를 이용해서 다양한 환경의 라이브러리/애플리케이션을 스카폴딩 할 수 있도록 돕는다. 몇가지 유용한 Generator를 살펴본다.
            </p>
            <h3 id="typescript-library-generator">Typescript Library Generator</h3>
            <p>
              타입스크립트 기반의 라이브러리 패키지를 생성하기 위해 사용 할 수 있는 <code>Generator</code>로 <code>jest</code>, <code>lint</code>와 빌드환경을
              모두 갖춘 패키지를 생성한다.
            </p>
            <p><code>devDependency</code>로 <code>@nrwl/js</code> 패키지를 설치한다.</p>
            <p>설치가 완료되면 아래 커맨드를 통해 타입스크립트 기반의 라이브러리를 생성한다.</p>
            <pre><code class="language-sh">nx g @nrwl/js:library ${library name}
</code></pre>
            <blockquote>
              <p>
                Typescript 기반의 라이브러리를 생성하는데 <code>@nrwl/js</code>라는 패키지를 설치하는 것은 nx의 generator가 기본적으로 ts를 사용하도록 설정되어
                있기 때문이다.
              </p>
              <p>
                실제 <code>@nrwl/js</code> 패키지는 타입스크립트 기반의 라이브러를 생성하는 것이 아닌 라이브러리 성향의 패키지 그 자체를 의미하며
                <code>--js=false</code> 옵션이 default 값으로 설정되어 있다.
              </p>
              <p>다시 말해 Javascript 베이스의 라이브러리를 생성하고 싶다면 아래의 커맨드를 입력해야 한다.</p>
              <p>`nx g @nrwl/js:library --js=false</p>
            </blockquote>
            <blockquote>
              <p><code>--buildable 옵션</code></p>
              <p>상기 커맨드를 통해 생성된 라이브러리는 기본적으로 <code>빌드 할 수 없는</code> 형태이다.</p>
              <p><code>--buildable=true</code> 옵션을 추가하는 것을 통해 <code>빌드 할 수 있는</code> 형태의 패키지를 생성할 수 있다..</p>
            </blockquote>
            <p>
              그 외에도 라이브러리를 생성하며 전달할 수 있는 옵션들이 다수 있으니 공식 문서를 참조하면 조금 더 다채로운 형태의 라이브러리를 생성 할 수 있다.
            </p>
            <blockquote>
              <p><code>--compiler 옵션</code></p>
              <p>
                타입스크립트 라이브러리를 생성하며 <code>--compiler=swc</code> 옵션을 추가하면 <code>tsc</code> 대신 <code>swc</code>를 컴파일러로 설정 할 수
                있다.
              </p>
            </blockquote>
            <blockquote>
              <p>SWC (standard for Speedy Web Compiler)</p>
              <p><code>Rust</code> 기반의 웹컴파일러로 기존의 <code>babel</code>과 같은 transpiler에 비해 월등한 성능을 보임.</p>
              <p>
                <code>SWC</code>는 다른 트랜스파일러와 유사하게 <code>typescript</code>의 type checking을 수행하지 않기 때문에 사용하더라도 <code>tsc</code>를
                통해 타입체크를 별도로 수행해야한다. 특히 라이브러리 프로젝트의 경우 다른 프로젝트에서 라이브러리의 타입 정보를 체크하기 위해 <code>tsc</code>를
                통해 타입선언을 해주는 것이 좋겠다.
              </p>
            </blockquote>
            <h3 id="react-library-generator">React Library Generator</h3>
            <p>
              리액트 라이브러리 패키지를 생성하기 위해 <code>@nrwl/react</code> 디펜던시를 설치한다. 패키지 생성 명령은 앞서 살펴본 타입스크립트의 경우와 동일한
              형식을 갖는다.
            </p>
            <pre><code class="language-sh">nx g @nrwl/react:library
</code></pre>
            <p>
              타입스크립트 생성과 유사한 <code>linting</code>, <code>testing</code> 환경이 갖춰진 패키지를 생성해낸다. React Library도 기본적으로 타입스크립트
              베이스로 생성되며 만약 자바스크립트 베이스의 React 라이브러리를 생성하고자 한다면 <code>--js=false</code> 옵션을 추가해야 한다.
            </p>
            <h2 id="마치며">마치며</h2>
            <p>
              <code>nx</code>는 패키지를 개발과정의 <code>workflow</code>를 관리하는 툴에 가깝다. <code>lerna</code>와 유사한 기능을 제공할거라고 기대한 (물론
              대부분의 기능을 nx도 제공하지만 module publishing이나 versioning은 lerna가 나에게는 더 수월하다는 생각이든다.) 것과는 약간 다른 성격을 가지고
              있었다.
            </p>
            <p>
              다양한 코드베이스의 프로젝트들을 한군데에서 관리하고 일하는 것 자체의 효율을 높이기 위한 툴이라는 생각이 들었다 (프론트엔드 백엔드를 넘나드는
              Scaffolding과 필요한 대부분의 툴이 inject 된 상태의 디렉토리 구조등)
            </p>
            <p>
              <a href="https://stackoverflow.com/questions/67000436/the-difference-between-nx-and-lerna-monorepos">직접 느꼈으나 말로 표현 할 수 없던 이야기</a
              >를 누군가 아주 잘 정리해준 글이 있어 첨부한다.
            </p>
          </section>
        </article>
        <section class="PostDetail_relatedPosting__VlXXV">
          <h2>연관 포스팅</h2>
          <dl class="PostSeriesLink_container__jtRUh">
            <a href="https://code-logs.github.io/nx-build-system-%EB%A7%9B%EB%B3%B4%EA%B8%B0"
              ><dt>
                <span>이전글 - </span>
                <h3>Nx build system 맛보기</h3>
              </dt>
              <dd>Nx build system을 이용한 Monorepo 구성하기</dd></a
            ><a href="https://code-logs.github.io/yarn-berry%EB%A1%9C-%EA%B5%AC%EC%84%B1%ED%95%98%EB%8A%94-monorepo"
              ><dt>
                <span>다음글 - </span>
                <h3>yarn berry로 구성하는 monorepo</h3>
              </dt>
              <dd>yarn berry와 yarn workspaces를 이용해 monorepo 구성 - 환경 설정, 샘플 프로젝트</dd></a
            >
          </dl>
        </section>
        <section class="PostDetail_categoryGroup___S2ib">
          <h2>카테고리 더보기</h2>
          <dl class="CategoryPostGroup_container__MDFUe"></dl>
        </section>
        <section class="PostDetail_utterances__jZeOm">
          <h2>댓글</h2>
          <div></div>
        </section>
        <ins
          class="adsbygoogle"
          style="display: block"
          data-ad-client="ca-pub-7134579063537339"
          data-ad-slot="5391522351"
          data-ad-format="auto"
          data-full-width-responsive="true"
        ></ins>
      </main>
      <aside></aside>
      <footer class="Footer_footer__GLL0J"><p>ⓒ 2021. Jay Lee all rights reserved.</p></footer>
    </div>
    <script id="__NEXT_DATA__" type="application/json">
      {
        "props": {
          "pageProps": {
            "post": {
              "title": "Nx build system 맛보기",
              "description": "Nx build system을 이용한 Monorepo 구성하기",
              "fileName": "monorepo-with-nx.md",
              "category": "infrastructure",
              "published": true,
              "publishedAt": "2022-02-12",
              "thumbnailName": "monorepo-with-nx.png",
              "tags": ["build", "build system", "monorepo", "nx", "모노리포", "빌드", "빌드 시스템"],
              "series": { "prevPostTitle": "Nx build system 맛보기", "nextPostTitle": "yarn berry로 구성하는 monorepo" }
            },
            "content": "\u003ch2 id=\"table-of-contents\"\u003eTable of contents\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003e\u003ca href=\"#monorepo\"\u003eMonorepo\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#nx\"\u003eNx\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#nx-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-%EA%B5%AC%EC%84%B1%ED%95%98%EA%B8%B0\"\u003eNx 프로젝트 구성하기\u003c/a\u003e\u003col\u003e\n\u003cli\u003e\u003ca href=\"#%EC%83%88%EB%A1%9C%EC%9A%B4-workspace-%EC%83%9D%EC%84%B1\"\u003e새로운 Workspace 생성\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#npm-package-%EC%83%9D%EC%84%B1\"\u003eNPM Package 생성\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#package-%EB%82%B4%EB%B6%80-script-%EC%8B%A4%ED%96%89\"\u003ePackage 내부 script 실행\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#%EC%97%AC%EB%9F%AC-package-%EB%82%B4%EB%B6%80-script-%EC%8B%A4%ED%96%89\"\u003e여러 Package 내부 script 실행\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#package%EA%B0%84-%EC%B0%B8%EC%A1%B0-%EC%84%A4%EC%A0%95\"\u003ePackage간 참조 설정\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#nx-graph\"\u003eNX Graph\u003c/a\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#generator\"\u003eGenerator\u003c/a\u003e\u003col\u003e\n\u003cli\u003e\u003ca href=\"#typescript-library-generator\"\u003eTypescript Library Generator\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#react-library-generator\"\u003eReact Library Generator\u003c/a\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#%EB%A7%88%EC%B9%98%EB%A9%B0\"\u003e마치며\u003c/a\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2 id=\"monorepo\"\u003eMonorepo\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003eMonorepo\u003c/code\u003e는 방대한 양의 프로젝트 코드를 단일 Repository에서 관리하는 전략이다. 개인적으로 4년 전쯤 (2022년 기준) 처음 도입해서 사용했는데, 프론트엔드 개발자로서 컴퍼넌트 개발을 많이했고 각 컴퍼넌트들이 분산된 저장소에서 관리됨으로 발생하는 문제점들을 획기적으로 개선하는 경험을 했다.\u003c/p\u003e\n\u003cp\u003e그 이후 라이브러리 성향의 프로젝트를 구성할 경우에는 \u003ccode\u003eMonorepo\u003c/code\u003e를 필수적으로 체택하게 되었다.\u003c/p\u003e\n\u003cp\u003e처음 \u003ccode\u003eMonorepo\u003c/code\u003e를 도입한 뒤 감동은 말 그대로 \u003ccode\u003e신세계\u003c/code\u003e를 보는 듯 했으나 이것도 사실 20년도 \u003ca href=\"https://en.wikipedia.org/wiki/Monorepo\"\u003e\u0026quot;As of 2017, this software engineering practice was over two decades old\u0026quot; - wiki\u003c/a\u003e 훌쩍 넘긴 것이라 하니 여전히 공부해야 할 것들이 넘쳐난다는 생각이 든다\u003c/p\u003e\n\u003ch2 id=\"nx\"\u003eNx\u003c/h2\u003e\n\u003cp\u003e나에게 익숙한 \u003ccode\u003eMonorepo\u003c/code\u003e 구성은 \u003ccode\u003elerna\u003c/code\u003e를 이용한 구성이였는데\n이번 포스팅에서는 \u003ccode\u003eMonorepo\u003c/code\u003e 구성뿐 아니라 프로젝트 빌드의 전반적인 프로세스를 돕는 \u003ccode\u003eNx\u003c/code\u003e 빌드 시스템을 살펴본다.\u003c/p\u003e\n\u003cdiv style=\"text-align:center\"\u003e\u003ca href=\"https://nx.dev\" target=\"_blank\"\u003eNx 홈페이지 바로가기\u003c/a\u003e\u003c/div\u003e\n\n\u003cp\u003e\u003ccode\u003eNx\u003c/code\u003e는 \u003ccode\u003eNrwl (Narwhal Technologies Inc)\u003c/code\u003e에 의해 만들어진 시스템이다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eNrwl\u003c/code\u003e은 Google의 Angular 팀 멤버에 의해 만들어진 법인으로 세계 여러 국가의 IT 컨설팅 외 다수의 작업을 하는 것으로 보인다. \u003ca href=\"https://nrwl.io/\"\u003eNrwl\u003c/a\u003e\u003c/p\u003e\n\u003ch2 id=\"nx-프로젝트-구성하기\"\u003eNx 프로젝트 구성하기\u003c/h2\u003e\n\u003ch3 id=\"새로운-workspace-생성\"\u003e새로운 Workspace 생성\u003c/h3\u003e\n\u003cp\u003e아래의 커맨드를 통해 새로운 workspace를 생성한다\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-sh\"\u003enpx create-nx-workspace@latest --preset=core\n\u003c/code\u003e\u003c/pre\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003ccode\u003e--preset=core\u003c/code\u003e 옵션은 npm 패키지를 위한 빈 (yarn workspace와 유사한) 워크스페이스를 생성한다.\u003c/p\u003e\n\u003cp\u003e상기 옵션 없이 커맨드를 실행 할 경우 몇가지 옵션을 선택 할 수 있고 구성하려는 프로젝트의 성향에 맞게 preset을 선택 할 수 있다.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e커맨드를 실행하면 디렉토리를 생성하고 필요한 설정이 담긴 파일들이 만들어진다.\u003c/p\u003e\n\u003cp\u003e생성된 파일중 \u003ccode\u003enx.json\u003c/code\u003e 파일을 통해 \u003ccode\u003enx\u003c/code\u003e의 설정을 진행 할 수 있다.\u003c/p\u003e\n\u003ch3 id=\"npm-package-생성\"\u003eNPM Package 생성\u003c/h3\u003e\n\u003cp\u003e아래의 커맨드를 통해 새로운 패키지(sample)를 workspace에 추가 할 수 있다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-sh\"\u003enx g npm-package sample\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이렇게 생성된 패키지의 \u003ccode\u003epackage.json\u003c/code\u003e 파일을 열어 보면\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-json\"\u003e{\n  \u0026quot;name\u0026quot;: \u0026quot;@nx-sample-workspace/sample\u0026quot;,\n  \u0026quot;version\u0026quot;: \u0026quot;0.0.0\u0026quot;,\n  \u0026quot;scripts\u0026quot;: {\n    \u0026quot;test\u0026quot;: \u0026quot;node index.js\u0026quot;\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e패키지의 명칭이 @nx-sample-worspace로 설정되어 있다. 처음 Workspace를 생성할 때 입력이 organization으로 결정되니 Workspace 생성 시점에 이를 고려해야한다.\u003c/p\u003e\n\u003ch3 id=\"package-내부-script-실행\"\u003ePackage 내부 script 실행\u003c/h3\u003e\n\u003cp\u003e패키지 내부에 정의된 script를 실행하기 위해 아래의 커맨드를 입력한다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-sh\"\u003enx ${script} ${package}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003ccode\u003eyarn\u003c/code\u003e과 \u003ccode\u003elerna\u003c/code\u003e로 구성한 monorepo에서는\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eyarn workspace ${package} ${script}\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e형식으로 스크립트를 실행 할 수 있는데 \u003ccode\u003e${package}\u003c/code\u003e를 \u003ccode\u003e@nx-sample-workspace/sample\u003c/code\u003e과 같이 패키지의 이름 전체를 입력해야 한다.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch3 id=\"여러-package-내부-script-실행\"\u003e여러 Package 내부 script 실행\u003c/h3\u003e\n\u003cp\u003e빌드를 실행하거나 테스트 커맨드를 실행하는 등 전체 또는 복수의 package를 대상으로 script를 실행하려면 아래의 커맨드를 입력한다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-sh\"\u003enx run-many --target=${script} --all\n\u003c/code\u003e\u003c/pre\u003e\n\u003cblockquote\u003e\n\u003cp\u003e특정 패키지를 대상으로 스크립트를 실행하려면 \u003ccode\u003e--all\u003c/code\u003e 옵션 대신 \u003ccode\u003e--projects=package1,package2\u003c/code\u003e 옵션을 추가한다.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e이렇게 실행한 scripts는 비동기적으로 평행하게 수행된다.\u003c/p\u003e\n\u003ch3 id=\"package간-참조-설정\"\u003ePackage간 참조 설정\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003eMonorepo\u003c/code\u003e 구성 내부에서 컴퍼넌트를 개발하다 보면 종종 컴퍼넌트간의 참조가 발생한다. \u003ccode\u003eMonorepo\u003c/code\u003e의 도입을 통해 얻을 수 있는 장점중 하나가 참조하고 있는 컴퍼넌트의 완전한 \u003ccode\u003epublishing\u003c/code\u003e 없이 변경 사항을 적용하고 테스트 할 수 있다는 것이기도 하다.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e만약 A 모듈이 B 모듈을 참조하고 있을때 이 둘이 각기 별도의 Repository로 구성되어 있을 경우 A 모듈을 수정하던중 B 모듈의 문제점을 발견하게 되면\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eB 모듈을 수정 -\u0026gt; B 모듈 Publishing -\u0026gt; A 모듈의 디펜던시 최신화 -\u0026gt; A 모듈 작업 재개\u003c/code\u003e의 순으로 작업을 하게 되는데 (\u003ccode\u003eyarn link\u003c/code\u003e를 사용하는 방법도 있지만) \u003ccode\u003emonorepo\u003c/code\u003e 내부에서 패키지간의 참조는 별도의 publishing 없이도 최신화된 로컬 소스를 참조 할 수 있다.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e패키지간의 참조 설정을 위해 또 다른 패키지를 생성한다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-sh\"\u003enx g npm-package rely-on-sample\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003epackages/rely-on-sample/index.js\u003c/code\u003e를 열어 \u003ccode\u003esample\u003c/code\u003e 패키지를 참조하도록 아래와 같이 수정한다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-js\"\u003e// index.js\nimport \u0026#39;@nx-sample-workspace/sample\u0026#39;\n\nconsole.log(\u0026#39;Hello World\u0026#39;)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e참조 대상을 불러오기 위해 \u003ccode\u003erely-on-sample\u003c/code\u003e 패키지의 \u003ccode\u003epackage.json\u003c/code\u003e에 디펜던시를 추가한다.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003ccode\u003e@nx-sample-worspace/sample\u003c/code\u003e 패키지는 아직 publishing 되지 않은 상태이기 때문에 커맨드를 통해 추가 할 수 없다.\u003c/p\u003e\n\u003cp\u003e직접 \u003ccode\u003epackage.json\u003c/code\u003e 파일을 수정한 뒤 \u003ccode\u003eyarn install\u003c/code\u003e 또는 \u003ccode\u003enpm install\u003c/code\u003e을 통해 패키지를 최신화해야 한다.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch2 id=\"nx-graph\"\u003eNX Graph\u003c/h2\u003e\n\u003cp\u003e아래의 커맨드를 실행하면 헌재 Workspace에 존재하는 패키지간의 상관관계를 볼 수 있는 dashboard를 실행 할 수 있다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-sh\"\u003enx graph\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"generator\"\u003eGenerator\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003eNx\u003c/code\u003e는 Generator를 이용해서 다양한 환경의 라이브러리/애플리케이션을 스카폴딩 할 수 있도록 돕는다.\n몇가지 유용한 Generator를 살펴본다.\u003c/p\u003e\n\u003ch3 id=\"typescript-library-generator\"\u003eTypescript Library Generator\u003c/h3\u003e\n\u003cp\u003e타입스크립트 기반의 라이브러리 패키지를 생성하기 위해 사용 할 수 있는 \u003ccode\u003eGenerator\u003c/code\u003e로 \u003ccode\u003ejest\u003c/code\u003e, \u003ccode\u003elint\u003c/code\u003e와 빌드환경을 모두 갖춘 패키지를 생성한다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003edevDependency\u003c/code\u003e로 \u003ccode\u003e@nrwl/js\u003c/code\u003e 패키지를 설치한다.\u003c/p\u003e\n\u003cp\u003e설치가 완료되면 아래 커맨드를 통해 타입스크립트 기반의 라이브러리를 생성한다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-sh\"\u003enx g @nrwl/js:library ${library name}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cblockquote\u003e\n\u003cp\u003eTypescript 기반의 라이브러리를 생성하는데 \u003ccode\u003e@nrwl/js\u003c/code\u003e라는 패키지를 설치하는 것은 nx의 generator가 기본적으로 ts를 사용하도록 설정되어 있기 때문이다.\u003c/p\u003e\n\u003cp\u003e실제 \u003ccode\u003e@nrwl/js\u003c/code\u003e 패키지는 타입스크립트 기반의 라이브러를 생성하는 것이 아닌 라이브러리 성향의 패키지 그 자체를 의미하며 \u003ccode\u003e--js=false\u003c/code\u003e 옵션이 default 값으로 설정되어 있다.\u003c/p\u003e\n\u003cp\u003e다시 말해 Javascript 베이스의 라이브러리를 생성하고 싶다면 아래의 커맨드를 입력해야 한다.\u003c/p\u003e\n\u003cp\u003e`nx g @nrwl/js:library --js=false\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003ccode\u003e--buildable 옵션\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e상기 커맨드를 통해 생성된 라이브러리는 기본적으로 \u003ccode\u003e빌드 할 수 없는\u003c/code\u003e 형태이다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003e--buildable=true\u003c/code\u003e 옵션을 추가하는 것을 통해 \u003ccode\u003e빌드 할 수 있는\u003c/code\u003e 형태의 패키지를 생성할 수 있다..\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e그 외에도 라이브러리를 생성하며 전달할 수 있는 옵션들이 다수 있으니 공식 문서를 참조하면 조금 더 다채로운 형태의 라이브러리를 생성 할 수 있다.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003ccode\u003e--compiler 옵션\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e타입스크립트 라이브러리를 생성하며 \u003ccode\u003e--compiler=swc\u003c/code\u003e 옵션을 추가하면 \u003ccode\u003etsc\u003c/code\u003e 대신 \u003ccode\u003eswc\u003c/code\u003e를 컴파일러로 설정 할 수 있다.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cblockquote\u003e\n\u003cp\u003eSWC (standard for Speedy Web Compiler)\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eRust\u003c/code\u003e 기반의 웹컴파일러로 기존의 \u003ccode\u003ebabel\u003c/code\u003e과 같은 transpiler에 비해 월등한 성능을 보임.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eSWC\u003c/code\u003e는 다른 트랜스파일러와 유사하게 \u003ccode\u003etypescript\u003c/code\u003e의 type checking을 수행하지 않기 때문에 사용하더라도 \u003ccode\u003etsc\u003c/code\u003e를 통해 타입체크를 별도로 수행해야한다. 특히 라이브러리 프로젝트의 경우 다른 프로젝트에서 라이브러리의 타입 정보를 체크하기 위해 \u003ccode\u003etsc\u003c/code\u003e를 통해 타입선언을 해주는 것이 좋겠다.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch3 id=\"react-library-generator\"\u003eReact Library Generator\u003c/h3\u003e\n\u003cp\u003e리액트 라이브러리 패키지를 생성하기 위해 \u003ccode\u003e@nrwl/react\u003c/code\u003e 디펜던시를 설치한다. 패키지 생성 명령은 앞서 살펴본 타입스크립트의 경우와 동일한 형식을 갖는다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-sh\"\u003enx g @nrwl/react:library\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e타입스크립트 생성과 유사한 \u003ccode\u003elinting\u003c/code\u003e, \u003ccode\u003etesting\u003c/code\u003e 환경이 갖춰진 패키지를 생성해낸다.\nReact Library도 기본적으로 타입스크립트 베이스로 생성되며 만약 자바스크립트 베이스의 React 라이브러리를 생성하고자 한다면 \u003ccode\u003e--js=false\u003c/code\u003e 옵션을 추가해야 한다.\u003c/p\u003e\n\u003ch2 id=\"마치며\"\u003e마치며\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003enx\u003c/code\u003e는 패키지를 개발과정의 \u003ccode\u003eworkflow\u003c/code\u003e를 관리하는 툴에 가깝다. \u003ccode\u003elerna\u003c/code\u003e와 유사한 기능을 제공할거라고 기대한 (물론 대부분의 기능을 nx도 제공하지만 module publishing이나 versioning은 lerna가 나에게는 더 수월하다는 생각이든다.) 것과는 약간 다른 성격을 가지고 있었다.\u003c/p\u003e\n\u003cp\u003e다양한 코드베이스의 프로젝트들을 한군데에서 관리하고 일하는 것 자체의 효율을 높이기 위한 툴이라는 생각이 들었다 (프론트엔드 백엔드를 넘나드는 Scaffolding과 필요한 대부분의 툴이 inject 된 상태의 디렉토리 구조등)\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://stackoverflow.com/questions/67000436/the-difference-between-nx-and-lerna-monorepos\"\u003e직접 느꼈으나 말로 표현 할 수 없던 이야기\u003c/a\u003e를 누군가 아주 잘 정리해준 글이 있어 첨부한다.\u003c/p\u003e\n",
            "postsByCategory": [
              {
                "title": "yarn berry로 구성하는 monorepo",
                "description": "yarn berry와 yarn workspaces를 이용해 monorepo 구성 - 환경 설정, 샘플 프로젝트",
                "fileName": "yarn-berry-monorepo.md",
                "category": "infrastructure",
                "published": true,
                "publishedAt": "2022-02-26",
                "thumbnailName": "yarn-berry-monorepo.png",
                "tags": ["berry", "monorepo", "workspace", "workspaces", "yarn", "yarn berry", "zero-install", "모노리포"],
                "references": [{ "title": "yarn workspaces", "url": "https://yarnpkg.com/features/workspaces" }],
                "series": { "prevPostTitle": "Nx build system 맛보기" }
              }
            ]
          },
          "__N_SSG": true
        },
        "page": "/[title]",
        "query": { "title": "nx-build-system-맛보기" },
        "buildId": "skUPIFWrM9tb05QUQJtZ7",
        "isFallback": false,
        "gsp": true,
        "scriptLoader": []
      }
    </script>
  </body>
</html>
