<!DOCTYPE html><html lang="ko"><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><link rel="canonical" href="https://code-logs.github.io/elasticsearch:-full-text-search-(전문검색)"/><link rel="apple-touch-icon" href="/icons/icon-192x-192.png"/><link rel="manifest" href="/manifest.json"/><meta name="theme-color" content="#fff"/><meta property="og:type" content="website"/><meta property="og:site_name" content="Code Logs"/><meta name="author" content="Jay Lee"/><meta name="keyword" content="elasticsearch, full-text search, searching engine, 엘라스틱서치, 전문검색, Elasticsearch: Full-text search (전문검색), Elasticsearch를 이용한 Full-text search, elasticsearch"/><meta name="description" content="Elasticsearch를 이용한 Full-text search"/><meta property="og:description" content="Elasticsearch를 이용한 Full-text search"/><meta property="og:title" content="Elasticsearch: Full-text search (전문검색) | Code Logs"/><meta property="og:url" content="https://code-logs.github.io/elasticsearch:-full-text-search-(전문검색)"/><meta property="og:image" content="/assets/images/elasticsearch-full-text-search.jpg"/><title>Elasticsearch: Full-text search (전문검색) | Code Logs</title><meta name="next-head-count" content="16"/><link rel="preload" href="/_next/static/css/a3846824ca944ab2.css" as="style"/><link rel="stylesheet" href="/_next/static/css/a3846824ca944ab2.css" data-n-g=""/><link rel="preload" href="/_next/static/css/7312969b97a189f4.css" as="style"/><link rel="stylesheet" href="/_next/static/css/7312969b97a189f4.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script src="/_next/static/chunks/webpack-2e51481b1d484a05.js" defer=""></script><script src="/_next/static/chunks/framework-5f4595e5518b5600.js" defer=""></script><script src="/_next/static/chunks/main-a4d9e436b9a532ca.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6d33c6eabb431f92.js" defer=""></script><script src="/_next/static/chunks/294-c1b4c50337db4bdd.js" defer=""></script><script src="/_next/static/chunks/pages/%5Btitle%5D-fe00864d53a4ffd6.js" defer=""></script><script src="/_next/static/-A21tKZSsSleB7NlYjKPX/_buildManifest.js" defer=""></script><script src="/_next/static/-A21tKZSsSleB7NlYjKPX/_ssgManifest.js" defer=""></script><script src="/_next/static/-A21tKZSsSleB7NlYjKPX/_middlewareManifest.js" defer=""></script></head><body><div id="__next" data-reactroot=""><header class="Header_header__RW35m"><p class="Header_title__GPS8b">Code Logs</p><ul class="Header_socialIcons__CBf_s"><li><a href="https://github.com/possible819" target="_blank" rel="noreferrer" aria-label="My Github"><style data-emotion="css vubbuv">.css-vubbuv{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;width:1em;height:1em;display:inline-block;fill:currentColor;-webkit-flex-shrink:0;-ms-flex-negative:0;flex-shrink:0;-webkit-transition:fill 200ms cubic-bezier(0.4, 0, 0.2, 1) 0ms;transition:fill 200ms cubic-bezier(0.4, 0, 0.2, 1) 0ms;font-size:1.5rem;}</style><svg class="MuiSvgIcon-root MuiSvgIcon-fontSizeMedium css-vubbuv" focusable="false" aria-hidden="true" viewBox="0 0 24 24" data-testid="GitHubIcon"><path d="M12 1.27a11 11 0 00-3.48 21.46c.55.09.73-.28.73-.55v-1.84c-3.03.64-3.67-1.46-3.67-1.46-.55-1.29-1.28-1.65-1.28-1.65-.92-.65.1-.65.1-.65 1.1 0 1.73 1.1 1.73 1.1.92 1.65 2.57 1.2 3.21.92a2 2 0 01.64-1.47c-2.47-.27-5.04-1.19-5.04-5.5 0-1.1.46-2.1 1.2-2.84a3.76 3.76 0 010-2.93s.91-.28 3.11 1.1c1.8-.49 3.7-.49 5.5 0 2.1-1.38 3.02-1.1 3.02-1.1a3.76 3.76 0 010 2.93c.83.74 1.2 1.74 1.2 2.94 0 4.21-2.57 5.13-5.04 5.4.45.37.82.92.82 2.02v3.03c0 .27.1.64.73.55A11 11 0 0012 1.27"></path></svg></a></li><li><a href="https://linkedin.com/in/jaylee819" target="_blank" rel="noreferrer" aria-label="My Linked in"><style data-emotion="css vubbuv">.css-vubbuv{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;width:1em;height:1em;display:inline-block;fill:currentColor;-webkit-flex-shrink:0;-ms-flex-negative:0;flex-shrink:0;-webkit-transition:fill 200ms cubic-bezier(0.4, 0, 0.2, 1) 0ms;transition:fill 200ms cubic-bezier(0.4, 0, 0.2, 1) 0ms;font-size:1.5rem;}</style><svg class="MuiSvgIcon-root MuiSvgIcon-fontSizeMedium css-vubbuv" focusable="false" aria-hidden="true" viewBox="0 0 24 24" data-testid="LinkedInIcon"><path d="M19 3a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h14m-.5 15.5v-5.3a3.26 3.26 0 0 0-3.26-3.26c-.85 0-1.84.52-2.32 1.3v-1.11h-2.79v8.37h2.79v-4.93c0-.77.62-1.4 1.39-1.4a1.4 1.4 0 0 1 1.4 1.4v4.93h2.79M6.88 8.56a1.68 1.68 0 0 0 1.68-1.68c0-.93-.75-1.69-1.68-1.69a1.69 1.69 0 0 0-1.69 1.69c0 .93.76 1.68 1.69 1.68m1.39 9.94v-8.37H5.5v8.37h2.77z"></path></svg></a></li></ul><nav class="NavBar_navBar__akqA3"><ul><li><a class="MarkedAnchor_anchor__QCmkL" href="https://code-logs.github.io/">Home</a></li><li><a class="MarkedAnchor_anchor__QCmkL" href="https://code-logs.github.io/posts/1">Posts</a></li><li><a class="MarkedAnchor_anchor__QCmkL" href="https://code-logs.github.io/about">About</a></li></ul></nav></header><main><article class="PostDetail_container__Ma_26"><p class="PostDetail_dateCount__xIC2G"><span></span><span>Views <!-- -->0</span></p><section class="PostDetail_thumbnailWrapper__oALCg"><img src="/assets/images/elasticsearch-full-text-search.jpg" alt="Elasticsearch를 이용한 Full-text search"/></section><section><h1>Elasticsearch: Full-text search (전문검색)</h1><p class="PostDetail_description__l6wHC">Elasticsearch를 이용한 Full-text search</p></section><section><h2 id="table-of-contents">Table of contents</h2>
<ol>
<li><a href="#elasticsearch">Elasticsearch?</a></li>
<li><a href="#elasticsearch%EC%9D%98-%EC%97%AD%ED%95%A0">Elasticsearch의 역할</a></li>
<li><a href="#elasticsearch%EC%9D%98-%ED%8A%B9%EC%A7%95">Elasticsearch의 특징</a></li>
<li><a href="#clustering">Clustering</a><ol>
<li><a href="#node%EC%9D%98-%EC%A2%85%EB%A5%98">Node의 종류</a></li>
<li><a href="#master-node">Master node</a></li>
<li><a href="#data-node">Data node</a></li>
<li><a href="#split-brain">Split Brain</a></li>
<li><a href="#node%EC%9D%98-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EC%A0%80%EC%9E%A5">Node의 데이터 저장</a></li>
</ol>
</li>
<li><a href="#rest-api%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-crud">REST API를 이용한 CRUD</a><ol>
<li><a href="#%EC%9E%85%EB%A0%A5-put">입력 (PUT)</a></li>
<li><a href="#%EC%A1%B0%ED%9D%AC-get">조회 (GET)</a></li>
<li><a href="#%EC%82%AD%EC%A0%9C-delete">삭제 (DELETE)</a></li>
<li><a href="#%EC%88%98%EC%A0%95-post">수정 (POST)</a></li>
<li><a href="#_update">_update</a></li>
<li><a href="#%EB%B2%8C%ED%81%AC-api">벌크 API</a></li>
</ol>
</li>
<li><a href="#_search-api">_search API</a><ol>
<li><a href="#uri-%EA%B2%80%EC%83%89">URI 검색</a></li>
</ol>
</li>
<li><a href="#full-text-search">Full-text search</a><ol>
<li><a href="#match_all">match_all</a></li>
<li><a href="#match">match</a></li>
<li><a href="#match_phrase">match_phrase</a></li>
<li><a href="#query_string">query_string</a></li>
<li><a href="#bool-query">bool query</a></li>
</ol>
</li>
<li><a href="#analyzer">Analyzer</a><ol>
<li><a href="#analyzer%EC%9D%98-%EA%B5%AC%EC%A1%B0">Analyzer의 구조</a></li>
<li><a href="#analyzer-%EC%A0%81%EC%9A%A9">Analyzer 적용</a></li>
<li><a href="#%EC%82%AC%EC%9A%A9%EC%9E%90-%EC%A0%95%EC%9D%98-analyzer">사용자 정의 Analyzer</a></li>
</ol>
</li>
<li><a href="#%EA%B7%B8-%EB%B0%96%EC%9D%98-%EA%B2%80%EC%83%89">그 밖의 검색</a><ol>
<li><a href="#exact-value-query">Exact value query</a></li>
<li><a href="#range-query">Range query</a></li>
</ol>
</li>
</ol>
<h2 id="elasticsearch">Elasticsearch?</h2>
<p><code>Elasticsearch</code>는 전문검색엔진으로 처음 개발 되었지만 현재는 검색엔진을 넘어 보안, 로그분석, 전문분석 등 다양한 영역에서 사용되고 있다.
샤이 배논에의해 2004년 부터 개발이 시작된 <code>elasticsearch</code>는 <code>Apache Lucene (검색 라이브러리)</code>을 사용했으나 이것의 한계점을 발견하고 이를 보완한 새로운 검색엔진을 만들기 시작했다.</p>
<p>이것이 <code>elasticsearch</code> 프로젝트의 시작이 되었다.</p>
<p>샤이 베논이 검색 프로그램을 만들기 시작한 이유는 그의 아내가 요리공부를 시작하게 되어 레시피 검색을 돕는 프로그램을 만들면서 부터라고 한다. <del>그 이후로 일이 이상하게 흘러가 여전히 레시피 검색 프로그램을 받지는 못한 모양이다</del></p>
<p>초기 <code>elasticsearch</code>는 <code>Logstash</code>와 <code>Kibana</code>를 함께 사용하며 <code>ELK Stack</code>이라 불리게 되었고 현재는 <code>Logstash</code>와 <code>Kibana</code>를 흡수하여 함께 개발되고 있으며 <code>Elastic Stack</code>이라는 명칭을 갖게 되었다.</p>
<h3 id="elasticsearch의-역할">Elasticsearch의 역할</h3>
<p><code>Elastic Stack</code>의 가장 핵심적인 역할을 수행한다. 데이터 색인, 저장, 검색, 집계를 수행하고 결과를 클라이언트 또는 다른 프로그램으로 전달하는 역할을 수행한다.</p>
<h3 id="elasticsearch의-특징">Elasticsearch의 특징</h3>
<ul>
<li><p><strong>오픈소스</strong></p>
<ul>
<li>핵심 기능들은 Apache 2.0 라이센스로 배포된다. <em>모든 소스가 <a href="https://github.elastic">깃허브</a>에 공개되어 있다.</em></li>
<li>6.3 버전 부터 Elastic 라이센스와 Apache 라이센스가 혼용되고 있지만 버전에 따른 별도의 배포판이 있다</li>
</ul>
</li>
<li><p><strong>실시간 분석</strong></p>
<ul>
<li>일반적인 데이터 분석시스템 (eg. <code>Hadoop</code>) 은 배치 작업을 기본으로 한다. 소스데이터와 분석을 수행하는 프로그램을 분석 시스템에 올리고 실행하면 결과가 나오는 식의 방식이다</li>
<li>반면 <code>elasticsearch</code>는 클러스터가 실행되고 있는 동안 데이터가 입력됨과 동시에 색인된 데이터의 검색 집계가 가능하다</li>
</ul>
</li>
<li><p><strong>전문 검색 엔진</strong></p>
<ul>
<li>역색인 구조 (<code>inverted index</code>)로 가공된 텍스트를 검색한다</li>
<li>내부적으로 역색인 구조로 데이터를 저장하고 있고 사용자 관점에서는 JSON 형식으로 데이터를 전달한다</li>
</ul>
</li>
<li><p><strong>RESTFul API</strong></p>
<ul>
<li>데이터 조회, 입력, 삭제를 http 프로토콜을 통해 Rest API로 처리한다</li>
</ul>
</li>
<li><p><strong>멀티테넌시</strong></p>
<ul>
<li><code>Elasticsearch</code>의 데이터는 <code>index</code>를 기준으로 구분되어 저장된다. <code>elasticsearch</code>는 다른 <code>index</code>에 속한 데이터를 별도의 커넥션 없이도 조회가 가능하고 이것을 <code>elasticsearch</code>에서는 멀티테넌시라한다.</li>
</ul>
</li>
</ul>
<blockquote>
<p><code>elasticsearch</code>는 <code>JSON</code> 형식만 지원하고 있기 때문에 데이터의 입력을 위해서 반드시 JSON으로 변환하는 작업이 필요하다. <code>Logstash</code>를 이용하여 대부분의 파일형식을 JSON 형식으로 변경할 수 있다.</p>
</blockquote>
<blockquote>
<p><code>elasticsearch</code>는 내부적으로 역색인 구조의 데이터를 저장한다. 이를 통해 데이터의 양이 늘어남에 따라 조회 대상이 늘어나는 일반적인 RDBMS와 달리 <code>term</code>을 통해 해당 <code>term</code>이 포함되어 있는 도큐먼트의 아이디를 찾게되고 결과적으로 검색 성능을 향상 시킬 수 있다. 역색인 구조로 데이터를 가공하여 저장하는 절차는 새로운 도큐먼트가 추가될 때 발생하기 때문에 <code>elasticsearch</code>는 저장이 아닌 색인이란 표현을 사용한다.</p>
</blockquote>
<h2 id="clustering">Clustering</h2>
<p><code>Elasticsearch</code> 노드들은 <code>cluster.name</code>을 설정으로 갖는데 동일한 <code>cluster.name</code>을 가지고 있는 노드들은 하나의 클러스터에 포함된다.
클러스터링은 하나의 서버에서 여러개로 구분될 수 있고 거꾸로 여러개의 서버에서 하나의 클러스터를 구성할 수 있다.
다른 네트워크 환경에 구성되어 있는 클러스터는 <code>discover.seed_hosts</code> 설정을 통해 서로를 탐색하고 하나의 클러스터로 구성 될 수 있다. 자세한 내용은 <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/important-settings.html">공식문서</a>를 통해 확인 할 수 있다.</p>
<h3 id="node의-종류">Node의 종류</h3>
<ol>
<li>Master node</li>
<li>Data node</li>
</ol>
<h3 id="master-node">Master node</h3>
<p><code>elasticsearch</code>의 클러스터는 반드시 하나의 마스터 노드를 포함하고 있어야 한다. 마스터 노드는 인덱스의 메타 데이터, 데이터가 분산 저장되어 있는 위치와 같은 클러스터의 상태 정보를 관리한다. 마스터노드가 관리하는 데이터가 유실되면 클러스터 전체가 작동하지 않기 때문에 마스터 노드가 어떠한 이유에 의해 중지되었을 때 이를 대신할 마스터 노드 후보자가 필요하다.</p>
<p>모든 노드는 기본적으로 마스터 노드가 될 수 있는 후보자로 등록된다. 후보자로 등록되어 있는 노드들은 마스터 노드가 정상적으로 동작하고 있더라도 마스터 노드에서 관리되는 메타 데이터를 가지고 있게된다. 이렇게 하는 것을 통해 갑작스레 마스터 노드가 유실 되었을 때 곧바로 후보자중 하나가 마스터 노드의 역할을 대신 수행 할 수 있기 때문이다.</p>
<p>클러스터의 규모가 커짐에 따라 불필요하게 많은 마스터 노드의 후보자가 생성될 수 있는데 이것은 성능에 안좋은 영향을 미치게 되고 이런 문제를 사전에 방지하기 위해 <code>node.master</code> 설정을 통해 후보자로 등록될지 여부를 결정 할 수 있다.</p>
<h3 id="data-node">Data node</h3>
<p>데이터 노드는 실제로 색인된 데이터를 저장하고 있는 노드이다. 마스터 노드와 마찬가지로 <code>node.data</code> 설정을 통해 데이터 노드의 역할을 수행할지 여부를 결정 할 수 있다.</p>
<blockquote>
<p>그 밖의 노드의 역할</p>
<p><em>node.ingest</em></p>
<p>데이터 색인 전처리 작업인 ingest pipeline 작업</p>
<p>node.ingest 설정을 통해 해당 역할을 on/off 할 수 있다.</p>
<p><em>node.ml</em></p>
<p>머신러닝 작업</p>
<p>node.ml 설정을 통해 해당 역할을 on/off 할 수 있다.</p>
</blockquote>
<blockquote>
<p>마스터 노드와 데이터 노드의 성능 향상</p>
<p>마스터 노드와 데이터 노드는 두가지 역할을 함께 수행 할 수 있지만 각자에 역할만 수행하도록 설정하는 것을 통해 성능상의 이점을 얻을 수 있다.</p>
</blockquote>
<h4 id="split-brain">Split Brain</h4>
<p>클러스터를 구성 할 때 마스터 노드를 최소 3개 이상의 &#39;홀수&#39;로 구성하는 것을 권장한다. 만약 마스터 후보 노드가 2개 또는 짝수로 구성할 경우 네트워크 유실로 인해 분리된 두개의 클러스터로 구성되어 계속 동작할 수 있는데 각기 다른 형상의 데이터를 저장하게 된다. 네트워크가 다시 연결되어 정상 상태인 하나의 클러스터로 묶일 때 데이터의 정합성과 무결성을 유지할 수 없게 된다. 이런 문제를 <code>Split Brain</code>이라 한다.</p>
<h3 id="node의-데이터-저장">Node의 데이터 저장</h3>
<p>elasticsearch에서는 단일 데이터 단위를 <code>document</code>라고 하며 이 <code>document</code>의 집합을 <code>index</code>라고 한다.
Node에 데이터를 저장할 때 <code>document</code>의 집합인 <code>index</code>는 다 시 <code>shard</code>라는 단위로 분리되어 저장되게 된다. 분리된 <code>shard</code>는 클러스터에 포함된 노드들에 의해 나뉘어 보관된다. 뿐만 아니라 <code>shard</code>는 <code>replica</code>라고 불리는 복제본을 생성하게 되며 이 복제본들 또한 노드들에 의해 나뉘어 보관된다.</p>
<p>이렇게 분리된 <code>shard</code>와 <code>replica</code>에 의해 클러스터의 특정 노드에 문제가 발생하여 데이터가 유실되더라도 다른 노드에 보관중인 <code>replica</code>와 <code>shard</code>에 의해 데이터의 유실을 방지 할 수 있다.</p>
<p>node가 실행을 멈추게 되면 일정시간동안 node의 재실행을 기다리고 timeout이 발생하게 되면 남아 있는 노드에 유실된 <code>shard</code>와 <code>replica</code>를 다시 생성하는 것을 통해 다시 발생할지도 모르는 장애로인한 데이터 유실을 방지한다.</p>
<h2 id="rest-api를-이용한-crud">REST API를 이용한 CRUD</h2>
<p>elasticsearch는 도큐먼트 별로 고유한 URL을 갖는다. URL은 아래의 패턴을 갖는다</p>
<div align=center>http://host:port/index/doc type/doc id</div>

<h3 id="입력-put">입력 (PUT)</h3>
<pre><code class="language-javascript">const response = await fetch(&#39;http://localhost:9200/new_index/_doc/1&#39;, {
  method: &#39;put&#39;,
  headers: { [&#39;Content-Type&#39;]: &#39;application/json&#39; },
  body: JSON.stringify({
    name: &#39;Code Logs&#39;,
  }),
})

console.log((await response.json()).result) // created
</code></pre>
<p><code>new_index</code>라는 명칭의 인덱스에 새로운 도큐먼트가 추가 되었다 정상적으로 데이터가 추가되면 <code>created</code>를 response.result로 응답한다.</p>
<p>동일한 요청을 다시 보내게 되면 대상 도큐먼트가 덮어씌워지게 된다. 이 경우에는 <code>created</code> 대신 <code>updated</code>를 response.result로 응답한다.</p>
<p>도큐먼트가 덮어 씌워지는 것을 방지하기 위해 요청시 도큐먼트 타입을 <code>_create</code>로 지정 할 수 있다. 이렇게 하면 해당 아이디를 가진 도큐먼트가 이미 존재 할 경우 에러를 발생시키고 그렇지 않을 경우에만 새로운 도큐먼트를 저장한다.</p>
<pre><code class="language-javascript">const response = await fetch(&#39;http://localhost:9200/new_index/_create/1&#39;, {
  method: &#39;put&#39;,
  headers: { [&#39;Content-Type&#39;]: &#39;application/json&#39; },
  body: JSON.stringify({ name: &#39;Code Logs&#39; }),
})

if (!response.ok) console.log((await response.json()).error.reason) // [1]: version conflict, document already exists (current version [2])
</code></pre>
<h3 id="조회-get">조회 (GET)</h3>
<pre><code class="language-javascript">const response = await fetch(&#39;http://localhost:9200/new_index/_doc/1&#39;)
console.log((await response.json())._source) // { name: &#39;Code Logs&#39; }
</code></pre>
<p>도큐먼트를 조회하면 저장되어 있는 데이터 외에도 다양한 정보를 응답한다. 데이터는 <code>_source</code> 프로퍼티를 통해 접근 할 수 있다.</p>
<h3 id="삭제-delete">삭제 (DELETE)</h3>
<p>도큐먼트 또는 인덱스 단위로 데이터를 삭제 할 수 있다.</p>
<pre><code class="language-javascript">// 도큐먼트 단위 삭제
const response = await fetch(&#39;http://localhost:9200/new_index/_doc/1&#39;, {
  method: &#39;delete&#39;,
})

console.log((await response.json()).result) // deleted
</code></pre>
<pre><code class="language-javascript">// 인덱스 단위 삭제
const response = await fetch(&#39;http://localhost:9200/new_index&#39;, {
  method: &#39;delete&#39;,
})

console.log((await response.json()).acknowledged) // true
</code></pre>
<h3 id="수정-post">수정 (POST)</h3>
<p>POST 메서드는 PUT 메서드와 마찬가지로 데이터 입력에 사용된다. 도큐먼트를 입력 할 때 도큐먼트 아이디를 생략하게 되면 임의의 도큐먼트 아이디가 자동으로 생성된다.</p>
<pre><code class="language-javascript">const response = await fetch(&#39;http://localhost:9200/new_index/_doc&#39;, {
  method: &#39;post&#39;,
  headers: { [&#39;Content-Type&#39;]: &#39;application/json&#39; },
  body: JSON.stringify({ name: &#39;Code Logs&#39; }),
})

const { result, _id } = await response.json()
console.log(_id) // 임의 아이디
console.log(result) // created
</code></pre>
<h3 id="_update">_update</h3>
<p>POST 또는 PUT 메서드를 통해 도큐먼트를 업데이트 하려면 대상 도큐먼트의 모든 필드를 다시 입력해야 하는 번거로움이 있다. 이럴 경우 <code>_update</code> 도큐먼트 타입을 이용하면 수정하고자 하는 필드만 업데이트 할 수 있다.</p>
<pre><code class="language-javascript">const response = await fetch(&#39;http://localhost:9200/new_index/_update/1&#39;, {
  method: &#39;post&#39;,
  headers: { [&#39;Content-type&#39;]: &#39;application/json&#39; },
  body: JSON.stringify({
    doc: {
      description: &#39;Personal blog about web development&#39;,
    },
  }),
})

console.log((await response.json()).result) // updated
</code></pre>
<blockquote>
<p>_version 프로퍼티</p>
<p>도큐먼트를 조회 했을 때 받게되는 응담의 프로퍼티중 <code>_version</code> 프로퍼티는 해당 도큐먼트의 변경이 발생함에 따라 1씩 증가하게 된다.</p>
<p><code>_update</code> 도큐먼트 타입을 통해 일부 필드가 수정되더라도 <code>_version</code>은 1 증가하는 것을 확인 할 수 있는데 그 이유는 내부적으로 업데이트 대상 도큐먼트를 모두 가지고와 일부 필드만 수정한 뒤 전체 내용을 PUT하는 방식으로 동작하기 때문이다.</p>
</blockquote>
<h3 id="벌크-api">벌크 API</h3>
<p>여러 유형의 명령을 배치로 수행하기 위해서 <code>_bulk</code> API를 사용 할 수 있다. <code>_bulk</code> API는 <code>delete</code>를 제외하고 명령문과 데이터문을 한 줄 씩 순서대로 입력해야 한다.
<code>delete</code>는 입력할 데이터가 없기 때문에 명령문만 입력한다.</p>
<p>다음 예제는 아래의 명령을 한번에 실행하는 것이다.</p>
<ol>
<li>user index에 id가 1인 { name: &#39;Jay&#39;, age: 20 } 생성</li>
<li>user index에 id가 2인 { name: &#39;Lee&#39;, age: 21 } 생성</li>
<li>fruit index에 id가 1인 { name: &#39;apple&#39;, price: 2000 } 생성</li>
<li>user index에 id가 2인 도큐먼트 삭제</li>
<li>fruit index에 id가 1인 도큐먼트의 { description: &#39;Fresh and delicious apple&#39; } 업데이트</li>
</ol>
<pre><code class="language-javascript">const commands = [
  { index: { _index: &#39;user&#39;, _id: &#39;1&#39; } },
  { name: &#39;Jay&#39;, age: &#39;20&#39; },
  { index: { _index: &#39;user&#39;, _id: &#39;2&#39; } },
  { name: &#39;Lee&#39;, age: &#39;21&#39; },
  { index: { _index: &#39;fruit&#39;, _id: &#39;1&#39; } },
  { name: &#39;apple&#39;, price: &#39;2000&#39; },
  { delete: { _index: &#39;user&#39;, _id: &#39;2&#39; } },
  { update: { _index: &#39;fruit&#39;, _id: &#39;1&#39; } },
  { doc: { description: &#39;Fresh and delicious apple&#39; } },
]
const response = await fetch(&#39;http://localhost:9200/_bulk&#39;, {
  method: &#39;post&#39;,
  headers: { [&#39;Content-type&#39;]: &#39;application/json&#39; },
  body: commands.map((c) =&gt; JSON.stringify(c)).join(&#39;\n&#39;) + &#39;\n&#39;,
})

console.log((await response.json()).items) // (5) [{…}, {…}, {…}, {…}, {…}]
</code></pre>
<p><code>_bulk</code> API를 통해 변경된 도큐먼트의 응답은 <code>items</code> 프로퍼티를 통해 확인 할 수 있다.</p>
<p>만약 조작하고자하는 도큐먼트가 모두 하나의 index에 속해 있다면 아래와 같이 index를 명시한 상태로 호출 할 수 있다.</p>
<pre><code class="language-javascript">const commands = [
  { index: { _id: 1 } },
  { name: &#39;Jay&#39;, age: 20 },
  { index: { _id: 2 } },
  { name: &#39;Lee&#39;, age: 21 },
  { delete: { _id: 2 } },
]
const response = await fetch(&#39;http://localhost:9200/user/_bulk&#39;, {
  method: &#39;post&#39;,
  headers: { [&#39;Content-type&#39;]: &#39;application/json&#39; },
  body: commands.map((c) =&gt; JSON.stringify(c)).join(&#39;\n&#39;) + &#39;\n&#39;,
})

console.log((await response.json()).items) // (3) [{…}, {…}, {…}]
</code></pre>
<blockquote>
<p>elasticsearch는 <code>commit</code>, <code>rollback</code>, <code>transaction</code> 개념이 존재하지 않는다 만약 <code>_bulk</code> API를 통해 여러 도큐먼트를 대상으로 작업을 수행하던 중 문제가 발생하면 수행이 완료된 index를 찾을 수 없기 때문에 모든 index를 삭제하고 다시 전체 bulk 작업을 수행하는 것을 권장한다.</p>
</blockquote>
<h2 id="_search-api">_search API</h2>
<p><code>_search</code> API를 통해 인덱스 단위의 검색을 할 수 있다.
<code>GET</code> 메서드를 이용하여 아래의 형식으로 조회를 요청 할 수 있다.</p>
<div align=center>http://localhost:9200/target_index/_search</div>

<h3 id="uri-검색">URI 검색</h3>
<p><code>q</code> 파라메터를 이용하여 검색 조건을 설정 할 수 있다. 검색 조건이 존재하지 않을 경우 인덱스의 모든 도큐먼트를 대상으로 검색을 수행한다.</p>
<p>이러한 검색 방식을 <code>URI 검색</code>이라 한다.</p>
<div align=center>http://localhost:9200/target_index/_search?q=condition</div>

<blockquote>
<p>AND 조건으로 검색하기</p>
<p><a href="http://localhost:9200/target_index/%5C_search?q=condition1">http://localhost:9200/target_index/\_search?q=condition1</a> AND condition2</p>
</blockquote>
<blockquote>
<p>검색 조건을 특정 필드로 한정하기</p>
<p><a href="http://localhost:9200/target_index/%5C_search?q=field:condition1">http://localhost:9200/target_index/\_search?q=field:condition1</a></p>
</blockquote>
<h3 id="멀티테넌시">멀티테넌시</h3>
<p>멀티네넌시는 한번에 여러 인덱스를 대상으로 검색하는 것을 의미한다. 여러 인덱스를 검색할때는 <code>,</code>로 구분하여 나열하거나 <code>*</code> 와일드 카드를 통해 표현 할 수 있다.</p>
<div align=center>http://localhost:9200/target_index1,target_index2/_search</div>

<div align=center>http://localhost:9200/target_index*/_search</div>

<blockquote>
<p>인덱스를 지정하지 않고 클러스터 내부의 모든 인덱스를 대상으로 검색을 하려면 <code>_all</code> 지정자를 사용할 수 있지만 시스템 사용을 위해 정의된 인덱스에도 접근하게 되어 불필요한 작업을 수행하게 되므로 권장되지 않는다.</p>
</blockquote>
<h2 id="full-text-search">Full-text search</h2>
<p><code>elasticsearch</code>는 검색시 주어지는 조건의 대소문자, 단수, 복수, 원형의 여부와 상관 없이 검색이 가능하도록 <code>Term</code>으로 분석하는 과정을 거친 뒤 데이터를 저장한다.
이런 전처리 과정을 거친 결과로 Full-text search가 가능하게 된다.</p>
<blockquote>
<p>DSL - 도메인 특화 언어 (Domain Specific Language)</p>
<p>도메인 특화 언어는 특정한 도메인에 적용하도록 최적화된 프로그래밍 언어이다. Elasticsearch는 JSON 형태의 Query DSL을 사용한다.</p>
<p>Query DSL을 통해 <code>데이터 본문 (Data body) 검색</code>을 할 수 있다.</p>
<p><a href="https://ko.wikipedia.org/wiki/%EB%8F%84%EB%A9%94%EC%9D%B8_%ED%8A%B9%ED%99%94_%EC%96%B8%EC%96%B4">wiki</a></p>
</blockquote>
<h3 id="match_all">match_all</h3>
<p>특별한 조건 없이 특정 인덱스의 모든 도큐먼트를 검색하는 쿼리</p>
<pre><code class="language-javascript">const response = await fetch(&#39;http://localhost:9200/target_index/_search&#39;, {
  method: &#39;post&#39;,
  headers: { [&#39;Content-type&#39;]: &#39;application/json&#39; },
})
</code></pre>
<blockquote>
<p>Full-text search를 진행하기 위해서 앞서 살펴본 URI 검색이 아닌 <code>데이터 본문 (Data body) 검색</code>을 이용해야 한다.</p>
<p><a href="https://www.npmjs.com/package/@elastic/elasticsearch">@elastic/elasticsearch</a> 모듈을 이용해 데이터 본문 검색을 사용할 수 있다.</p>
</blockquote>
<h3 id="match">match</h3>
<p>가장 일반적으로 사용되는 풀 텍스트 검색 쿼리로 특정 필드에 특정한 값이 포함되는 도큐먼트를 조회하는데 사용된다.</p>
<pre><code class="language-javascript">const response = await fetch(&#39;http://localhost:9200/target_index/_search&#39;, {
  method: &#39;post&#39;,
  headers: { [&#39;Content-type&#39;]: &#39;application/json&#39; },
  body: JSON.stringify({
    query: {
      match: {
        field: &#39;condition&#39;,
      },
    },
  }),
})
</code></pre>
<p><code>match</code> 검색을 사용할 때 여러개의 검색어를 집어 넣으면 기본적으로 <code>OR</code> 조건으로 검색이 된다.</p>
<pre><code class="language-javascript">const response = await fetch(&#39;http://localhost:9200/target_index/_search&#39;, {
  method: &#39;post&#39;,
  headers: { [&#39;Content-type&#39;]: &#39;application/json&#39; },
  body: JSON.stringify({
    query: {
      match: {
        field: &#39;condition1 condition2&#39;,
      },
    },
  }),
})
</code></pre>
<p>여러 검색어를 <code>AND</code> 조건으로 검색하려면 <code>operator</code> 옵션을 사용한다. <code>AND</code> 조건으로 검색할 때는 본문의 형식이 달라지는 것에 유의한다.</p>
<pre><code class="language-javascript">const response = await fetch(&#39;http://localhost:9200/target_index/_search&#39;, {
  method: &#39;post&#39;,
  headers: { [&#39;Content-type&#39;]: &#39;application/json&#39; },
  body: JSON.stringify({
    query: {
      match: {
        field: {
          query: &#39;condition1 condition2&#39;,
          operator: &#39;and&#39;,
        },
      },
    },
  }),
})
</code></pre>
<h3 id="match_phrase">match_phrase</h3>
<p>검색어로 나열된 조건들을 공백을 포함한 하나의 문자열 조건으로 검색할 때 사용한다.</p>
<pre><code class="language-javascript">const response = await fetch(&#39;http://localhost:9200/target_index/_search&#39;, {
  method: &#39;post&#39;,
  headers: { [&#39;Content-type&#39;]: &#39;application/json&#39; },
  body: JSON.stringify({
    query: {
      match_phrase: {
        field: &#39;condition1 condition2&#39;,
      },
    },
  }),
})
</code></pre>
<p>나열된 검색어 사이에 n 개의 단어를 포함하여 검색하도록 하기 위해 <code>slop</code> 속성을 사용한다.</p>
<pre><code class="language-javascript">const response = await fetch(&#39;http://localhost:9200/target_index/_search&#39;, {
  method: &#39;post&#39;,
  headers: { [&#39;Content-type&#39;]: &#39;application/json&#39; },
  body: JSON.stringify({
    query: {
      match_phrase: {
        field: &#39;condition1 condition2&#39;,
        slop: 1, // condition1 something condition2와 같은 형식의 데이터 조회 가능
      },
    },
  }),
})
</code></pre>
<p>위 예제에서 <code>slop</code>을 1로 설정 했기 때문에 <code>condition1</code>과 <code>condition2</code> 사이에 한개의 추가적인 단어가 존재하는 도큐먼트를 조회하게 된다.</p>
<h3 id="query_string">query_string</h3>
<p><a href="#uri-%EA%B2%80%EC%83%89">URI 검색</a>에서 사용했던 <code>q</code> 파라메터를 데이터 본문 검색을 통해 수행할 수 있다.</p>
<pre><code class="language-javascript">const response = await fetch(&#39;http://localhost:9200/target_index/_search&#39;, {
  method: &#39;post&#39;,
  headers: { [&#39;Content-type&#39;]: &#39;application/json&#39; },
  body: JSON.stringify({
    query: {
      query_string: {
        default_field: &#39;field&#39;,
        query: &#39;condition1 AND condition2&#39;,
      },
    },
  }),
})
</code></pre>
<p><code>query_string</code>을 이용해서도 <code>match_phrase</code>와 같이 구문을 검색이 가능한데 그럴 경우 검색어를 <code>\&quot;</code>로 묶어주면 된다.</p>
<pre><code class="language-javascript">const response = await fetch(&#39;http://localhost:9200/target_index/_search&#39;, {
  method: &#39;post&#39;,
  headers: { [&#39;Content-type&#39;]: &#39;application/json&#39; },
  body: JSON.stringify({
    query: {
      query_string: {
        default_field: &#39;field&#39;,
        query: &#39;(condition1 AND condition2) OR &quot;condition3 condition4&quot;&#39;,
      },
    },
  }),
})
</code></pre>
<blockquote>
<p><code>query_string</code>을 이용하여 구문 검색을 할 때 <code>slop</code>은 사용 할 수 없다.</p>
</blockquote>
<h3 id="bool-query">bool query</h3>
<p><code>데이터 본문 검색</code>을 통해 복합적인 조건을 구성하려면 <code>bool query (복합쿼리)</code>를 이용해야한다.</p>
<p><code>bool query</code>는 다음의 네가지 인자를 가지고 있으며 각 인자에 따라 검색 조건이 달라진다.</p>
<ul>
<li>must<ul>
<li>조건이 반드시 true인 도큐먼트를 검색한다.</li>
</ul>
</li>
<li>must_not<ul>
<li>조건이 반드시 false인 도큐먼트를 검색한다.</li>
</ul>
</li>
<li>should<ul>
<li>검색된 결과중 이 조건에 부함하는 도큐먼트의 정확도 점수를 높인다.</li>
</ul>
</li>
<li>filter<ul>
<li>조건이 반드시 true인 도큐먼트를 검색하되 정확도 점수를 계산하지 않아 속도가 빠르고 캐싱이 된다는 장점이 있다.</li>
</ul>
</li>
</ul>
<pre><code class="language-javascript">const response = await fetch(&#39;http://localhost:9200/target_index/_search&#39;, {
  method: &#39;post&#39;,
  headers: { [&#39;Content-type&#39;]: &#39;application/json&#39; },
  body: JSON.stringify({
    query: {
      bool: {
        must: [
          {
            match: {
              field: &#39;condition 1&#39;,
            },
          },
        ],
        must_not: [
          {
            match: {
              field: &#39;condition 3&#39;,
            },
          },
        ],
        should: [
          {
            match_phrase: {
              field: &#39;condition1 condition2&#39;,
            },
          },
        ],
      },
    },
  }),
})
</code></pre>
<blockquote>
<p><code>should</code>를 이용한 검색 정확도 가중치 부여하기</p>
<p><code>elasticsearch</code>는 기본적으로 검색 결과의 정확도를 기준으로 결과를 정렬한다.</p>
<p><code>bool query</code>를 통해 도큐먼트를 조회 할 때 필요에 따라 더 중요한 키워드를 <code>should</code> 속성에 포함시켜 정확도 점수에 가중치를 부여할 수 있고 결과적으로 도큐먼트중 더 중요한 결과를 상위에 노출 시킬 수 있다.</p>
</blockquote>
<blockquote>
<p><code>filter</code>를 이용한 검색 정확도 배제하기</p>
<p>경우에 따라 겸색어가 정확도에 영향을 미쳐선 안되는 상황이 벌어질 수 있다. 이런 경우의 검색어 조건을 <code>filter</code> 속성에 포함시켜 정확도 점수에 영향을 주지 않도록 설정하고 검색 할 수 있다.</p>
</blockquote>
<h2 id="analyzer">Analyzer</h2>
<p>관계형 데이터베이스의 일반적인 조회가 아닌 <code>Full-text search</code>를 이용하는 것을 통해 얻을 수 있는 이점중 하나는 동의어 검색 또는 원형을 통한 검색 (ex. <em>먹었다</em> 라는 키워드를 통해 동일한 원형 (<em>먹다</em>)을 갖고 있는 키워드 (<em>먹었는데</em>, <em>먹고</em>)를 포함하는 도큐먼트를 조회하는 것)이다.</p>
<p>앞서 살펴본바와 같이 <code>elasticsearch</code>는 역색인 구조를 통해 도큐먼트를 조회하기 때문에 이런 고급검색 기능을 사용하기 위해서는 동의어와 원형을 통해 도큐먼트를 찾을 수 있도록 데이터를 저장하는 시점에 미리 적절한 index를 생성해야 한다.</p>
<p>저장하려는 데이터를 분석하여 적절한 index를 설정하는 것이 Analyzer의 역할이다.</p>
<h3 id="analyzer의-구조">Analyzer의 구조</h3>
<p><code>Analyzer</code>는 다음 세가지 요소의 조합으로</p>
<ul>
<li>Character filters</li>
<li>Tokenizer</li>
<li>Token filters</li>
</ul>
<p>저장 되려는 데이터는 각 요소를 거쳐 최종적으로 필요한 인덱스를 생성하며 저장된다.</p>
<ol>
<li><p>Character filters</p>
<p>문장을 특정 문자로 대치하거나 제거하는 과장을 담당하는 필터</p>
</li>
<li><p>Tokenizer</p>
<p>입력된 도큐먼트를 어떤 기준을 통해 잘라내는 과정 (일반적으로는 whitespace를 기준으로 함)</p>
</li>
<li><p>Token filters</p>
<p>잘라진 도큐먼트 요소들을 돌며 최종적인 index 키워드를 생성하는 과정으로 동의어, 원형등을 만들어 내고 (ing, ed 등의 접미사를 제거하거나 등록되어 있는 사전을 통해 동의어를 찾아 등록하는 등) 그렇게 만들어진 index와 도큐먼트를 연결함</p>
</li>
</ol>
<blockquote>
<p>Tokenizer는 Character filters, token filters와 달리 반드시 하나만 정용 할 수 있다.</p>
</blockquote>
<h3 id="analyzer-적용">Analyzer 적용</h3>
<p>별도의 설정 없이 생성된 <code>elasticsearch</code>의 <code>index</code>는 기본값인 <code>standard analyzer</code>가 설정되어 있다. <code>standard analyzer</code>를 통해 생성된 색인은 이 문서의 소기의 목적이였던 <code>full-text search</code>의 강력한 기능들을 사용 할 수 없다.</p>
<p><code>index</code>를 생성하는 시점에 어떤 <code>analyzer</code>를 사용할지 정의해야한다.</p>
<pre><code class="language-javascript">const response = await fetch(&#39;http://localhost:9200/target_index&#39;, {
  method: &#39;put&#39;,
  headers: { [&#39;Content-type&#39;]: &#39;application/json&#39; },
  body: JSON.stringify({
    mappings: {
      properties: {
        name: {
          type: &#39;text&#39;,
          analyzer: &#39;snowball&#39;,
        },
      },
    },
  }),
})
</code></pre>
<p><code>index</code>가 생성되는 시점에 도큐먼트의 <em>name</em> 필드에 <em>snowball</em> analyzer를 적용하는 예시이다.</p>
<blockquote>
<p>snowball은 elasticsearch가 기본적으로 제공하는 analyzer</p>
</blockquote>
<p>이렇게 생성된 <code>index</code>에 데이터를 저장하게 되면 앞서 이야기한 <code>Character filter</code>, <code>Tokenizer</code>, <code>Token filter</code>를 적절한 색인이 생성되고 마침내 동의어, 원형 검색 등이 가능하게 된다.</p>
<h3 id="사용자-정의-analyzer">사용자 정의 Analyzer</h3>
<p>사용자의 정의 <code>analyzer</code>는 character filter, tokenizer를 정의하고 token filter들을 조합하는 것을 통해 설정한다.</p>
<p>마찬가지로 <code>index</code>를 생성하는 시점에 해당 작업을 수행해야 한다.</p>
<pre><code class="language-javascript">const response = await fetch(&#39;http://localhost:9200/target_index&#39;, {
  method: &#39;put&#39;,
  headers: { [&#39;Content-type&#39;]: &#39;application/json&#39; },
  body: JSON.stringify({
    settings: {
      analysis: {
        analyzer: {
          custom_analyzer: {
            char_filter: [&#39;custom_char_filter&#39;],
            tokenizer: &#39;whitespace&#39;,
            filter: [&#39;lowercase&#39;, &#39;snowball&#39;],
          },
        },
        char_filter: {
          custom_char_filter: {
            type: &#39;mapping&#39;,
            mappings: [&#39;as soon as possible&#39;, &#39;_asap_&#39;],
          },
        },
      },
    },
    mappings: {
      properties: {
        message: {
          type: &#39;text&#39;,
          analyzer: &#39;custom_analyzer&#39;,
        },
      },
    },
  }),
})
</code></pre>
<blockquote>
<p>사용자 analyzer를 정의하는 것은 새로운 <em>Character Filter</em>를 정의하여 사용할 수 있고 마찬가지로 <em>Token Filter</em>를 정의하여 사용할 수도 있다.</p>
<p><em>Token Filter</em>의 조합 순서에 따라 생성되는 index의 결과가 달라질 수 있는 것에 유의해야 한다.</p>
</blockquote>
<h2 id="그-밖의-검색">그 밖의 검색</h2>
<h3 id="exact-value-query">Exact value query</h3>
<p>정확한 문자열 검색을 해야할 때 <code>[field].keyword</code>를 이용한다</p>
<pre><code class="language-javascript">const response = await fetch(&#39;http://localhost:9200/target_index/_search&#39;, {
  method: &#39;post&#39;,
  headers: { [&#39;Content-type&#39;]: &#39;application/json&#39; },
  body: JSON.stringify({
    query: {
      bool: {
        filter: [
          {
            match: {
              [&#39;name.keyword&#39;]: &#39;Condition 1&#39;,
            },
          },
        ],
      },
    },
  }),
})
</code></pre>
<blockquote>
<p><code>[field].keyword</code> 형식의 검색조건을 설정할 때 <code>bool query</code>의 <code>filter</code> 속성을 이용하는 것을 권장한다.</p>
<p>Exact value query는 정확도와 관계가 없기 때문에 정확도 점수를 계산할 필요가 없으며 그 결과 <code>filter</code>를 통해 검색하는 것이 캐싱이 가능하고 검색 성능이 더 우수하기 때문이다.</p>
</blockquote>
<h3 id="range-query">Range query</h3>
<p>숫자와 날짜 형식을 포함하고 있는 도큐먼트를 대상으로 검색을 수행할 때 범위를 통한 조건 설정이 가능하다. <code>range query</code>는 다음 네가지의 속성을 통해 범위 설정이 가능하다.</p>
<ul>
<li>gte (Greater Than or Equal to)<ul>
<li>이상</li>
</ul>
</li>
<li>gt (Grater Than)<ul>
<li>초과</li>
</ul>
</li>
<li>lte (Less Than or Equal to)<ul>
<li>이하</li>
</ul>
</li>
<li>lt (Less Than)<ul>
<li>미만</li>
</ul>
</li>
</ul>
<pre><code class="language-javascript">const response = await fetch(&#39;http://localhost:9200/target_index/_search&#39;, {
  method: &#39;post&#39;,
  headers: { [&#39;Content-Type&#39;]: &#39;application/json&#39; },
  body: JSON.stringify({
    query: {
      range: {
        price: {
          gte: 3000,
          lte: 4000,
        },
      },
    },
  }),
})
</code></pre>
<p>날짜 데이터의 범위 검색도 숫자 데이터의 범위 검색과 동일하지만 몇가지 옵션이 있다.</p>
<pre><code class="language-javascript">const response = await fetch(&#39;http://localhost:9200/target_index/_search&#39;, {
  method: &#39;post&#39;,
  headers: { [&#39;Content-Type&#39;]: &#39;application/json&#39; },
  body: JSON.stringify({
    query: {
      range: {
        manufacture_date: {
          gte: &#39;2021/11/01&#39;,
          lt: &#39;2021/12/01&#39;,
          format: &#39;yyyy/mm/dd&#39;, // 날짜 형식을 결정하는 속성
        },
      },
    },
  }),
})
</code></pre>
<p><code>format</code> 속성을 통해 날짜의 형식을 결정 할 수 있다.</p>
<p>예약어를 통해 범위를 결정하는 방법도 있다. 예약어는 아래의 8가지가 존재한다</p>
<ul>
<li>now: 현재시간</li>
<li>y: 년</li>
<li>M: 월</li>
<li>d: 일</li>
<li>h: 시</li>
<li>m: 분</li>
<li>s: 초</li>
<li>w: 주</li>
</ul>
<pre><code class="language-javascript">const response = await fetch(&#39;http://localhost:9200/target_index/_search&#39;, {
  method: &#39;post&#39;,
  headers: { [&#39;Content-Type&#39;]: &#39;application/json&#39; },
  body: JSON.stringify({
    query: {
      range: {
        manufacture_date: {
          lte: &#39;now-1w&#39;, // 지금으로 부터 일주일 전까지의 날짜에 속하는 도큐먼트를 검색함
        },
      },
    },
  }),
})
</code></pre>
<blockquote>
<p>범위검색은 기본적으로 정확도 점수를 계산하지 않는다.</p>
<p>경우에 따라 어던 기준으로 부터 더 가까운 값이 중요한 결과로 취급 될 수 있는데 이런 경우에는 <a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.3/query-dsl-function-score-query.html">Function score query</a>를 이용해야한다.</p>
</blockquote>
</section></article><section class="PostDetail_utterances__jZeOm"><h2>Comments</h2><div></div></section></main><footer class="Footer_footer__GLL0J"><p>ⓒ 2021. Jay Lee  all rights reserved.</p></footer></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"Elasticsearch: Full-text search (전문검색)","fileName":"full-text-search.md","description":"Elasticsearch를 이용한 Full-text search","category":"elasticsearch","published":true,"publishedAt":"2021-11-16","tags":["elasticsearch","full-text search","searching engine","엘라스틱서치","전문검색"],"thumbnailName":"elasticsearch-full-text-search.jpg"},"content":"\u003ch2 id=\"table-of-contents\"\u003eTable of contents\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003e\u003ca href=\"#elasticsearch\"\u003eElasticsearch?\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#elasticsearch%EC%9D%98-%EC%97%AD%ED%95%A0\"\u003eElasticsearch의 역할\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#elasticsearch%EC%9D%98-%ED%8A%B9%EC%A7%95\"\u003eElasticsearch의 특징\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#clustering\"\u003eClustering\u003c/a\u003e\u003col\u003e\n\u003cli\u003e\u003ca href=\"#node%EC%9D%98-%EC%A2%85%EB%A5%98\"\u003eNode의 종류\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#master-node\"\u003eMaster node\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#data-node\"\u003eData node\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#split-brain\"\u003eSplit Brain\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#node%EC%9D%98-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EC%A0%80%EC%9E%A5\"\u003eNode의 데이터 저장\u003c/a\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#rest-api%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-crud\"\u003eREST API를 이용한 CRUD\u003c/a\u003e\u003col\u003e\n\u003cli\u003e\u003ca href=\"#%EC%9E%85%EB%A0%A5-put\"\u003e입력 (PUT)\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#%EC%A1%B0%ED%9D%AC-get\"\u003e조회 (GET)\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#%EC%82%AD%EC%A0%9C-delete\"\u003e삭제 (DELETE)\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#%EC%88%98%EC%A0%95-post\"\u003e수정 (POST)\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#_update\"\u003e_update\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#%EB%B2%8C%ED%81%AC-api\"\u003e벌크 API\u003c/a\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#_search-api\"\u003e_search API\u003c/a\u003e\u003col\u003e\n\u003cli\u003e\u003ca href=\"#uri-%EA%B2%80%EC%83%89\"\u003eURI 검색\u003c/a\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#full-text-search\"\u003eFull-text search\u003c/a\u003e\u003col\u003e\n\u003cli\u003e\u003ca href=\"#match_all\"\u003ematch_all\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#match\"\u003ematch\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#match_phrase\"\u003ematch_phrase\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#query_string\"\u003equery_string\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#bool-query\"\u003ebool query\u003c/a\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#analyzer\"\u003eAnalyzer\u003c/a\u003e\u003col\u003e\n\u003cli\u003e\u003ca href=\"#analyzer%EC%9D%98-%EA%B5%AC%EC%A1%B0\"\u003eAnalyzer의 구조\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#analyzer-%EC%A0%81%EC%9A%A9\"\u003eAnalyzer 적용\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#%EC%82%AC%EC%9A%A9%EC%9E%90-%EC%A0%95%EC%9D%98-analyzer\"\u003e사용자 정의 Analyzer\u003c/a\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#%EA%B7%B8-%EB%B0%96%EC%9D%98-%EA%B2%80%EC%83%89\"\u003e그 밖의 검색\u003c/a\u003e\u003col\u003e\n\u003cli\u003e\u003ca href=\"#exact-value-query\"\u003eExact value query\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#range-query\"\u003eRange query\u003c/a\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2 id=\"elasticsearch\"\u003eElasticsearch?\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003eElasticsearch\u003c/code\u003e는 전문검색엔진으로 처음 개발 되었지만 현재는 검색엔진을 넘어 보안, 로그분석, 전문분석 등 다양한 영역에서 사용되고 있다.\n샤이 배논에의해 2004년 부터 개발이 시작된 \u003ccode\u003eelasticsearch\u003c/code\u003e는 \u003ccode\u003eApache Lucene (검색 라이브러리)\u003c/code\u003e을 사용했으나 이것의 한계점을 발견하고 이를 보완한 새로운 검색엔진을 만들기 시작했다.\u003c/p\u003e\n\u003cp\u003e이것이 \u003ccode\u003eelasticsearch\u003c/code\u003e 프로젝트의 시작이 되었다.\u003c/p\u003e\n\u003cp\u003e샤이 베논이 검색 프로그램을 만들기 시작한 이유는 그의 아내가 요리공부를 시작하게 되어 레시피 검색을 돕는 프로그램을 만들면서 부터라고 한다. \u003cdel\u003e그 이후로 일이 이상하게 흘러가 여전히 레시피 검색 프로그램을 받지는 못한 모양이다\u003c/del\u003e\u003c/p\u003e\n\u003cp\u003e초기 \u003ccode\u003eelasticsearch\u003c/code\u003e는 \u003ccode\u003eLogstash\u003c/code\u003e와 \u003ccode\u003eKibana\u003c/code\u003e를 함께 사용하며 \u003ccode\u003eELK Stack\u003c/code\u003e이라 불리게 되었고 현재는 \u003ccode\u003eLogstash\u003c/code\u003e와 \u003ccode\u003eKibana\u003c/code\u003e를 흡수하여 함께 개발되고 있으며 \u003ccode\u003eElastic Stack\u003c/code\u003e이라는 명칭을 갖게 되었다.\u003c/p\u003e\n\u003ch3 id=\"elasticsearch의-역할\"\u003eElasticsearch의 역할\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003eElastic Stack\u003c/code\u003e의 가장 핵심적인 역할을 수행한다. 데이터 색인, 저장, 검색, 집계를 수행하고 결과를 클라이언트 또는 다른 프로그램으로 전달하는 역할을 수행한다.\u003c/p\u003e\n\u003ch3 id=\"elasticsearch의-특징\"\u003eElasticsearch의 특징\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cp\u003e\u003cstrong\u003e오픈소스\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e핵심 기능들은 Apache 2.0 라이센스로 배포된다. \u003cem\u003e모든 소스가 \u003ca href=\"https://github.elastic\"\u003e깃허브\u003c/a\u003e에 공개되어 있다.\u003c/em\u003e\u003c/li\u003e\n\u003cli\u003e6.3 버전 부터 Elastic 라이센스와 Apache 라이센스가 혼용되고 있지만 버전에 따른 별도의 배포판이 있다\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cp\u003e\u003cstrong\u003e실시간 분석\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e일반적인 데이터 분석시스템 (eg. \u003ccode\u003eHadoop\u003c/code\u003e) 은 배치 작업을 기본으로 한다. 소스데이터와 분석을 수행하는 프로그램을 분석 시스템에 올리고 실행하면 결과가 나오는 식의 방식이다\u003c/li\u003e\n\u003cli\u003e반면 \u003ccode\u003eelasticsearch\u003c/code\u003e는 클러스터가 실행되고 있는 동안 데이터가 입력됨과 동시에 색인된 데이터의 검색 집계가 가능하다\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cp\u003e\u003cstrong\u003e전문 검색 엔진\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e역색인 구조 (\u003ccode\u003einverted index\u003c/code\u003e)로 가공된 텍스트를 검색한다\u003c/li\u003e\n\u003cli\u003e내부적으로 역색인 구조로 데이터를 저장하고 있고 사용자 관점에서는 JSON 형식으로 데이터를 전달한다\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cp\u003e\u003cstrong\u003eRESTFul API\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e데이터 조회, 입력, 삭제를 http 프로토콜을 통해 Rest API로 처리한다\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cp\u003e\u003cstrong\u003e멀티테넌시\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eElasticsearch\u003c/code\u003e의 데이터는 \u003ccode\u003eindex\u003c/code\u003e를 기준으로 구분되어 저장된다. \u003ccode\u003eelasticsearch\u003c/code\u003e는 다른 \u003ccode\u003eindex\u003c/code\u003e에 속한 데이터를 별도의 커넥션 없이도 조회가 가능하고 이것을 \u003ccode\u003eelasticsearch\u003c/code\u003e에서는 멀티테넌시라한다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003ccode\u003eelasticsearch\u003c/code\u003e는 \u003ccode\u003eJSON\u003c/code\u003e 형식만 지원하고 있기 때문에 데이터의 입력을 위해서 반드시 JSON으로 변환하는 작업이 필요하다. \u003ccode\u003eLogstash\u003c/code\u003e를 이용하여 대부분의 파일형식을 JSON 형식으로 변경할 수 있다.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003ccode\u003eelasticsearch\u003c/code\u003e는 내부적으로 역색인 구조의 데이터를 저장한다. 이를 통해 데이터의 양이 늘어남에 따라 조회 대상이 늘어나는 일반적인 RDBMS와 달리 \u003ccode\u003eterm\u003c/code\u003e을 통해 해당 \u003ccode\u003eterm\u003c/code\u003e이 포함되어 있는 도큐먼트의 아이디를 찾게되고 결과적으로 검색 성능을 향상 시킬 수 있다. 역색인 구조로 데이터를 가공하여 저장하는 절차는 새로운 도큐먼트가 추가될 때 발생하기 때문에 \u003ccode\u003eelasticsearch\u003c/code\u003e는 저장이 아닌 색인이란 표현을 사용한다.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch2 id=\"clustering\"\u003eClustering\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003eElasticsearch\u003c/code\u003e 노드들은 \u003ccode\u003ecluster.name\u003c/code\u003e을 설정으로 갖는데 동일한 \u003ccode\u003ecluster.name\u003c/code\u003e을 가지고 있는 노드들은 하나의 클러스터에 포함된다.\n클러스터링은 하나의 서버에서 여러개로 구분될 수 있고 거꾸로 여러개의 서버에서 하나의 클러스터를 구성할 수 있다.\n다른 네트워크 환경에 구성되어 있는 클러스터는 \u003ccode\u003ediscover.seed_hosts\u003c/code\u003e 설정을 통해 서로를 탐색하고 하나의 클러스터로 구성 될 수 있다. 자세한 내용은 \u003ca href=\"https://www.elastic.co/guide/en/elasticsearch/reference/current/important-settings.html\"\u003e공식문서\u003c/a\u003e를 통해 확인 할 수 있다.\u003c/p\u003e\n\u003ch3 id=\"node의-종류\"\u003eNode의 종류\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003eMaster node\u003c/li\u003e\n\u003cli\u003eData node\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3 id=\"master-node\"\u003eMaster node\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003eelasticsearch\u003c/code\u003e의 클러스터는 반드시 하나의 마스터 노드를 포함하고 있어야 한다. 마스터 노드는 인덱스의 메타 데이터, 데이터가 분산 저장되어 있는 위치와 같은 클러스터의 상태 정보를 관리한다. 마스터노드가 관리하는 데이터가 유실되면 클러스터 전체가 작동하지 않기 때문에 마스터 노드가 어떠한 이유에 의해 중지되었을 때 이를 대신할 마스터 노드 후보자가 필요하다.\u003c/p\u003e\n\u003cp\u003e모든 노드는 기본적으로 마스터 노드가 될 수 있는 후보자로 등록된다. 후보자로 등록되어 있는 노드들은 마스터 노드가 정상적으로 동작하고 있더라도 마스터 노드에서 관리되는 메타 데이터를 가지고 있게된다. 이렇게 하는 것을 통해 갑작스레 마스터 노드가 유실 되었을 때 곧바로 후보자중 하나가 마스터 노드의 역할을 대신 수행 할 수 있기 때문이다.\u003c/p\u003e\n\u003cp\u003e클러스터의 규모가 커짐에 따라 불필요하게 많은 마스터 노드의 후보자가 생성될 수 있는데 이것은 성능에 안좋은 영향을 미치게 되고 이런 문제를 사전에 방지하기 위해 \u003ccode\u003enode.master\u003c/code\u003e 설정을 통해 후보자로 등록될지 여부를 결정 할 수 있다.\u003c/p\u003e\n\u003ch3 id=\"data-node\"\u003eData node\u003c/h3\u003e\n\u003cp\u003e데이터 노드는 실제로 색인된 데이터를 저장하고 있는 노드이다. 마스터 노드와 마찬가지로 \u003ccode\u003enode.data\u003c/code\u003e 설정을 통해 데이터 노드의 역할을 수행할지 여부를 결정 할 수 있다.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e그 밖의 노드의 역할\u003c/p\u003e\n\u003cp\u003e\u003cem\u003enode.ingest\u003c/em\u003e\u003c/p\u003e\n\u003cp\u003e데이터 색인 전처리 작업인 ingest pipeline 작업\u003c/p\u003e\n\u003cp\u003enode.ingest 설정을 통해 해당 역할을 on/off 할 수 있다.\u003c/p\u003e\n\u003cp\u003e\u003cem\u003enode.ml\u003c/em\u003e\u003c/p\u003e\n\u003cp\u003e머신러닝 작업\u003c/p\u003e\n\u003cp\u003enode.ml 설정을 통해 해당 역할을 on/off 할 수 있다.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cblockquote\u003e\n\u003cp\u003e마스터 노드와 데이터 노드의 성능 향상\u003c/p\u003e\n\u003cp\u003e마스터 노드와 데이터 노드는 두가지 역할을 함께 수행 할 수 있지만 각자에 역할만 수행하도록 설정하는 것을 통해 성능상의 이점을 얻을 수 있다.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch4 id=\"split-brain\"\u003eSplit Brain\u003c/h4\u003e\n\u003cp\u003e클러스터를 구성 할 때 마스터 노드를 최소 3개 이상의 \u0026#39;홀수\u0026#39;로 구성하는 것을 권장한다. 만약 마스터 후보 노드가 2개 또는 짝수로 구성할 경우 네트워크 유실로 인해 분리된 두개의 클러스터로 구성되어 계속 동작할 수 있는데 각기 다른 형상의 데이터를 저장하게 된다. 네트워크가 다시 연결되어 정상 상태인 하나의 클러스터로 묶일 때 데이터의 정합성과 무결성을 유지할 수 없게 된다. 이런 문제를 \u003ccode\u003eSplit Brain\u003c/code\u003e이라 한다.\u003c/p\u003e\n\u003ch3 id=\"node의-데이터-저장\"\u003eNode의 데이터 저장\u003c/h3\u003e\n\u003cp\u003eelasticsearch에서는 단일 데이터 단위를 \u003ccode\u003edocument\u003c/code\u003e라고 하며 이 \u003ccode\u003edocument\u003c/code\u003e의 집합을 \u003ccode\u003eindex\u003c/code\u003e라고 한다.\nNode에 데이터를 저장할 때 \u003ccode\u003edocument\u003c/code\u003e의 집합인 \u003ccode\u003eindex\u003c/code\u003e는 다 시 \u003ccode\u003eshard\u003c/code\u003e라는 단위로 분리되어 저장되게 된다. 분리된 \u003ccode\u003eshard\u003c/code\u003e는 클러스터에 포함된 노드들에 의해 나뉘어 보관된다. 뿐만 아니라 \u003ccode\u003eshard\u003c/code\u003e는 \u003ccode\u003ereplica\u003c/code\u003e라고 불리는 복제본을 생성하게 되며 이 복제본들 또한 노드들에 의해 나뉘어 보관된다.\u003c/p\u003e\n\u003cp\u003e이렇게 분리된 \u003ccode\u003eshard\u003c/code\u003e와 \u003ccode\u003ereplica\u003c/code\u003e에 의해 클러스터의 특정 노드에 문제가 발생하여 데이터가 유실되더라도 다른 노드에 보관중인 \u003ccode\u003ereplica\u003c/code\u003e와 \u003ccode\u003eshard\u003c/code\u003e에 의해 데이터의 유실을 방지 할 수 있다.\u003c/p\u003e\n\u003cp\u003enode가 실행을 멈추게 되면 일정시간동안 node의 재실행을 기다리고 timeout이 발생하게 되면 남아 있는 노드에 유실된 \u003ccode\u003eshard\u003c/code\u003e와 \u003ccode\u003ereplica\u003c/code\u003e를 다시 생성하는 것을 통해 다시 발생할지도 모르는 장애로인한 데이터 유실을 방지한다.\u003c/p\u003e\n\u003ch2 id=\"rest-api를-이용한-crud\"\u003eREST API를 이용한 CRUD\u003c/h2\u003e\n\u003cp\u003eelasticsearch는 도큐먼트 별로 고유한 URL을 갖는다. URL은 아래의 패턴을 갖는다\u003c/p\u003e\n\u003cdiv align=center\u003ehttp://host:port/index/doc type/doc id\u003c/div\u003e\n\n\u003ch3 id=\"입력-put\"\u003e입력 (PUT)\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003econst response = await fetch(\u0026#39;http://localhost:9200/new_index/_doc/1\u0026#39;, {\n  method: \u0026#39;put\u0026#39;,\n  headers: { [\u0026#39;Content-Type\u0026#39;]: \u0026#39;application/json\u0026#39; },\n  body: JSON.stringify({\n    name: \u0026#39;Code Logs\u0026#39;,\n  }),\n})\n\nconsole.log((await response.json()).result) // created\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003enew_index\u003c/code\u003e라는 명칭의 인덱스에 새로운 도큐먼트가 추가 되었다 정상적으로 데이터가 추가되면 \u003ccode\u003ecreated\u003c/code\u003e를 response.result로 응답한다.\u003c/p\u003e\n\u003cp\u003e동일한 요청을 다시 보내게 되면 대상 도큐먼트가 덮어씌워지게 된다. 이 경우에는 \u003ccode\u003ecreated\u003c/code\u003e 대신 \u003ccode\u003eupdated\u003c/code\u003e를 response.result로 응답한다.\u003c/p\u003e\n\u003cp\u003e도큐먼트가 덮어 씌워지는 것을 방지하기 위해 요청시 도큐먼트 타입을 \u003ccode\u003e_create\u003c/code\u003e로 지정 할 수 있다. 이렇게 하면 해당 아이디를 가진 도큐먼트가 이미 존재 할 경우 에러를 발생시키고 그렇지 않을 경우에만 새로운 도큐먼트를 저장한다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003econst response = await fetch(\u0026#39;http://localhost:9200/new_index/_create/1\u0026#39;, {\n  method: \u0026#39;put\u0026#39;,\n  headers: { [\u0026#39;Content-Type\u0026#39;]: \u0026#39;application/json\u0026#39; },\n  body: JSON.stringify({ name: \u0026#39;Code Logs\u0026#39; }),\n})\n\nif (!response.ok) console.log((await response.json()).error.reason) // [1]: version conflict, document already exists (current version [2])\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"조회-get\"\u003e조회 (GET)\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003econst response = await fetch(\u0026#39;http://localhost:9200/new_index/_doc/1\u0026#39;)\nconsole.log((await response.json())._source) // { name: \u0026#39;Code Logs\u0026#39; }\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e도큐먼트를 조회하면 저장되어 있는 데이터 외에도 다양한 정보를 응답한다. 데이터는 \u003ccode\u003e_source\u003c/code\u003e 프로퍼티를 통해 접근 할 수 있다.\u003c/p\u003e\n\u003ch3 id=\"삭제-delete\"\u003e삭제 (DELETE)\u003c/h3\u003e\n\u003cp\u003e도큐먼트 또는 인덱스 단위로 데이터를 삭제 할 수 있다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003e// 도큐먼트 단위 삭제\nconst response = await fetch(\u0026#39;http://localhost:9200/new_index/_doc/1\u0026#39;, {\n  method: \u0026#39;delete\u0026#39;,\n})\n\nconsole.log((await response.json()).result) // deleted\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003e// 인덱스 단위 삭제\nconst response = await fetch(\u0026#39;http://localhost:9200/new_index\u0026#39;, {\n  method: \u0026#39;delete\u0026#39;,\n})\n\nconsole.log((await response.json()).acknowledged) // true\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"수정-post\"\u003e수정 (POST)\u003c/h3\u003e\n\u003cp\u003ePOST 메서드는 PUT 메서드와 마찬가지로 데이터 입력에 사용된다. 도큐먼트를 입력 할 때 도큐먼트 아이디를 생략하게 되면 임의의 도큐먼트 아이디가 자동으로 생성된다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003econst response = await fetch(\u0026#39;http://localhost:9200/new_index/_doc\u0026#39;, {\n  method: \u0026#39;post\u0026#39;,\n  headers: { [\u0026#39;Content-Type\u0026#39;]: \u0026#39;application/json\u0026#39; },\n  body: JSON.stringify({ name: \u0026#39;Code Logs\u0026#39; }),\n})\n\nconst { result, _id } = await response.json()\nconsole.log(_id) // 임의 아이디\nconsole.log(result) // created\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"_update\"\u003e_update\u003c/h3\u003e\n\u003cp\u003ePOST 또는 PUT 메서드를 통해 도큐먼트를 업데이트 하려면 대상 도큐먼트의 모든 필드를 다시 입력해야 하는 번거로움이 있다. 이럴 경우 \u003ccode\u003e_update\u003c/code\u003e 도큐먼트 타입을 이용하면 수정하고자 하는 필드만 업데이트 할 수 있다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003econst response = await fetch(\u0026#39;http://localhost:9200/new_index/_update/1\u0026#39;, {\n  method: \u0026#39;post\u0026#39;,\n  headers: { [\u0026#39;Content-type\u0026#39;]: \u0026#39;application/json\u0026#39; },\n  body: JSON.stringify({\n    doc: {\n      description: \u0026#39;Personal blog about web development\u0026#39;,\n    },\n  }),\n})\n\nconsole.log((await response.json()).result) // updated\n\u003c/code\u003e\u003c/pre\u003e\n\u003cblockquote\u003e\n\u003cp\u003e_version 프로퍼티\u003c/p\u003e\n\u003cp\u003e도큐먼트를 조회 했을 때 받게되는 응담의 프로퍼티중 \u003ccode\u003e_version\u003c/code\u003e 프로퍼티는 해당 도큐먼트의 변경이 발생함에 따라 1씩 증가하게 된다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003e_update\u003c/code\u003e 도큐먼트 타입을 통해 일부 필드가 수정되더라도 \u003ccode\u003e_version\u003c/code\u003e은 1 증가하는 것을 확인 할 수 있는데 그 이유는 내부적으로 업데이트 대상 도큐먼트를 모두 가지고와 일부 필드만 수정한 뒤 전체 내용을 PUT하는 방식으로 동작하기 때문이다.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch3 id=\"벌크-api\"\u003e벌크 API\u003c/h3\u003e\n\u003cp\u003e여러 유형의 명령을 배치로 수행하기 위해서 \u003ccode\u003e_bulk\u003c/code\u003e API를 사용 할 수 있다. \u003ccode\u003e_bulk\u003c/code\u003e API는 \u003ccode\u003edelete\u003c/code\u003e를 제외하고 명령문과 데이터문을 한 줄 씩 순서대로 입력해야 한다.\n\u003ccode\u003edelete\u003c/code\u003e는 입력할 데이터가 없기 때문에 명령문만 입력한다.\u003c/p\u003e\n\u003cp\u003e다음 예제는 아래의 명령을 한번에 실행하는 것이다.\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003euser index에 id가 1인 { name: \u0026#39;Jay\u0026#39;, age: 20 } 생성\u003c/li\u003e\n\u003cli\u003euser index에 id가 2인 { name: \u0026#39;Lee\u0026#39;, age: 21 } 생성\u003c/li\u003e\n\u003cli\u003efruit index에 id가 1인 { name: \u0026#39;apple\u0026#39;, price: 2000 } 생성\u003c/li\u003e\n\u003cli\u003euser index에 id가 2인 도큐먼트 삭제\u003c/li\u003e\n\u003cli\u003efruit index에 id가 1인 도큐먼트의 { description: \u0026#39;Fresh and delicious apple\u0026#39; } 업데이트\u003c/li\u003e\n\u003c/ol\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003econst commands = [\n  { index: { _index: \u0026#39;user\u0026#39;, _id: \u0026#39;1\u0026#39; } },\n  { name: \u0026#39;Jay\u0026#39;, age: \u0026#39;20\u0026#39; },\n  { index: { _index: \u0026#39;user\u0026#39;, _id: \u0026#39;2\u0026#39; } },\n  { name: \u0026#39;Lee\u0026#39;, age: \u0026#39;21\u0026#39; },\n  { index: { _index: \u0026#39;fruit\u0026#39;, _id: \u0026#39;1\u0026#39; } },\n  { name: \u0026#39;apple\u0026#39;, price: \u0026#39;2000\u0026#39; },\n  { delete: { _index: \u0026#39;user\u0026#39;, _id: \u0026#39;2\u0026#39; } },\n  { update: { _index: \u0026#39;fruit\u0026#39;, _id: \u0026#39;1\u0026#39; } },\n  { doc: { description: \u0026#39;Fresh and delicious apple\u0026#39; } },\n]\nconst response = await fetch(\u0026#39;http://localhost:9200/_bulk\u0026#39;, {\n  method: \u0026#39;post\u0026#39;,\n  headers: { [\u0026#39;Content-type\u0026#39;]: \u0026#39;application/json\u0026#39; },\n  body: commands.map((c) =\u0026gt; JSON.stringify(c)).join(\u0026#39;\\n\u0026#39;) + \u0026#39;\\n\u0026#39;,\n})\n\nconsole.log((await response.json()).items) // (5) [{…}, {…}, {…}, {…}, {…}]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003e_bulk\u003c/code\u003e API를 통해 변경된 도큐먼트의 응답은 \u003ccode\u003eitems\u003c/code\u003e 프로퍼티를 통해 확인 할 수 있다.\u003c/p\u003e\n\u003cp\u003e만약 조작하고자하는 도큐먼트가 모두 하나의 index에 속해 있다면 아래와 같이 index를 명시한 상태로 호출 할 수 있다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003econst commands = [\n  { index: { _id: 1 } },\n  { name: \u0026#39;Jay\u0026#39;, age: 20 },\n  { index: { _id: 2 } },\n  { name: \u0026#39;Lee\u0026#39;, age: 21 },\n  { delete: { _id: 2 } },\n]\nconst response = await fetch(\u0026#39;http://localhost:9200/user/_bulk\u0026#39;, {\n  method: \u0026#39;post\u0026#39;,\n  headers: { [\u0026#39;Content-type\u0026#39;]: \u0026#39;application/json\u0026#39; },\n  body: commands.map((c) =\u0026gt; JSON.stringify(c)).join(\u0026#39;\\n\u0026#39;) + \u0026#39;\\n\u0026#39;,\n})\n\nconsole.log((await response.json()).items) // (3) [{…}, {…}, {…}]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cblockquote\u003e\n\u003cp\u003eelasticsearch는 \u003ccode\u003ecommit\u003c/code\u003e, \u003ccode\u003erollback\u003c/code\u003e, \u003ccode\u003etransaction\u003c/code\u003e 개념이 존재하지 않는다 만약 \u003ccode\u003e_bulk\u003c/code\u003e API를 통해 여러 도큐먼트를 대상으로 작업을 수행하던 중 문제가 발생하면 수행이 완료된 index를 찾을 수 없기 때문에 모든 index를 삭제하고 다시 전체 bulk 작업을 수행하는 것을 권장한다.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch2 id=\"_search-api\"\u003e_search API\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003e_search\u003c/code\u003e API를 통해 인덱스 단위의 검색을 할 수 있다.\n\u003ccode\u003eGET\u003c/code\u003e 메서드를 이용하여 아래의 형식으로 조회를 요청 할 수 있다.\u003c/p\u003e\n\u003cdiv align=center\u003ehttp://localhost:9200/target_index/_search\u003c/div\u003e\n\n\u003ch3 id=\"uri-검색\"\u003eURI 검색\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003eq\u003c/code\u003e 파라메터를 이용하여 검색 조건을 설정 할 수 있다. 검색 조건이 존재하지 않을 경우 인덱스의 모든 도큐먼트를 대상으로 검색을 수행한다.\u003c/p\u003e\n\u003cp\u003e이러한 검색 방식을 \u003ccode\u003eURI 검색\u003c/code\u003e이라 한다.\u003c/p\u003e\n\u003cdiv align=center\u003ehttp://localhost:9200/target_index/_search?q=condition\u003c/div\u003e\n\n\u003cblockquote\u003e\n\u003cp\u003eAND 조건으로 검색하기\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"http://localhost:9200/target_index/%5C_search?q=condition1\"\u003ehttp://localhost:9200/target_index/\\_search?q=condition1\u003c/a\u003e AND condition2\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cblockquote\u003e\n\u003cp\u003e검색 조건을 특정 필드로 한정하기\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"http://localhost:9200/target_index/%5C_search?q=field:condition1\"\u003ehttp://localhost:9200/target_index/\\_search?q=field:condition1\u003c/a\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch3 id=\"멀티테넌시\"\u003e멀티테넌시\u003c/h3\u003e\n\u003cp\u003e멀티네넌시는 한번에 여러 인덱스를 대상으로 검색하는 것을 의미한다. 여러 인덱스를 검색할때는 \u003ccode\u003e,\u003c/code\u003e로 구분하여 나열하거나 \u003ccode\u003e*\u003c/code\u003e 와일드 카드를 통해 표현 할 수 있다.\u003c/p\u003e\n\u003cdiv align=center\u003ehttp://localhost:9200/target_index1,target_index2/_search\u003c/div\u003e\n\n\u003cdiv align=center\u003ehttp://localhost:9200/target_index*/_search\u003c/div\u003e\n\n\u003cblockquote\u003e\n\u003cp\u003e인덱스를 지정하지 않고 클러스터 내부의 모든 인덱스를 대상으로 검색을 하려면 \u003ccode\u003e_all\u003c/code\u003e 지정자를 사용할 수 있지만 시스템 사용을 위해 정의된 인덱스에도 접근하게 되어 불필요한 작업을 수행하게 되므로 권장되지 않는다.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch2 id=\"full-text-search\"\u003eFull-text search\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003eelasticsearch\u003c/code\u003e는 검색시 주어지는 조건의 대소문자, 단수, 복수, 원형의 여부와 상관 없이 검색이 가능하도록 \u003ccode\u003eTerm\u003c/code\u003e으로 분석하는 과정을 거친 뒤 데이터를 저장한다.\n이런 전처리 과정을 거친 결과로 Full-text search가 가능하게 된다.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eDSL - 도메인 특화 언어 (Domain Specific Language)\u003c/p\u003e\n\u003cp\u003e도메인 특화 언어는 특정한 도메인에 적용하도록 최적화된 프로그래밍 언어이다. Elasticsearch는 JSON 형태의 Query DSL을 사용한다.\u003c/p\u003e\n\u003cp\u003eQuery DSL을 통해 \u003ccode\u003e데이터 본문 (Data body) 검색\u003c/code\u003e을 할 수 있다.\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://ko.wikipedia.org/wiki/%EB%8F%84%EB%A9%94%EC%9D%B8_%ED%8A%B9%ED%99%94_%EC%96%B8%EC%96%B4\"\u003ewiki\u003c/a\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch3 id=\"match_all\"\u003ematch_all\u003c/h3\u003e\n\u003cp\u003e특별한 조건 없이 특정 인덱스의 모든 도큐먼트를 검색하는 쿼리\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003econst response = await fetch(\u0026#39;http://localhost:9200/target_index/_search\u0026#39;, {\n  method: \u0026#39;post\u0026#39;,\n  headers: { [\u0026#39;Content-type\u0026#39;]: \u0026#39;application/json\u0026#39; },\n})\n\u003c/code\u003e\u003c/pre\u003e\n\u003cblockquote\u003e\n\u003cp\u003eFull-text search를 진행하기 위해서 앞서 살펴본 URI 검색이 아닌 \u003ccode\u003e데이터 본문 (Data body) 검색\u003c/code\u003e을 이용해야 한다.\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://www.npmjs.com/package/@elastic/elasticsearch\"\u003e@elastic/elasticsearch\u003c/a\u003e 모듈을 이용해 데이터 본문 검색을 사용할 수 있다.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch3 id=\"match\"\u003ematch\u003c/h3\u003e\n\u003cp\u003e가장 일반적으로 사용되는 풀 텍스트 검색 쿼리로 특정 필드에 특정한 값이 포함되는 도큐먼트를 조회하는데 사용된다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003econst response = await fetch(\u0026#39;http://localhost:9200/target_index/_search\u0026#39;, {\n  method: \u0026#39;post\u0026#39;,\n  headers: { [\u0026#39;Content-type\u0026#39;]: \u0026#39;application/json\u0026#39; },\n  body: JSON.stringify({\n    query: {\n      match: {\n        field: \u0026#39;condition\u0026#39;,\n      },\n    },\n  }),\n})\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003ematch\u003c/code\u003e 검색을 사용할 때 여러개의 검색어를 집어 넣으면 기본적으로 \u003ccode\u003eOR\u003c/code\u003e 조건으로 검색이 된다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003econst response = await fetch(\u0026#39;http://localhost:9200/target_index/_search\u0026#39;, {\n  method: \u0026#39;post\u0026#39;,\n  headers: { [\u0026#39;Content-type\u0026#39;]: \u0026#39;application/json\u0026#39; },\n  body: JSON.stringify({\n    query: {\n      match: {\n        field: \u0026#39;condition1 condition2\u0026#39;,\n      },\n    },\n  }),\n})\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e여러 검색어를 \u003ccode\u003eAND\u003c/code\u003e 조건으로 검색하려면 \u003ccode\u003eoperator\u003c/code\u003e 옵션을 사용한다. \u003ccode\u003eAND\u003c/code\u003e 조건으로 검색할 때는 본문의 형식이 달라지는 것에 유의한다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003econst response = await fetch(\u0026#39;http://localhost:9200/target_index/_search\u0026#39;, {\n  method: \u0026#39;post\u0026#39;,\n  headers: { [\u0026#39;Content-type\u0026#39;]: \u0026#39;application/json\u0026#39; },\n  body: JSON.stringify({\n    query: {\n      match: {\n        field: {\n          query: \u0026#39;condition1 condition2\u0026#39;,\n          operator: \u0026#39;and\u0026#39;,\n        },\n      },\n    },\n  }),\n})\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"match_phrase\"\u003ematch_phrase\u003c/h3\u003e\n\u003cp\u003e검색어로 나열된 조건들을 공백을 포함한 하나의 문자열 조건으로 검색할 때 사용한다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003econst response = await fetch(\u0026#39;http://localhost:9200/target_index/_search\u0026#39;, {\n  method: \u0026#39;post\u0026#39;,\n  headers: { [\u0026#39;Content-type\u0026#39;]: \u0026#39;application/json\u0026#39; },\n  body: JSON.stringify({\n    query: {\n      match_phrase: {\n        field: \u0026#39;condition1 condition2\u0026#39;,\n      },\n    },\n  }),\n})\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e나열된 검색어 사이에 n 개의 단어를 포함하여 검색하도록 하기 위해 \u003ccode\u003eslop\u003c/code\u003e 속성을 사용한다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003econst response = await fetch(\u0026#39;http://localhost:9200/target_index/_search\u0026#39;, {\n  method: \u0026#39;post\u0026#39;,\n  headers: { [\u0026#39;Content-type\u0026#39;]: \u0026#39;application/json\u0026#39; },\n  body: JSON.stringify({\n    query: {\n      match_phrase: {\n        field: \u0026#39;condition1 condition2\u0026#39;,\n        slop: 1, // condition1 something condition2와 같은 형식의 데이터 조회 가능\n      },\n    },\n  }),\n})\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e위 예제에서 \u003ccode\u003eslop\u003c/code\u003e을 1로 설정 했기 때문에 \u003ccode\u003econdition1\u003c/code\u003e과 \u003ccode\u003econdition2\u003c/code\u003e 사이에 한개의 추가적인 단어가 존재하는 도큐먼트를 조회하게 된다.\u003c/p\u003e\n\u003ch3 id=\"query_string\"\u003equery_string\u003c/h3\u003e\n\u003cp\u003e\u003ca href=\"#uri-%EA%B2%80%EC%83%89\"\u003eURI 검색\u003c/a\u003e에서 사용했던 \u003ccode\u003eq\u003c/code\u003e 파라메터를 데이터 본문 검색을 통해 수행할 수 있다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003econst response = await fetch(\u0026#39;http://localhost:9200/target_index/_search\u0026#39;, {\n  method: \u0026#39;post\u0026#39;,\n  headers: { [\u0026#39;Content-type\u0026#39;]: \u0026#39;application/json\u0026#39; },\n  body: JSON.stringify({\n    query: {\n      query_string: {\n        default_field: \u0026#39;field\u0026#39;,\n        query: \u0026#39;condition1 AND condition2\u0026#39;,\n      },\n    },\n  }),\n})\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003equery_string\u003c/code\u003e을 이용해서도 \u003ccode\u003ematch_phrase\u003c/code\u003e와 같이 구문을 검색이 가능한데 그럴 경우 검색어를 \u003ccode\u003e\\\u0026quot;\u003c/code\u003e로 묶어주면 된다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003econst response = await fetch(\u0026#39;http://localhost:9200/target_index/_search\u0026#39;, {\n  method: \u0026#39;post\u0026#39;,\n  headers: { [\u0026#39;Content-type\u0026#39;]: \u0026#39;application/json\u0026#39; },\n  body: JSON.stringify({\n    query: {\n      query_string: {\n        default_field: \u0026#39;field\u0026#39;,\n        query: \u0026#39;(condition1 AND condition2) OR \u0026quot;condition3 condition4\u0026quot;\u0026#39;,\n      },\n    },\n  }),\n})\n\u003c/code\u003e\u003c/pre\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003ccode\u003equery_string\u003c/code\u003e을 이용하여 구문 검색을 할 때 \u003ccode\u003eslop\u003c/code\u003e은 사용 할 수 없다.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch3 id=\"bool-query\"\u003ebool query\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003e데이터 본문 검색\u003c/code\u003e을 통해 복합적인 조건을 구성하려면 \u003ccode\u003ebool query (복합쿼리)\u003c/code\u003e를 이용해야한다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003ebool query\u003c/code\u003e는 다음의 네가지 인자를 가지고 있으며 각 인자에 따라 검색 조건이 달라진다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003emust\u003cul\u003e\n\u003cli\u003e조건이 반드시 true인 도큐먼트를 검색한다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003emust_not\u003cul\u003e\n\u003cli\u003e조건이 반드시 false인 도큐먼트를 검색한다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eshould\u003cul\u003e\n\u003cli\u003e검색된 결과중 이 조건에 부함하는 도큐먼트의 정확도 점수를 높인다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003efilter\u003cul\u003e\n\u003cli\u003e조건이 반드시 true인 도큐먼트를 검색하되 정확도 점수를 계산하지 않아 속도가 빠르고 캐싱이 된다는 장점이 있다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003econst response = await fetch(\u0026#39;http://localhost:9200/target_index/_search\u0026#39;, {\n  method: \u0026#39;post\u0026#39;,\n  headers: { [\u0026#39;Content-type\u0026#39;]: \u0026#39;application/json\u0026#39; },\n  body: JSON.stringify({\n    query: {\n      bool: {\n        must: [\n          {\n            match: {\n              field: \u0026#39;condition 1\u0026#39;,\n            },\n          },\n        ],\n        must_not: [\n          {\n            match: {\n              field: \u0026#39;condition 3\u0026#39;,\n            },\n          },\n        ],\n        should: [\n          {\n            match_phrase: {\n              field: \u0026#39;condition1 condition2\u0026#39;,\n            },\n          },\n        ],\n      },\n    },\n  }),\n})\n\u003c/code\u003e\u003c/pre\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003ccode\u003eshould\u003c/code\u003e를 이용한 검색 정확도 가중치 부여하기\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eelasticsearch\u003c/code\u003e는 기본적으로 검색 결과의 정확도를 기준으로 결과를 정렬한다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003ebool query\u003c/code\u003e를 통해 도큐먼트를 조회 할 때 필요에 따라 더 중요한 키워드를 \u003ccode\u003eshould\u003c/code\u003e 속성에 포함시켜 정확도 점수에 가중치를 부여할 수 있고 결과적으로 도큐먼트중 더 중요한 결과를 상위에 노출 시킬 수 있다.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003ccode\u003efilter\u003c/code\u003e를 이용한 검색 정확도 배제하기\u003c/p\u003e\n\u003cp\u003e경우에 따라 겸색어가 정확도에 영향을 미쳐선 안되는 상황이 벌어질 수 있다. 이런 경우의 검색어 조건을 \u003ccode\u003efilter\u003c/code\u003e 속성에 포함시켜 정확도 점수에 영향을 주지 않도록 설정하고 검색 할 수 있다.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch2 id=\"analyzer\"\u003eAnalyzer\u003c/h2\u003e\n\u003cp\u003e관계형 데이터베이스의 일반적인 조회가 아닌 \u003ccode\u003eFull-text search\u003c/code\u003e를 이용하는 것을 통해 얻을 수 있는 이점중 하나는 동의어 검색 또는 원형을 통한 검색 (ex. \u003cem\u003e먹었다\u003c/em\u003e 라는 키워드를 통해 동일한 원형 (\u003cem\u003e먹다\u003c/em\u003e)을 갖고 있는 키워드 (\u003cem\u003e먹었는데\u003c/em\u003e, \u003cem\u003e먹고\u003c/em\u003e)를 포함하는 도큐먼트를 조회하는 것)이다.\u003c/p\u003e\n\u003cp\u003e앞서 살펴본바와 같이 \u003ccode\u003eelasticsearch\u003c/code\u003e는 역색인 구조를 통해 도큐먼트를 조회하기 때문에 이런 고급검색 기능을 사용하기 위해서는 동의어와 원형을 통해 도큐먼트를 찾을 수 있도록 데이터를 저장하는 시점에 미리 적절한 index를 생성해야 한다.\u003c/p\u003e\n\u003cp\u003e저장하려는 데이터를 분석하여 적절한 index를 설정하는 것이 Analyzer의 역할이다.\u003c/p\u003e\n\u003ch3 id=\"analyzer의-구조\"\u003eAnalyzer의 구조\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003eAnalyzer\u003c/code\u003e는 다음 세가지 요소의 조합으로\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eCharacter filters\u003c/li\u003e\n\u003cli\u003eTokenizer\u003c/li\u003e\n\u003cli\u003eToken filters\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e저장 되려는 데이터는 각 요소를 거쳐 최종적으로 필요한 인덱스를 생성하며 저장된다.\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003cp\u003eCharacter filters\u003c/p\u003e\n\u003cp\u003e문장을 특정 문자로 대치하거나 제거하는 과장을 담당하는 필터\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cp\u003eTokenizer\u003c/p\u003e\n\u003cp\u003e입력된 도큐먼트를 어떤 기준을 통해 잘라내는 과정 (일반적으로는 whitespace를 기준으로 함)\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cp\u003eToken filters\u003c/p\u003e\n\u003cp\u003e잘라진 도큐먼트 요소들을 돌며 최종적인 index 키워드를 생성하는 과정으로 동의어, 원형등을 만들어 내고 (ing, ed 등의 접미사를 제거하거나 등록되어 있는 사전을 통해 동의어를 찾아 등록하는 등) 그렇게 만들어진 index와 도큐먼트를 연결함\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003cblockquote\u003e\n\u003cp\u003eTokenizer는 Character filters, token filters와 달리 반드시 하나만 정용 할 수 있다.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch3 id=\"analyzer-적용\"\u003eAnalyzer 적용\u003c/h3\u003e\n\u003cp\u003e별도의 설정 없이 생성된 \u003ccode\u003eelasticsearch\u003c/code\u003e의 \u003ccode\u003eindex\u003c/code\u003e는 기본값인 \u003ccode\u003estandard analyzer\u003c/code\u003e가 설정되어 있다. \u003ccode\u003estandard analyzer\u003c/code\u003e를 통해 생성된 색인은 이 문서의 소기의 목적이였던 \u003ccode\u003efull-text search\u003c/code\u003e의 강력한 기능들을 사용 할 수 없다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eindex\u003c/code\u003e를 생성하는 시점에 어떤 \u003ccode\u003eanalyzer\u003c/code\u003e를 사용할지 정의해야한다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003econst response = await fetch(\u0026#39;http://localhost:9200/target_index\u0026#39;, {\n  method: \u0026#39;put\u0026#39;,\n  headers: { [\u0026#39;Content-type\u0026#39;]: \u0026#39;application/json\u0026#39; },\n  body: JSON.stringify({\n    mappings: {\n      properties: {\n        name: {\n          type: \u0026#39;text\u0026#39;,\n          analyzer: \u0026#39;snowball\u0026#39;,\n        },\n      },\n    },\n  }),\n})\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003eindex\u003c/code\u003e가 생성되는 시점에 도큐먼트의 \u003cem\u003ename\u003c/em\u003e 필드에 \u003cem\u003esnowball\u003c/em\u003e analyzer를 적용하는 예시이다.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003esnowball은 elasticsearch가 기본적으로 제공하는 analyzer\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e이렇게 생성된 \u003ccode\u003eindex\u003c/code\u003e에 데이터를 저장하게 되면 앞서 이야기한 \u003ccode\u003eCharacter filter\u003c/code\u003e, \u003ccode\u003eTokenizer\u003c/code\u003e, \u003ccode\u003eToken filter\u003c/code\u003e를 적절한 색인이 생성되고 마침내 동의어, 원형 검색 등이 가능하게 된다.\u003c/p\u003e\n\u003ch3 id=\"사용자-정의-analyzer\"\u003e사용자 정의 Analyzer\u003c/h3\u003e\n\u003cp\u003e사용자의 정의 \u003ccode\u003eanalyzer\u003c/code\u003e는 character filter, tokenizer를 정의하고 token filter들을 조합하는 것을 통해 설정한다.\u003c/p\u003e\n\u003cp\u003e마찬가지로 \u003ccode\u003eindex\u003c/code\u003e를 생성하는 시점에 해당 작업을 수행해야 한다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003econst response = await fetch(\u0026#39;http://localhost:9200/target_index\u0026#39;, {\n  method: \u0026#39;put\u0026#39;,\n  headers: { [\u0026#39;Content-type\u0026#39;]: \u0026#39;application/json\u0026#39; },\n  body: JSON.stringify({\n    settings: {\n      analysis: {\n        analyzer: {\n          custom_analyzer: {\n            char_filter: [\u0026#39;custom_char_filter\u0026#39;],\n            tokenizer: \u0026#39;whitespace\u0026#39;,\n            filter: [\u0026#39;lowercase\u0026#39;, \u0026#39;snowball\u0026#39;],\n          },\n        },\n        char_filter: {\n          custom_char_filter: {\n            type: \u0026#39;mapping\u0026#39;,\n            mappings: [\u0026#39;as soon as possible\u0026#39;, \u0026#39;_asap_\u0026#39;],\n          },\n        },\n      },\n    },\n    mappings: {\n      properties: {\n        message: {\n          type: \u0026#39;text\u0026#39;,\n          analyzer: \u0026#39;custom_analyzer\u0026#39;,\n        },\n      },\n    },\n  }),\n})\n\u003c/code\u003e\u003c/pre\u003e\n\u003cblockquote\u003e\n\u003cp\u003e사용자 analyzer를 정의하는 것은 새로운 \u003cem\u003eCharacter Filter\u003c/em\u003e를 정의하여 사용할 수 있고 마찬가지로 \u003cem\u003eToken Filter\u003c/em\u003e를 정의하여 사용할 수도 있다.\u003c/p\u003e\n\u003cp\u003e\u003cem\u003eToken Filter\u003c/em\u003e의 조합 순서에 따라 생성되는 index의 결과가 달라질 수 있는 것에 유의해야 한다.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch2 id=\"그-밖의-검색\"\u003e그 밖의 검색\u003c/h2\u003e\n\u003ch3 id=\"exact-value-query\"\u003eExact value query\u003c/h3\u003e\n\u003cp\u003e정확한 문자열 검색을 해야할 때 \u003ccode\u003e[field].keyword\u003c/code\u003e를 이용한다\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003econst response = await fetch(\u0026#39;http://localhost:9200/target_index/_search\u0026#39;, {\n  method: \u0026#39;post\u0026#39;,\n  headers: { [\u0026#39;Content-type\u0026#39;]: \u0026#39;application/json\u0026#39; },\n  body: JSON.stringify({\n    query: {\n      bool: {\n        filter: [\n          {\n            match: {\n              [\u0026#39;name.keyword\u0026#39;]: \u0026#39;Condition 1\u0026#39;,\n            },\n          },\n        ],\n      },\n    },\n  }),\n})\n\u003c/code\u003e\u003c/pre\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003ccode\u003e[field].keyword\u003c/code\u003e 형식의 검색조건을 설정할 때 \u003ccode\u003ebool query\u003c/code\u003e의 \u003ccode\u003efilter\u003c/code\u003e 속성을 이용하는 것을 권장한다.\u003c/p\u003e\n\u003cp\u003eExact value query는 정확도와 관계가 없기 때문에 정확도 점수를 계산할 필요가 없으며 그 결과 \u003ccode\u003efilter\u003c/code\u003e를 통해 검색하는 것이 캐싱이 가능하고 검색 성능이 더 우수하기 때문이다.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch3 id=\"range-query\"\u003eRange query\u003c/h3\u003e\n\u003cp\u003e숫자와 날짜 형식을 포함하고 있는 도큐먼트를 대상으로 검색을 수행할 때 범위를 통한 조건 설정이 가능하다. \u003ccode\u003erange query\u003c/code\u003e는 다음 네가지의 속성을 통해 범위 설정이 가능하다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003egte (Greater Than or Equal to)\u003cul\u003e\n\u003cli\u003e이상\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003egt (Grater Than)\u003cul\u003e\n\u003cli\u003e초과\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003elte (Less Than or Equal to)\u003cul\u003e\n\u003cli\u003e이하\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003elt (Less Than)\u003cul\u003e\n\u003cli\u003e미만\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003econst response = await fetch(\u0026#39;http://localhost:9200/target_index/_search\u0026#39;, {\n  method: \u0026#39;post\u0026#39;,\n  headers: { [\u0026#39;Content-Type\u0026#39;]: \u0026#39;application/json\u0026#39; },\n  body: JSON.stringify({\n    query: {\n      range: {\n        price: {\n          gte: 3000,\n          lte: 4000,\n        },\n      },\n    },\n  }),\n})\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e날짜 데이터의 범위 검색도 숫자 데이터의 범위 검색과 동일하지만 몇가지 옵션이 있다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003econst response = await fetch(\u0026#39;http://localhost:9200/target_index/_search\u0026#39;, {\n  method: \u0026#39;post\u0026#39;,\n  headers: { [\u0026#39;Content-Type\u0026#39;]: \u0026#39;application/json\u0026#39; },\n  body: JSON.stringify({\n    query: {\n      range: {\n        manufacture_date: {\n          gte: \u0026#39;2021/11/01\u0026#39;,\n          lt: \u0026#39;2021/12/01\u0026#39;,\n          format: \u0026#39;yyyy/mm/dd\u0026#39;, // 날짜 형식을 결정하는 속성\n        },\n      },\n    },\n  }),\n})\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003eformat\u003c/code\u003e 속성을 통해 날짜의 형식을 결정 할 수 있다.\u003c/p\u003e\n\u003cp\u003e예약어를 통해 범위를 결정하는 방법도 있다. 예약어는 아래의 8가지가 존재한다\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003enow: 현재시간\u003c/li\u003e\n\u003cli\u003ey: 년\u003c/li\u003e\n\u003cli\u003eM: 월\u003c/li\u003e\n\u003cli\u003ed: 일\u003c/li\u003e\n\u003cli\u003eh: 시\u003c/li\u003e\n\u003cli\u003em: 분\u003c/li\u003e\n\u003cli\u003es: 초\u003c/li\u003e\n\u003cli\u003ew: 주\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003econst response = await fetch(\u0026#39;http://localhost:9200/target_index/_search\u0026#39;, {\n  method: \u0026#39;post\u0026#39;,\n  headers: { [\u0026#39;Content-Type\u0026#39;]: \u0026#39;application/json\u0026#39; },\n  body: JSON.stringify({\n    query: {\n      range: {\n        manufacture_date: {\n          lte: \u0026#39;now-1w\u0026#39;, // 지금으로 부터 일주일 전까지의 날짜에 속하는 도큐먼트를 검색함\n        },\n      },\n    },\n  }),\n})\n\u003c/code\u003e\u003c/pre\u003e\n\u003cblockquote\u003e\n\u003cp\u003e범위검색은 기본적으로 정확도 점수를 계산하지 않는다.\u003c/p\u003e\n\u003cp\u003e경우에 따라 어던 기준으로 부터 더 가까운 값이 중요한 결과로 취급 될 수 있는데 이런 경우에는 \u003ca href=\"https://www.elastic.co/guide/en/elasticsearch/reference/7.3/query-dsl-function-score-query.html\"\u003eFunction score query\u003c/a\u003e를 이용해야한다.\u003c/p\u003e\n\u003c/blockquote\u003e\n"},"__N_SSG":true},"page":"/[title]","query":{"title":"elasticsearch:-full-text-search-(전문검색)"},"buildId":"-A21tKZSsSleB7NlYjKPX","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>