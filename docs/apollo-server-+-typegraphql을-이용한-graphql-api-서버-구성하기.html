<!DOCTYPE html><html lang="ko"><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><link rel="canonical" href="https://code-logs.github.io/apollo-server-+-typegraphql을-이용한-graphql-api-서버-구성하기"/><link rel="apple-touch-icon" href="/icons/icon-192x-192.png"/><link rel="manifest" href="/manifest.json"/><meta name="theme-color" content="#fff"/><meta property="og:type" content="website"/><meta property="og:site_name" content="Code Logs"/><meta name="author" content="Jay Lee"/><meta name="keyword" content="graphql, apollo, apollo-server, node.js, typescript, typegraphql, api, api server, Apollo Server + TypeGraphQL을 이용한 GraphQL API 서버 구성하기, Apollo Server와 TypeGraphQL을 사용한 Node.JS GraphQL API 서버 구성하기, nodejs"/><meta name="description" content="Apollo Server와 TypeGraphQL을 사용한 Node.JS GraphQL API 서버 구성하기"/><meta property="og:description" content="Apollo Server와 TypeGraphQL을 사용한 Node.JS GraphQL API 서버 구성하기"/><meta property="og:title" content="Apollo Server + TypeGraphQL을 이용한 GraphQL API 서버 구성하기 | Code Logs"/><meta property="og:url" content="https://code-logs.github.io/apollo-server-+-typegraphql을-이용한-graphql-api-서버-구성하기"/><meta property="og:image" content="/assets/images/grapqhl-apollo-typegrapql.png"/><title>Apollo Server + TypeGraphQL을 이용한 GraphQL API 서버 구성하기 | Code Logs</title><meta name="next-head-count" content="16"/><link rel="preload" href="/_next/static/css/e67f92fc328a3d57.css" as="style"/><link rel="stylesheet" href="/_next/static/css/e67f92fc328a3d57.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b5e8827db00c1c2b.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b5e8827db00c1c2b.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script src="/_next/static/chunks/webpack-2e51481b1d484a05.js" defer=""></script><script src="/_next/static/chunks/framework-5f4595e5518b5600.js" defer=""></script><script src="/_next/static/chunks/main-a4d9e436b9a532ca.js" defer=""></script><script src="/_next/static/chunks/pages/_app-302687a3b3726e89.js" defer=""></script><script src="/_next/static/chunks/294-6603e2d70ff7953e.js" defer=""></script><script src="/_next/static/chunks/992-5c20c13ff5f0f7b2.js" defer=""></script><script src="/_next/static/chunks/pages/%5Btitle%5D-80168ae5693cc526.js" defer=""></script><script src="/_next/static/tW1VJICNjS_tjNJW4WsNt/_buildManifest.js" defer=""></script><script src="/_next/static/tW1VJICNjS_tjNJW4WsNt/_ssgManifest.js" defer=""></script><script src="/_next/static/tW1VJICNjS_tjNJW4WsNt/_middlewareManifest.js" defer=""></script></head><body><div id="__next" data-reactroot=""><header class="Header_header__RW35m"><p class="Header_title__GPS8b">Code Logs</p><ul class="Header_socialIcons__CBf_s"><li><a href="https://github.com/possible819" target="_blank" rel="noreferrer" aria-label="My Github"><style data-emotion="css vubbuv">.css-vubbuv{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;width:1em;height:1em;display:inline-block;fill:currentColor;-webkit-flex-shrink:0;-ms-flex-negative:0;flex-shrink:0;-webkit-transition:fill 200ms cubic-bezier(0.4, 0, 0.2, 1) 0ms;transition:fill 200ms cubic-bezier(0.4, 0, 0.2, 1) 0ms;font-size:1.5rem;}</style><svg class="MuiSvgIcon-root MuiSvgIcon-fontSizeMedium css-vubbuv" focusable="false" aria-hidden="true" viewBox="0 0 24 24" data-testid="GitHubIcon"><path d="M12 1.27a11 11 0 00-3.48 21.46c.55.09.73-.28.73-.55v-1.84c-3.03.64-3.67-1.46-3.67-1.46-.55-1.29-1.28-1.65-1.28-1.65-.92-.65.1-.65.1-.65 1.1 0 1.73 1.1 1.73 1.1.92 1.65 2.57 1.2 3.21.92a2 2 0 01.64-1.47c-2.47-.27-5.04-1.19-5.04-5.5 0-1.1.46-2.1 1.2-2.84a3.76 3.76 0 010-2.93s.91-.28 3.11 1.1c1.8-.49 3.7-.49 5.5 0 2.1-1.38 3.02-1.1 3.02-1.1a3.76 3.76 0 010 2.93c.83.74 1.2 1.74 1.2 2.94 0 4.21-2.57 5.13-5.04 5.4.45.37.82.92.82 2.02v3.03c0 .27.1.64.73.55A11 11 0 0012 1.27"></path></svg></a></li></ul><nav class="NavBar_navBar__akqA3"><ul><li><a class="MarkedAnchor_anchor__QCmkL" href="https://code-logs.github.io/">Home</a></li><li><a class="MarkedAnchor_anchor__QCmkL" href="https://code-logs.github.io/posts/1">Posts</a></li><li><a class="MarkedAnchor_anchor__QCmkL" href="https://code-logs.github.io/about">About</a></li></ul></nav></header><main><article class="PostDetail_container__Ma_26"><p class="PostDetail_publishedAt__7GOQm"><span></span></p><section class="PostDetail_thumbnailWrapper__oALCg"><img src="/assets/images/grapqhl-apollo-typegrapql.png" alt="Apollo Server와 TypeGraphQL을 사용한 Node.JS GraphQL API 서버 구성하기"/></section><section><h1>Apollo Server + TypeGraphQL을 이용한 GraphQL API 서버 구성하기</h1><p class="PostDetail_description__l6wHC">Apollo Server와 TypeGraphQL을 사용한 Node.JS GraphQL API 서버 구성하기</p></section><section><h2 id="table-of-contents">Table of contents</h2>
<ol>
<li><a href="#graphql">GraphQL</a></li>
<li><a href="#typescript%EC%99%80-%EC%B0%B0%EB%96%A1-%EA%B6%81%ED%95%A9">Typescript와 찰떡 궁합</a></li>
<li><a href="#apollo-server">Apollo Server</a></li>
<li><a href="#apollo-server-%EA%B5%AC%EC%84%B1%ED%95%98%EA%B8%B0">Apollo Server 구성하기</a><ol>
<li><a href="#schema---%EA%B0%9D%EC%B2%B4-%ED%98%95%ED%83%9C-%EC%A0%95%EC%9D%98%ED%95%98%EA%B8%B0">Schema - 객체 형태 정의하기</a></li>
<li><a href="#schema---query-%EC%A0%95%EC%9D%98%ED%95%98%EA%B8%B0">Schema - Query 정의하기</a></li>
<li><a href="#schema---mutation-%EC%A0%95%EC%9D%98%ED%95%98%EA%B8%B0">Schema - Mutation 정의하기</a></li>
<li><a href="#resolver---%EC%8B%A4%EC%A0%9C-%EC%9E%91%EC%97%85%EC%9D%B4-%EC%9D%BC%EC%96%B4%EB%82%98%EB%8A%94-%EA%B3%B3">Resolver - 실제 작업이 일어나는 곳</a></li>
<li><a href="#%EC%82%AC%EC%A0%84-%EC%9E%91%EC%97%85---dummy-data">사전 작업 - Dummy data</a></li>
<li><a href="#query-%EC%9E%91%EC%84%B1%ED%95%98%EA%B8%B0">Query 작성하기</a></li>
<li><a href="#mutation-%EC%9E%91%EC%84%B1%ED%95%98%EA%B8%B0">Mutation 작성하기</a></li>
<li><a href="#apollo-server-%EC%8B%A4%ED%96%89%ED%95%98%EA%B8%B0">Apollo Server 실행하기</a></li>
<li><a href="#graphql-query--mutation">GraphQL Query &amp; Mutation</a></li>
</ol>
</li>
<li><a href="#field-resolver%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-%ED%85%8C%EC%9D%B4%EB%B8%94-join">Field resolver를 이용한 테이블 Join</a></li>
<li><a href="#typegraphql">TypeGraphQL</a><ol>
<li><a href="#%EB%94%94%ED%8E%9C%EB%8D%98%EC%8B%9C-%EC%84%A4%EC%B9%98">디펜던시 설치</a></li>
<li><a href="#tsconfig-configuration">tsconfig configuration</a></li>
<li><a href="#class-%EC%A0%95%EC%9D%98">Class 정의</a></li>
<li><a href="#resolver-%EC%A0%95%EC%9D%98">Resolver 정의</a></li>
<li><a href="#schema-%EC%83%9D%EC%84%B1%ED%95%98%EA%B8%B0">Schema 생성하기</a></li>
<li><a href="#%EA%B7%B8-%EB%B0%96%EC%9D%98-%EC%84%A4%EC%A0%95%EB%93%A4">그 밖의 설정들</a></li>
</ol>
</li>
</ol>
<h2 id="graphql">GraphQL</h2>
<blockquote>
<p>GraphQL은 2012년 부터 페이스북에 의해 개발되었으며 2015년에 공식적으로 발표되었다.
RESTful API로 대표되는 클라이언트와 서버의 통신 아키텍쳐중 하나이다. 단일 Resource를 대상으로하는 RESTful API와 다르게 Graph 구조, 즉 노드간의 상관관계를 통해 클라이언트에서 반환 받고자 하는 데이터의 형식을 결정 할 수 있는 것이 특징이다.
이를 통해 불필요한 데이터의 fetching을 방지 할 수 있다는 것과 클라이언트 소스의 수정만으로 기대되는 API의 Return type을 조정 할 수 있다는 장점을 가지고 있다.</p>
</blockquote>
<h2 id="typescript와-찰떡-궁합">Typescript와 찰떡 궁합</h2>
<p>GraphQL은 ‘강한 타입’ 제약을 가지는 것이 특징이다. GraphQL 아키텍쳐로 구성된 서버는 클라이언트에서 요구하는 데이터 유형과 정확히 일치하는 데이터 유형을 반환해야 하기 때문이다.</p>
<h2 id="apollo-server">Apollo Server</h2>
<p>GraphQL 환경의 클라이언트와 통신하기 위한 Node.js 서버를 구성할 수 있는 패키지다. Apollo Server는 GrpahQL 아키텍쳐의 간단한 서버를 구성하는 것을 목적으로 하기 때문에 조금더 복잡한 구조의 Node.js 서버 구성을 위해서는 <code>apollo-server-express</code> 또는 <code>apollo-server-koa</code> 와 같은 디펜던시를 <code>Express</code> , <code>Koa</code> 와 같은 프레임워크에 엮어서 사용해아 한다.</p>
<h2 id="apollo-server-구성하기">Apollo Server 구성하기</h2>
<p>node 프로젝트를 초기화하고 필요한 디펜던시를 설치한다.</p>
<pre><code class="language-bash">$ npm init -y
$ npm i graphql apollo-server
</code></pre>
<h3 id="schema---객체-형태-정의하기">Schema - 객체 형태 정의하기</h3>
<p>GraphQL은 <code>강한 타입 제약</code> 을 가지고 있고 이것을 정의하는 역할을 하게 되는 것이 바로 <code>Schema</code>이다. 스키마의 아래 예제를 통해 <code>User</code> schema를 정의한다.</p>
<pre><code class="language-typescript">// typeDefs.ts

import { gql } from &#39;apollo-server&#39;

const typeDefs = gql`
  type User {
    id: Int
    name: String
    age: Int
  }

  input NewUser {
    name: String!
    age: Int!
  }
`
</code></pre>
<p>User라는 명칭의 schema는 String 타입의 <code>name</code> 필드와 Int 타입의 <code>age</code> 필드를 가지고 있다.</p>
<blockquote>
<p><code>User</code> 유형의 schema는 데이터를 반환할 때 사용하는 형태다 (객체 타입)
<code>input</code> 유형의 schema는 클라이언트에서 서버로 데이터를 전달 할 때 사용하는 형태다</p>
</blockquote>
<blockquote>
<p><code>GraphQL</code>의 schema 타입을 정의할 때 <code>javascript</code>의 원시 타입 (number, string, boolean 등)을 사용하는 것이 아닌 <code>GraphQL</code>의 자체 타입을 사용한다. - <a href="https://graphql.org/learn/schema/">참조</a></p>
</blockquote>
<h3 id="schema---query-정의하기">Schema - Query 정의하기</h3>
<p>클라이언트와 서버가 통신하기 위한 입/출력(<code>type/input</code>) schema를 정의 했으니 이제 RESTful API의 endpoint와 유사한 <code>Query</code> schema를 정의한다.</p>
<pre><code class="language-typescript">// typeDefs.ts

import { gql } from &#39;apollo-server&#39;

const typeDefs = gql`
    ...

    type Query {
        user(name: String!): User
        users: [User]
    }
`
</code></pre>
<p><code>Query</code> 타입의 schema는 말 그대로 데이터를 조회하기 위해 사용되는 schema에 대한 정보다.</p>
<p>두가지 Query 유형의 schema가 정의되었고 <code>User</code> 를 리턴하는 <code>user</code> query와 <code>[User]</code> 를 리턴하는 <code>users</code> query다.</p>
<h3 id="schema---mutation-정의하기">Schema - Mutation 정의하기</h3>
<p>Query를 정의 했으니 이제 <code>Mutation</code>을 정의한다. <code>Mutation</code>은 말그대로 데이터의 변이를 발생시키는 스키마를 의미한다.</p>
<pre><code class="language-typescript">// typeDefs.ts

import { gql } from &#39;apollo-server&#39;

const typeDefs = gql`
    ...

    type Mutation {
        addUser(user: NewUser!): User
        deleteUser(id: String!): Boolean
    }
`
</code></pre>
<p>새로운 사용자를 추가할 때 사용할 <code>addUser</code> schema와 <code>ID</code> 를 통해 사용자를 삭제할 때 사용할 <code>deleteUser</code> 스키마를 정의 했다.</p>
<blockquote>
<p>Mutation 스키마의 파라미터로 사용되는 스키마는 반드시 <code>input</code> 타입 스키마를 사용하며
Query의 반환결과로 사용되는 스키마는 반드시 객체 타입의 스키마를 사용한다.</p>
</blockquote>
<blockquote>
<p>두 스키마는 각각 <code>User</code>와 <code>Boolean</code> 을 리턴 타입으로 갖고 있는데 GraphQL에서는 <code>void</code> 유형이 없는 것 또한 특징이다. <code>void</code> 를 사용해야 할 때 리턴 타입을 Boolean으로 선언한다.</p>
</blockquote>
<h3 id="resolver---실제-작업이-일어나는-곳">Resolver - 실제 작업이 일어나는 곳</h3>
<p>지금까지 작성한 Schema는</p>
<p><code>User</code>, <code>New User</code>, <code>Query - user</code>, <code>Query - users</code>, <code>Mutation - addUser</code>, <code>Mutation - deleteUser</code> 로 사용자를 조회하고 생성하고 삭제하기 위한 필요한 타입 정의는 끝났으니 이제 실제 데이터를 가공하는 로직을 작성해야 한다.</p>
<p>이렇게 정의된 schema를 통해 클라이언트로 부터 데이터를 전달 받고 처리하는 것을 <code>resolver</code>라 한다.</p>
<h3 id="사전-작업---dummy-data">사전 작업 - Dummy Data</h3>
<p>우선 본격적으로 resolver를 정의하기 전에 테스트로 사용할 더미 데이터와 인터페이스를 만든다.</p>
<pre><code class="language-typescript">// dummy-data.ts

export interface User {
  id: number
  name: string
  age: number
}

export const dummyUsers = Array.from({ length: 20 }, (_, idx) =&gt; {
  return {
    id: idx + 1,
    name: `Sample User ${idx + 1}`,
    age: Math.floor(Math.random() * 20),
  }
})
</code></pre>
<p>이제 조회 <code>user</code>, <code>users</code> 처리를 위한 <code>resolver</code>를 정의한다.</p>
<h3 id="query-작성하기">Query 작성하기</h3>
<p><code>Query</code>는 데이터 조회를 위한 <code>resolver</code>에 해당한다. <code>name</code>을 parameter로 전달 받아 동일한 <code>name</code>을 가진 사용자를 반환하는 <code>user</code> resolver와 <code>user</code> 전체 리스트를 반환하는 <code>users</code> resolver를 작성한다.</p>
<pre><code class="language-typescript">// resolvers.ts
import { dummyUsers, User } from &#39;./dummy-data&#39;

let users = [...dummyUsers]

const resolvers = {
  Query: {
    user: (_: unknown, { name }: { name: string }) =&gt; {
      return users.find((user) =&gt; user.name === name)
    },

    users: () =&gt; {
      return users
    },
  },
}
</code></pre>
<h3 id="mutation-작성하기">Mutation 작성하기</h3>
<p><code>Mutation</code>은 데이터의 변이가 일어나는 <code>resolver</code>에 해당한다. <code>user</code> 객체를 parameter로 전달 받아 새로운 <code>user</code> 데이터를 생성하는 <code>addUser</code> resolver와 사용자의 <code>id</code> 를 전달받아 일치하는 사용자 데이터를 삭제하는 <code>deleteUser</code> resolver를 작성한다.</p>
<pre><code class="language-typescript">// resolvers.ts

...

const resolvers = {

  ...

  Mutation: {
    addUser: (_: unknown, { user }: { user: User }) =&gt; {
      const newUser = {
        ...user,
        id: users[users.length - 1].id + 1,
      }
      users.push(newUser)
      return newUser
    },
    deleteUser: (_: unknown, { id }: { id: number }) =&gt; {
      users = users.filter((user) =&gt; user.id !== id)
    },
  },
}
</code></pre>
<blockquote>
<p>Resolver의 parameter들</p>
<p>resolver는 <code>parent</code>, <code>args</code>, <code>context</code>, <code>info</code> 네개의 parameter를 전달 받는다
각 parameter의 역할은 아래와 같다.</p>
<p><code>parent</code> - <code>field resolver</code>를 통해 현재 resolver가 호출 될 경우 부모 resolver에 의해 반환된 객체 (Resolver chaining)</p>
<p><code>args</code> - resolver를 호출할 때 전달한 인자</p>
<p><code>context</code> - 모든 resolver에 공통적으로 전달되는 <code>context</code> 객체로 일반적으로 미들웨어를 통해 기록된 값이 담겨있다.</p>
<p><code>info</code> - schema 정보와 field 정보 등을 담은 객체</p>
</blockquote>
<h3 id="apollo-server-실행하기">Apollo Server 실행하기</h3>
<p>Apollo Server를 실행하기 위한 type과 resolver가 모두 정의 되었으니 <code>apollo server</code> 를 실행하고 테스트 해본다.</p>
<pre><code class="language-typescript">import { ApolloServer } from &#39;apollo-server&#39;
import typeDefs from &#39;./typeDefs&#39;
import resolvers from &#39;./resolvers&#39;

const server = new ApolloServer({ typeDefs, resolvers })

server.listen(8080).then(() =&gt; {
  console.log(&#39;Apollo Server is running on 8080&#39;)
})
</code></pre>
<p>Apollo Server를 실행하면 <code>Apollo Studio</code> 를 통해 작성한 GraphQL 서버로 요청을 보낼 수 있다.</p>
<blockquote>
<p><strong>GraphQL Queries And Mutations</strong></p>
<p>GraphQL에 요청을 보내기 위해 사용하게 되는 Syntax는 <em>query</em> 또는 <em>mutation</em>에 관심 있는 필드를 정의하는 것을 기본으로 한다.</p>
<p><a href="https://graphql.org/learn/queries/">이곳</a> 에서 보다 자세한 내용을 확인 할 수 있다.</p>
</blockquote>
<h2 id="field-resolver를-이용한-테이블-join">Field resolver를 이용한 테이블 Join</h2>
<p>GraphQL은 반환하는 <code>Object type</code>의 모든 필드의 값이 <code>resolver</code> 에 의해 채워진다. 어떤 필드에 특정한 resolver가 정의되어 있지 않다면 일반적으로 <code>object.field</code> 와 같은 형태로 값을 채우게 된다. (default resolver)</p>
<p>만약 특정 필드가 또 다른 테이블 (객체)을 통해 값이 결정 된다면 <code>field resolver</code> 를 정의하여 쉽게 값을 채울 수 있다.</p>
<p>사용자가 <code>Company</code>라는 테이블과 relation을 가지고 있다면 아래와 같이 field resolver를 정의 할 수 있다.</p>
<pre><code class="language-typescript">// dummy-data.ts
...

export const dummyUsers = Array.from({ length: 20 }, (_, idx) =&gt; {
  return {
    id: idx + 1,
    name: `Sample User ${idx + 1}`,
    age: Math.floor(Math.random() * 20),
    companyId: (idx % 3) + 1, // company id를 통해 company 객체를 참조한다.
  }
}) as User[]

export interface Company {
  id: number
  name: string
}

export const dummyCompanies = Array.from({ length: 3 }, (_, idx) =&gt; {
  return {
    id: idx + 1,
    name: `Sample Company ${idx + 1}`,
  }
}) as Company[]
</code></pre>
<pre><code class="language-typescript">// resolvers.ts
import { dummyUsers, User, dummyCompanies } from &#39;./dummy-data&#39;

...

let companies = [...dummyCompanies]


const resolvers = {
    ...

    User: {
        company: (parent: User) =&gt; {
            return companies.find((company) =&gt; company.id === parent.companyId)
        }
    }
}
</code></pre>
<p>field resolver를 이용할 경우 resolver chain을 통해 해당 필드에 대한 접근을 시도할 때에만 대상 객체에 접근하도록 구성 할 수 있고 가상 필드와 같은 효과를 손쉽게 구현 할 수 있다는 장점이 있다. 반면에 리스트 데이터를 조회할 때 유사한 결과를 리턴하는 레코드가 많이 포함되어 있다면 같은 로직을 여러차례 반복하게 되는 단점도 있다. (N + 1 problem)</p>
<blockquote>
<p><strong>N + 1 problem</strong></p>
<p>사용자 레코드를 조회 할 때 사용자를 조회하기 위한 쿼리 1회 + 사용자와 관계를 맺고 있는 회사 레코드를 조회하는 쿼리 N 회가 발생하는 문제로 동일한 쿼리일 가능성이 높은 N회의 쿼리가 반복적으로 발생하는 문제</p>
<p><a href="https://github.com/graphql/dataloader">DataLoader</a>와 같은 라이브러리를 이용해 caching, 또는 batch 처리 등의 방법으로 N + 1 problem으로 인해 발생하는 비효율성을 개선하기도 한다.</p>
</blockquote>
<h2 id="typegraphql">TypeGraphQL</h2>
<p>GraphQL을 이용한 프로젝트를 구성하다 보면 type 정의, resolver 정의 그리고 entity, interface 등 상당히 많은 파일들을 생성해내야 한다.</p>
<p>프로젝트 구조가 복잡해지거니와 유사한 형태의 파일들을 반복적으로 작성해야하는 것은 번거로운 일이다.</p>
<p>TypeGraphQL은 이런 번거로움을 해결하기 위한 라이브러리로 class를 정의하는 것을 통해 entity와 GraphQL type의 정의를 동시에 처리 할 수 있도록 돕는다.</p>
<h3 id="디펜던시-설치">디펜던시 설치</h3>
<p>TypeGraphQL을 사용하기 위해 필요한 디펜던시를 설치한다.</p>
<pre><code class="language-bash">$ npm i graphql class-validator type-graphql reflect-metadata
</code></pre>
<blockquote>
<p>만약 디펜던시 설치중 에러가 발생한다면 type-graphql의 peer dependency인 graphql의 버전을 확인하고</p>
<p>필요한 경우 graphql을 삭제한 뒤 다시 설치한다</p>
</blockquote>
<h3 id="tsconfig-configuration">tsconfig configuration</h3>
<pre><code class="language-json">// tsconfig.json
{
  &quot;target&quot;: &quot;es2018&quot;, // type-graphql이 es2018 spec에 의존하고 있다
  &quot;emitDecoratorMetadata&quot;: true, // decorator를 사용하기 위해 true로 설정
  &quot;experimentalDecorators&quot;: true // decorator를 사용하기 위해 true로 설정
}
</code></pre>
<h3 id="class-정의">Class 정의</h3>
<p>class 정의를 통해 GraphQL의 type과 typescript의 interface 역할을 수행할 객체를 정의 할 수 있다.</p>
<pre><code class="language-typescript">// entities/User.ts

import { Field, ID, ObjectType } from &#39;type-graphql&#39;

@ObjectType()
export class User {
  @Field((type) =&gt; ID)
  id!: number

  @Field()
  name!: string

  @Field()
  age!: number
}
</code></pre>
<h3 id="resolver-정의">Resolver 정의</h3>
<p>resolver 또한 class 형식으로 정의 할 수 있다.</p>
<pre><code class="language-typescript">// resolvers/User.ts

import { Arg, Query, Resolver } from &#39;type-graphql&#39;
import { dummyUsers } from &#39;../dummy-data&#39;
import { User } from &#39;../entities/User&#39;

let users = [...dummyUsers]

@Resolver()
export class UserResolver {
  @Query((returns) =&gt; User)
  user(@Arg(&#39;name&#39;) name: string) {
    const foundUser = users.find((user) =&gt; user.name === name) || null
    if (!foundUser) throw new Error(&#39;No user found&#39;)

    return foundUser
  }

  @Query((returns) =&gt; [User])
  users() {
    return users
  }
}
</code></pre>
<blockquote>
<p>TypeGraphQL을 통해 resolver를 정의할 경우 반환 타입에 대한 validation이 더 엄격해진다. <code>null</code> 을 반환 할 수 없는 <code>Query</code> 의 경우 반환할 결과물이 없을 경우 <code>null</code> 또는 <code>undefined</code> 를 리턴하지 않도록 에러 처리를 해줘야한다.</p>
</blockquote>
<h3 id="schema-생성하기">Schema 생성하기</h3>
<p>이렇게 정의한 <code>resolver</code>를 통해 schema를 생성해야 한다. 생성된 schema는 Apollo Server를 실행할 때 전달되는 <code>config</code> 로 사용된다.</p>
<pre><code class="language-typescript">// app.ts

import { ApolloServer } from &#39;apollo-server&#39;
import &#39;reflect-metadata&#39;
import { buildSchema } from &#39;type-graphql&#39;
import { UserResolver } from &#39;./resolvers/User&#39;

buildSchema({
  resolvers: [UserResolver],
}).then((schema) =&gt; {
  const server = new ApolloServer({ schema })

  server.listen(8080).then(() =&gt; {
    console.log(&#39;Apollo Server is running on 8080&#39;)
  })
})
</code></pre>
<blockquote>
<p><code>&#39;reflect-metadata&#39;</code> 를 import 해야한다. schema 생성시 해당 모듈에 의존하기 때문이다.</p>
</blockquote>
<h3 id="그-밖의-설정들">그 밖의 설정들</h3>
<p>그 밖의 설정들은 <a href="https://typegraphql.com/docs/introduction.html">공식 문서를</a> 참조한다.</p>
</section></article><section class="PostDetail_references__EU_hH"><h2>참고</h2><ul class="PostDetail_references__EU_hH"><li><a href="https://www.apollographql.com" target="_blank" rel="noreferrer">Apollo Server</a></li><li><a href="https://typegraphql.com" target="_blank" rel="noreferrer">TypeGraphQL</a></li><li><a href="https://graphql.org" target="_blank" rel="noreferrer">GraphQL</a></li><li><a href="https://github.com/graphql/dataloader" target="_blank" rel="noreferrer">DataLoader - GitHub Repository</a></li><li><a href="https://github.com/possible819/graphql-sample" target="_blank" rel="noreferrer">Sample Repository</a></li></ul></section><section class="PostDetail_utterances__jZeOm"><h2>댓글</h2><div></div></section><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-7134579063537339" data-ad-slot="5391522351" data-ad-format="auto" data-full-width-responsive="true"></ins></main><aside></aside><footer class="Footer_footer__GLL0J"><p>ⓒ 2021. Jay Lee  all rights reserved.</p></footer></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"Apollo Server + TypeGraphQL을 이용한 GraphQL API 서버 구성하기","fileName":"grapql-with-apollo-server-typegraphql.md","description":"Apollo Server와 TypeGraphQL을 사용한 Node.JS GraphQL API 서버 구성하기","category":"nodejs","published":true,"publishedAt":"2022-03-10","tags":["graphql","apollo","apollo-server","node.js","typescript","typegraphql","api","api server"],"thumbnailName":"grapqhl-apollo-typegrapql.png","references":[{"title":"Apollo Server","url":"https://www.apollographql.com"},{"title":"TypeGraphQL","url":"https://typegraphql.com"},{"title":"GraphQL","url":"https://graphql.org"},{"title":"DataLoader - GitHub Repository","url":"https://github.com/graphql/dataloader"},{"title":"Sample Repository","url":"https://github.com/possible819/graphql-sample"}]},"content":"\u003ch2 id=\"table-of-contents\"\u003eTable of contents\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003e\u003ca href=\"#graphql\"\u003eGraphQL\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#typescript%EC%99%80-%EC%B0%B0%EB%96%A1-%EA%B6%81%ED%95%A9\"\u003eTypescript와 찰떡 궁합\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#apollo-server\"\u003eApollo Server\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#apollo-server-%EA%B5%AC%EC%84%B1%ED%95%98%EA%B8%B0\"\u003eApollo Server 구성하기\u003c/a\u003e\u003col\u003e\n\u003cli\u003e\u003ca href=\"#schema---%EA%B0%9D%EC%B2%B4-%ED%98%95%ED%83%9C-%EC%A0%95%EC%9D%98%ED%95%98%EA%B8%B0\"\u003eSchema - 객체 형태 정의하기\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#schema---query-%EC%A0%95%EC%9D%98%ED%95%98%EA%B8%B0\"\u003eSchema - Query 정의하기\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#schema---mutation-%EC%A0%95%EC%9D%98%ED%95%98%EA%B8%B0\"\u003eSchema - Mutation 정의하기\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#resolver---%EC%8B%A4%EC%A0%9C-%EC%9E%91%EC%97%85%EC%9D%B4-%EC%9D%BC%EC%96%B4%EB%82%98%EB%8A%94-%EA%B3%B3\"\u003eResolver - 실제 작업이 일어나는 곳\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#%EC%82%AC%EC%A0%84-%EC%9E%91%EC%97%85---dummy-data\"\u003e사전 작업 - Dummy data\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#query-%EC%9E%91%EC%84%B1%ED%95%98%EA%B8%B0\"\u003eQuery 작성하기\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#mutation-%EC%9E%91%EC%84%B1%ED%95%98%EA%B8%B0\"\u003eMutation 작성하기\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#apollo-server-%EC%8B%A4%ED%96%89%ED%95%98%EA%B8%B0\"\u003eApollo Server 실행하기\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#graphql-query--mutation\"\u003eGraphQL Query \u0026amp; Mutation\u003c/a\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#field-resolver%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-%ED%85%8C%EC%9D%B4%EB%B8%94-join\"\u003eField resolver를 이용한 테이블 Join\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#typegraphql\"\u003eTypeGraphQL\u003c/a\u003e\u003col\u003e\n\u003cli\u003e\u003ca href=\"#%EB%94%94%ED%8E%9C%EB%8D%98%EC%8B%9C-%EC%84%A4%EC%B9%98\"\u003e디펜던시 설치\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#tsconfig-configuration\"\u003etsconfig configuration\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#class-%EC%A0%95%EC%9D%98\"\u003eClass 정의\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#resolver-%EC%A0%95%EC%9D%98\"\u003eResolver 정의\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#schema-%EC%83%9D%EC%84%B1%ED%95%98%EA%B8%B0\"\u003eSchema 생성하기\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#%EA%B7%B8-%EB%B0%96%EC%9D%98-%EC%84%A4%EC%A0%95%EB%93%A4\"\u003e그 밖의 설정들\u003c/a\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2 id=\"graphql\"\u003eGraphQL\u003c/h2\u003e\n\u003cblockquote\u003e\n\u003cp\u003eGraphQL은 2012년 부터 페이스북에 의해 개발되었으며 2015년에 공식적으로 발표되었다.\nRESTful API로 대표되는 클라이언트와 서버의 통신 아키텍쳐중 하나이다. 단일 Resource를 대상으로하는 RESTful API와 다르게 Graph 구조, 즉 노드간의 상관관계를 통해 클라이언트에서 반환 받고자 하는 데이터의 형식을 결정 할 수 있는 것이 특징이다.\n이를 통해 불필요한 데이터의 fetching을 방지 할 수 있다는 것과 클라이언트 소스의 수정만으로 기대되는 API의 Return type을 조정 할 수 있다는 장점을 가지고 있다.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch2 id=\"typescript와-찰떡-궁합\"\u003eTypescript와 찰떡 궁합\u003c/h2\u003e\n\u003cp\u003eGraphQL은 ‘강한 타입’ 제약을 가지는 것이 특징이다. GraphQL 아키텍쳐로 구성된 서버는 클라이언트에서 요구하는 데이터 유형과 정확히 일치하는 데이터 유형을 반환해야 하기 때문이다.\u003c/p\u003e\n\u003ch2 id=\"apollo-server\"\u003eApollo Server\u003c/h2\u003e\n\u003cp\u003eGraphQL 환경의 클라이언트와 통신하기 위한 Node.js 서버를 구성할 수 있는 패키지다. Apollo Server는 GrpahQL 아키텍쳐의 간단한 서버를 구성하는 것을 목적으로 하기 때문에 조금더 복잡한 구조의 Node.js 서버 구성을 위해서는 \u003ccode\u003eapollo-server-express\u003c/code\u003e 또는 \u003ccode\u003eapollo-server-koa\u003c/code\u003e 와 같은 디펜던시를 \u003ccode\u003eExpress\u003c/code\u003e , \u003ccode\u003eKoa\u003c/code\u003e 와 같은 프레임워크에 엮어서 사용해아 한다.\u003c/p\u003e\n\u003ch2 id=\"apollo-server-구성하기\"\u003eApollo Server 구성하기\u003c/h2\u003e\n\u003cp\u003enode 프로젝트를 초기화하고 필요한 디펜던시를 설치한다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e$ npm init -y\n$ npm i graphql apollo-server\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"schema---객체-형태-정의하기\"\u003eSchema - 객체 형태 정의하기\u003c/h3\u003e\n\u003cp\u003eGraphQL은 \u003ccode\u003e강한 타입 제약\u003c/code\u003e 을 가지고 있고 이것을 정의하는 역할을 하게 되는 것이 바로 \u003ccode\u003eSchema\u003c/code\u003e이다. 스키마의 아래 예제를 통해 \u003ccode\u003eUser\u003c/code\u003e schema를 정의한다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-typescript\"\u003e// typeDefs.ts\n\nimport { gql } from \u0026#39;apollo-server\u0026#39;\n\nconst typeDefs = gql`\n  type User {\n    id: Int\n    name: String\n    age: Int\n  }\n\n  input NewUser {\n    name: String!\n    age: Int!\n  }\n`\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eUser라는 명칭의 schema는 String 타입의 \u003ccode\u003ename\u003c/code\u003e 필드와 Int 타입의 \u003ccode\u003eage\u003c/code\u003e 필드를 가지고 있다.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003ccode\u003eUser\u003c/code\u003e 유형의 schema는 데이터를 반환할 때 사용하는 형태다 (객체 타입)\n\u003ccode\u003einput\u003c/code\u003e 유형의 schema는 클라이언트에서 서버로 데이터를 전달 할 때 사용하는 형태다\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003ccode\u003eGraphQL\u003c/code\u003e의 schema 타입을 정의할 때 \u003ccode\u003ejavascript\u003c/code\u003e의 원시 타입 (number, string, boolean 등)을 사용하는 것이 아닌 \u003ccode\u003eGraphQL\u003c/code\u003e의 자체 타입을 사용한다. - \u003ca href=\"https://graphql.org/learn/schema/\"\u003e참조\u003c/a\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch3 id=\"schema---query-정의하기\"\u003eSchema - Query 정의하기\u003c/h3\u003e\n\u003cp\u003e클라이언트와 서버가 통신하기 위한 입/출력(\u003ccode\u003etype/input\u003c/code\u003e) schema를 정의 했으니 이제 RESTful API의 endpoint와 유사한 \u003ccode\u003eQuery\u003c/code\u003e schema를 정의한다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-typescript\"\u003e// typeDefs.ts\n\nimport { gql } from \u0026#39;apollo-server\u0026#39;\n\nconst typeDefs = gql`\n    ...\n\n    type Query {\n        user(name: String!): User\n        users: [User]\n    }\n`\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003eQuery\u003c/code\u003e 타입의 schema는 말 그대로 데이터를 조회하기 위해 사용되는 schema에 대한 정보다.\u003c/p\u003e\n\u003cp\u003e두가지 Query 유형의 schema가 정의되었고 \u003ccode\u003eUser\u003c/code\u003e 를 리턴하는 \u003ccode\u003euser\u003c/code\u003e query와 \u003ccode\u003e[User]\u003c/code\u003e 를 리턴하는 \u003ccode\u003eusers\u003c/code\u003e query다.\u003c/p\u003e\n\u003ch3 id=\"schema---mutation-정의하기\"\u003eSchema - Mutation 정의하기\u003c/h3\u003e\n\u003cp\u003eQuery를 정의 했으니 이제 \u003ccode\u003eMutation\u003c/code\u003e을 정의한다. \u003ccode\u003eMutation\u003c/code\u003e은 말그대로 데이터의 변이를 발생시키는 스키마를 의미한다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-typescript\"\u003e// typeDefs.ts\n\nimport { gql } from \u0026#39;apollo-server\u0026#39;\n\nconst typeDefs = gql`\n    ...\n\n    type Mutation {\n        addUser(user: NewUser!): User\n        deleteUser(id: String!): Boolean\n    }\n`\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e새로운 사용자를 추가할 때 사용할 \u003ccode\u003eaddUser\u003c/code\u003e schema와 \u003ccode\u003eID\u003c/code\u003e 를 통해 사용자를 삭제할 때 사용할 \u003ccode\u003edeleteUser\u003c/code\u003e 스키마를 정의 했다.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eMutation 스키마의 파라미터로 사용되는 스키마는 반드시 \u003ccode\u003einput\u003c/code\u003e 타입 스키마를 사용하며\nQuery의 반환결과로 사용되는 스키마는 반드시 객체 타입의 스키마를 사용한다.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cblockquote\u003e\n\u003cp\u003e두 스키마는 각각 \u003ccode\u003eUser\u003c/code\u003e와 \u003ccode\u003eBoolean\u003c/code\u003e 을 리턴 타입으로 갖고 있는데 GraphQL에서는 \u003ccode\u003evoid\u003c/code\u003e 유형이 없는 것 또한 특징이다. \u003ccode\u003evoid\u003c/code\u003e 를 사용해야 할 때 리턴 타입을 Boolean으로 선언한다.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch3 id=\"resolver---실제-작업이-일어나는-곳\"\u003eResolver - 실제 작업이 일어나는 곳\u003c/h3\u003e\n\u003cp\u003e지금까지 작성한 Schema는\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eUser\u003c/code\u003e, \u003ccode\u003eNew User\u003c/code\u003e, \u003ccode\u003eQuery - user\u003c/code\u003e, \u003ccode\u003eQuery - users\u003c/code\u003e, \u003ccode\u003eMutation - addUser\u003c/code\u003e, \u003ccode\u003eMutation - deleteUser\u003c/code\u003e 로 사용자를 조회하고 생성하고 삭제하기 위한 필요한 타입 정의는 끝났으니 이제 실제 데이터를 가공하는 로직을 작성해야 한다.\u003c/p\u003e\n\u003cp\u003e이렇게 정의된 schema를 통해 클라이언트로 부터 데이터를 전달 받고 처리하는 것을 \u003ccode\u003eresolver\u003c/code\u003e라 한다.\u003c/p\u003e\n\u003ch3 id=\"사전-작업---dummy-data\"\u003e사전 작업 - Dummy Data\u003c/h3\u003e\n\u003cp\u003e우선 본격적으로 resolver를 정의하기 전에 테스트로 사용할 더미 데이터와 인터페이스를 만든다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-typescript\"\u003e// dummy-data.ts\n\nexport interface User {\n  id: number\n  name: string\n  age: number\n}\n\nexport const dummyUsers = Array.from({ length: 20 }, (_, idx) =\u0026gt; {\n  return {\n    id: idx + 1,\n    name: `Sample User ${idx + 1}`,\n    age: Math.floor(Math.random() * 20),\n  }\n})\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이제 조회 \u003ccode\u003euser\u003c/code\u003e, \u003ccode\u003eusers\u003c/code\u003e 처리를 위한 \u003ccode\u003eresolver\u003c/code\u003e를 정의한다.\u003c/p\u003e\n\u003ch3 id=\"query-작성하기\"\u003eQuery 작성하기\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003eQuery\u003c/code\u003e는 데이터 조회를 위한 \u003ccode\u003eresolver\u003c/code\u003e에 해당한다. \u003ccode\u003ename\u003c/code\u003e을 parameter로 전달 받아 동일한 \u003ccode\u003ename\u003c/code\u003e을 가진 사용자를 반환하는 \u003ccode\u003euser\u003c/code\u003e resolver와 \u003ccode\u003euser\u003c/code\u003e 전체 리스트를 반환하는 \u003ccode\u003eusers\u003c/code\u003e resolver를 작성한다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-typescript\"\u003e// resolvers.ts\nimport { dummyUsers, User } from \u0026#39;./dummy-data\u0026#39;\n\nlet users = [...dummyUsers]\n\nconst resolvers = {\n  Query: {\n    user: (_: unknown, { name }: { name: string }) =\u0026gt; {\n      return users.find((user) =\u0026gt; user.name === name)\n    },\n\n    users: () =\u0026gt; {\n      return users\n    },\n  },\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"mutation-작성하기\"\u003eMutation 작성하기\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003eMutation\u003c/code\u003e은 데이터의 변이가 일어나는 \u003ccode\u003eresolver\u003c/code\u003e에 해당한다. \u003ccode\u003euser\u003c/code\u003e 객체를 parameter로 전달 받아 새로운 \u003ccode\u003euser\u003c/code\u003e 데이터를 생성하는 \u003ccode\u003eaddUser\u003c/code\u003e resolver와 사용자의 \u003ccode\u003eid\u003c/code\u003e 를 전달받아 일치하는 사용자 데이터를 삭제하는 \u003ccode\u003edeleteUser\u003c/code\u003e resolver를 작성한다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-typescript\"\u003e// resolvers.ts\n\n...\n\nconst resolvers = {\n\n  ...\n\n  Mutation: {\n    addUser: (_: unknown, { user }: { user: User }) =\u0026gt; {\n      const newUser = {\n        ...user,\n        id: users[users.length - 1].id + 1,\n      }\n      users.push(newUser)\n      return newUser\n    },\n    deleteUser: (_: unknown, { id }: { id: number }) =\u0026gt; {\n      users = users.filter((user) =\u0026gt; user.id !== id)\n    },\n  },\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cblockquote\u003e\n\u003cp\u003eResolver의 parameter들\u003c/p\u003e\n\u003cp\u003eresolver는 \u003ccode\u003eparent\u003c/code\u003e, \u003ccode\u003eargs\u003c/code\u003e, \u003ccode\u003econtext\u003c/code\u003e, \u003ccode\u003einfo\u003c/code\u003e 네개의 parameter를 전달 받는다\n각 parameter의 역할은 아래와 같다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eparent\u003c/code\u003e - \u003ccode\u003efield resolver\u003c/code\u003e를 통해 현재 resolver가 호출 될 경우 부모 resolver에 의해 반환된 객체 (Resolver chaining)\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eargs\u003c/code\u003e - resolver를 호출할 때 전달한 인자\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003econtext\u003c/code\u003e - 모든 resolver에 공통적으로 전달되는 \u003ccode\u003econtext\u003c/code\u003e 객체로 일반적으로 미들웨어를 통해 기록된 값이 담겨있다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003einfo\u003c/code\u003e - schema 정보와 field 정보 등을 담은 객체\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch3 id=\"apollo-server-실행하기\"\u003eApollo Server 실행하기\u003c/h3\u003e\n\u003cp\u003eApollo Server를 실행하기 위한 type과 resolver가 모두 정의 되었으니 \u003ccode\u003eapollo server\u003c/code\u003e 를 실행하고 테스트 해본다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-typescript\"\u003eimport { ApolloServer } from \u0026#39;apollo-server\u0026#39;\nimport typeDefs from \u0026#39;./typeDefs\u0026#39;\nimport resolvers from \u0026#39;./resolvers\u0026#39;\n\nconst server = new ApolloServer({ typeDefs, resolvers })\n\nserver.listen(8080).then(() =\u0026gt; {\n  console.log(\u0026#39;Apollo Server is running on 8080\u0026#39;)\n})\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eApollo Server를 실행하면 \u003ccode\u003eApollo Studio\u003c/code\u003e 를 통해 작성한 GraphQL 서버로 요청을 보낼 수 있다.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eGraphQL Queries And Mutations\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eGraphQL에 요청을 보내기 위해 사용하게 되는 Syntax는 \u003cem\u003equery\u003c/em\u003e 또는 \u003cem\u003emutation\u003c/em\u003e에 관심 있는 필드를 정의하는 것을 기본으로 한다.\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://graphql.org/learn/queries/\"\u003e이곳\u003c/a\u003e 에서 보다 자세한 내용을 확인 할 수 있다.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch2 id=\"field-resolver를-이용한-테이블-join\"\u003eField resolver를 이용한 테이블 Join\u003c/h2\u003e\n\u003cp\u003eGraphQL은 반환하는 \u003ccode\u003eObject type\u003c/code\u003e의 모든 필드의 값이 \u003ccode\u003eresolver\u003c/code\u003e 에 의해 채워진다. 어떤 필드에 특정한 resolver가 정의되어 있지 않다면 일반적으로 \u003ccode\u003eobject.field\u003c/code\u003e 와 같은 형태로 값을 채우게 된다. (default resolver)\u003c/p\u003e\n\u003cp\u003e만약 특정 필드가 또 다른 테이블 (객체)을 통해 값이 결정 된다면 \u003ccode\u003efield resolver\u003c/code\u003e 를 정의하여 쉽게 값을 채울 수 있다.\u003c/p\u003e\n\u003cp\u003e사용자가 \u003ccode\u003eCompany\u003c/code\u003e라는 테이블과 relation을 가지고 있다면 아래와 같이 field resolver를 정의 할 수 있다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-typescript\"\u003e// dummy-data.ts\n...\n\nexport const dummyUsers = Array.from({ length: 20 }, (_, idx) =\u0026gt; {\n  return {\n    id: idx + 1,\n    name: `Sample User ${idx + 1}`,\n    age: Math.floor(Math.random() * 20),\n    companyId: (idx % 3) + 1, // company id를 통해 company 객체를 참조한다.\n  }\n}) as User[]\n\nexport interface Company {\n  id: number\n  name: string\n}\n\nexport const dummyCompanies = Array.from({ length: 3 }, (_, idx) =\u0026gt; {\n  return {\n    id: idx + 1,\n    name: `Sample Company ${idx + 1}`,\n  }\n}) as Company[]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode class=\"language-typescript\"\u003e// resolvers.ts\nimport { dummyUsers, User, dummyCompanies } from \u0026#39;./dummy-data\u0026#39;\n\n...\n\nlet companies = [...dummyCompanies]\n\n\nconst resolvers = {\n    ...\n\n    User: {\n        company: (parent: User) =\u0026gt; {\n            return companies.find((company) =\u0026gt; company.id === parent.companyId)\n        }\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003efield resolver를 이용할 경우 resolver chain을 통해 해당 필드에 대한 접근을 시도할 때에만 대상 객체에 접근하도록 구성 할 수 있고 가상 필드와 같은 효과를 손쉽게 구현 할 수 있다는 장점이 있다. 반면에 리스트 데이터를 조회할 때 유사한 결과를 리턴하는 레코드가 많이 포함되어 있다면 같은 로직을 여러차례 반복하게 되는 단점도 있다. (N + 1 problem)\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eN + 1 problem\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e사용자 레코드를 조회 할 때 사용자를 조회하기 위한 쿼리 1회 + 사용자와 관계를 맺고 있는 회사 레코드를 조회하는 쿼리 N 회가 발생하는 문제로 동일한 쿼리일 가능성이 높은 N회의 쿼리가 반복적으로 발생하는 문제\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/graphql/dataloader\"\u003eDataLoader\u003c/a\u003e와 같은 라이브러리를 이용해 caching, 또는 batch 처리 등의 방법으로 N + 1 problem으로 인해 발생하는 비효율성을 개선하기도 한다.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch2 id=\"typegraphql\"\u003eTypeGraphQL\u003c/h2\u003e\n\u003cp\u003eGraphQL을 이용한 프로젝트를 구성하다 보면 type 정의, resolver 정의 그리고 entity, interface 등 상당히 많은 파일들을 생성해내야 한다.\u003c/p\u003e\n\u003cp\u003e프로젝트 구조가 복잡해지거니와 유사한 형태의 파일들을 반복적으로 작성해야하는 것은 번거로운 일이다.\u003c/p\u003e\n\u003cp\u003eTypeGraphQL은 이런 번거로움을 해결하기 위한 라이브러리로 class를 정의하는 것을 통해 entity와 GraphQL type의 정의를 동시에 처리 할 수 있도록 돕는다.\u003c/p\u003e\n\u003ch3 id=\"디펜던시-설치\"\u003e디펜던시 설치\u003c/h3\u003e\n\u003cp\u003eTypeGraphQL을 사용하기 위해 필요한 디펜던시를 설치한다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e$ npm i graphql class-validator type-graphql reflect-metadata\n\u003c/code\u003e\u003c/pre\u003e\n\u003cblockquote\u003e\n\u003cp\u003e만약 디펜던시 설치중 에러가 발생한다면 type-graphql의 peer dependency인 graphql의 버전을 확인하고\u003c/p\u003e\n\u003cp\u003e필요한 경우 graphql을 삭제한 뒤 다시 설치한다\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch3 id=\"tsconfig-configuration\"\u003etsconfig configuration\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-json\"\u003e// tsconfig.json\n{\n  \u0026quot;target\u0026quot;: \u0026quot;es2018\u0026quot;, // type-graphql이 es2018 spec에 의존하고 있다\n  \u0026quot;emitDecoratorMetadata\u0026quot;: true, // decorator를 사용하기 위해 true로 설정\n  \u0026quot;experimentalDecorators\u0026quot;: true // decorator를 사용하기 위해 true로 설정\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"class-정의\"\u003eClass 정의\u003c/h3\u003e\n\u003cp\u003eclass 정의를 통해 GraphQL의 type과 typescript의 interface 역할을 수행할 객체를 정의 할 수 있다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-typescript\"\u003e// entities/User.ts\n\nimport { Field, ID, ObjectType } from \u0026#39;type-graphql\u0026#39;\n\n@ObjectType()\nexport class User {\n  @Field((type) =\u0026gt; ID)\n  id!: number\n\n  @Field()\n  name!: string\n\n  @Field()\n  age!: number\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"resolver-정의\"\u003eResolver 정의\u003c/h3\u003e\n\u003cp\u003eresolver 또한 class 형식으로 정의 할 수 있다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-typescript\"\u003e// resolvers/User.ts\n\nimport { Arg, Query, Resolver } from \u0026#39;type-graphql\u0026#39;\nimport { dummyUsers } from \u0026#39;../dummy-data\u0026#39;\nimport { User } from \u0026#39;../entities/User\u0026#39;\n\nlet users = [...dummyUsers]\n\n@Resolver()\nexport class UserResolver {\n  @Query((returns) =\u0026gt; User)\n  user(@Arg(\u0026#39;name\u0026#39;) name: string) {\n    const foundUser = users.find((user) =\u0026gt; user.name === name) || null\n    if (!foundUser) throw new Error(\u0026#39;No user found\u0026#39;)\n\n    return foundUser\n  }\n\n  @Query((returns) =\u0026gt; [User])\n  users() {\n    return users\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cblockquote\u003e\n\u003cp\u003eTypeGraphQL을 통해 resolver를 정의할 경우 반환 타입에 대한 validation이 더 엄격해진다. \u003ccode\u003enull\u003c/code\u003e 을 반환 할 수 없는 \u003ccode\u003eQuery\u003c/code\u003e 의 경우 반환할 결과물이 없을 경우 \u003ccode\u003enull\u003c/code\u003e 또는 \u003ccode\u003eundefined\u003c/code\u003e 를 리턴하지 않도록 에러 처리를 해줘야한다.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch3 id=\"schema-생성하기\"\u003eSchema 생성하기\u003c/h3\u003e\n\u003cp\u003e이렇게 정의한 \u003ccode\u003eresolver\u003c/code\u003e를 통해 schema를 생성해야 한다. 생성된 schema는 Apollo Server를 실행할 때 전달되는 \u003ccode\u003econfig\u003c/code\u003e 로 사용된다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-typescript\"\u003e// app.ts\n\nimport { ApolloServer } from \u0026#39;apollo-server\u0026#39;\nimport \u0026#39;reflect-metadata\u0026#39;\nimport { buildSchema } from \u0026#39;type-graphql\u0026#39;\nimport { UserResolver } from \u0026#39;./resolvers/User\u0026#39;\n\nbuildSchema({\n  resolvers: [UserResolver],\n}).then((schema) =\u0026gt; {\n  const server = new ApolloServer({ schema })\n\n  server.listen(8080).then(() =\u0026gt; {\n    console.log(\u0026#39;Apollo Server is running on 8080\u0026#39;)\n  })\n})\n\u003c/code\u003e\u003c/pre\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003ccode\u003e\u0026#39;reflect-metadata\u0026#39;\u003c/code\u003e 를 import 해야한다. schema 생성시 해당 모듈에 의존하기 때문이다.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch3 id=\"그-밖의-설정들\"\u003e그 밖의 설정들\u003c/h3\u003e\n\u003cp\u003e그 밖의 설정들은 \u003ca href=\"https://typegraphql.com/docs/introduction.html\"\u003e공식 문서를\u003c/a\u003e 참조한다.\u003c/p\u003e\n","postsByCategory":[]},"__N_SSG":true},"page":"/[title]","query":{"title":"apollo-server-+-typegraphql을-이용한-graphql-api-서버-구성하기"},"buildId":"tW1VJICNjS_tjNJW4WsNt","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>