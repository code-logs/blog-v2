<!DOCTYPE html><html lang="ko"><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><link rel="canonical" href="https://code-logs.github.io/고차-컴퍼넌트-(hoc:-higher-order-component)"/><link rel="apple-touch-icon" href="/icons/icon-192x-192.png"/><link rel="manifest" href="/manifest.json"/><meta name="theme-color" content="#fff"/><meta property="og:type" content="website"/><meta property="og:site_name" content="Code Logs"/><meta name="author" content="Jay Lee"/><meta name="keyword" content="hoc, higher order component, 고차 컴퍼넌트, react, 리액트, 고차 컴퍼넌트 (HOC: Higher Order Component), React - 고차 컴퍼넌트를 이용한 컴퍼넌트의 재사용, react"/><meta name="description" content="React - 고차 컴퍼넌트를 이용한 컴퍼넌트의 재사용"/><meta property="og:description" content="React - 고차 컴퍼넌트를 이용한 컴퍼넌트의 재사용"/><meta property="og:title" content="고차 컴퍼넌트 (HOC: Higher Order Component) | Code Logs"/><meta property="og:url" content="https://code-logs.github.io/고차-컴퍼넌트-(hoc:-higher-order-component)"/><meta property="og:image" content="/assets/images/hoc.jpg"/><title>고차 컴퍼넌트 (HOC: Higher Order Component) | Code Logs</title><meta name="next-head-count" content="16"/><link rel="preload" href="/_next/static/css/952f0d8a41f9b4fa.css" as="style"/><link rel="stylesheet" href="/_next/static/css/952f0d8a41f9b4fa.css" data-n-g=""/><link rel="preload" href="/_next/static/css/9f2fc622355c4ebf.css" as="style"/><link rel="stylesheet" href="/_next/static/css/9f2fc622355c4ebf.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script src="/_next/static/chunks/webpack-2e51481b1d484a05.js" defer=""></script><script src="/_next/static/chunks/framework-5f4595e5518b5600.js" defer=""></script><script src="/_next/static/chunks/main-a4d9e436b9a532ca.js" defer=""></script><script src="/_next/static/chunks/pages/_app-f30633b9d9106e05.js" defer=""></script><script src="/_next/static/chunks/294-c1b4c50337db4bdd.js" defer=""></script><script src="/_next/static/chunks/pages/%5Btitle%5D-511c1ea60209342b.js" defer=""></script><script src="/_next/static/8kQfkTjKqXij2JEBq0puI/_buildManifest.js" defer=""></script><script src="/_next/static/8kQfkTjKqXij2JEBq0puI/_ssgManifest.js" defer=""></script><script src="/_next/static/8kQfkTjKqXij2JEBq0puI/_middlewareManifest.js" defer=""></script></head><body><div id="__next" data-reactroot=""><header class="Header_header__RW35m"><p class="Header_title__GPS8b">Code Logs</p><ul class="Header_socialIcons__CBf_s"><li><a href="https://github.com/possible819" target="_blank" rel="noreferrer" aria-label="My Github"><style data-emotion="css vubbuv">.css-vubbuv{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;width:1em;height:1em;display:inline-block;fill:currentColor;-webkit-flex-shrink:0;-ms-flex-negative:0;flex-shrink:0;-webkit-transition:fill 200ms cubic-bezier(0.4, 0, 0.2, 1) 0ms;transition:fill 200ms cubic-bezier(0.4, 0, 0.2, 1) 0ms;font-size:1.5rem;}</style><svg class="MuiSvgIcon-root MuiSvgIcon-fontSizeMedium css-vubbuv" focusable="false" aria-hidden="true" viewBox="0 0 24 24" data-testid="GitHubIcon"><path d="M12 1.27a11 11 0 00-3.48 21.46c.55.09.73-.28.73-.55v-1.84c-3.03.64-3.67-1.46-3.67-1.46-.55-1.29-1.28-1.65-1.28-1.65-.92-.65.1-.65.1-.65 1.1 0 1.73 1.1 1.73 1.1.92 1.65 2.57 1.2 3.21.92a2 2 0 01.64-1.47c-2.47-.27-5.04-1.19-5.04-5.5 0-1.1.46-2.1 1.2-2.84a3.76 3.76 0 010-2.93s.91-.28 3.11 1.1c1.8-.49 3.7-.49 5.5 0 2.1-1.38 3.02-1.1 3.02-1.1a3.76 3.76 0 010 2.93c.83.74 1.2 1.74 1.2 2.94 0 4.21-2.57 5.13-5.04 5.4.45.37.82.92.82 2.02v3.03c0 .27.1.64.73.55A11 11 0 0012 1.27"></path></svg></a></li></ul><nav class="NavBar_navBar__akqA3"><ul><li><a class="MarkedAnchor_anchor__QCmkL" href="https://code-logs.github.io/">Home</a></li><li><a class="MarkedAnchor_anchor__QCmkL" href="https://code-logs.github.io/posts/1">Posts</a></li><li><a class="MarkedAnchor_anchor__QCmkL" href="https://code-logs.github.io/about">About</a></li></ul></nav></header><main><article class="PostDetail_container__Ma_26"><p class="PostDetail_publishedAt__7GOQm"><span></span></p><section class="PostDetail_thumbnailWrapper__oALCg"><img src="/assets/images/hoc.jpg" alt="React - 고차 컴퍼넌트를 이용한 컴퍼넌트의 재사용"/></section><section><h1>고차 컴퍼넌트 (HOC: Higher Order Component)</h1><p class="PostDetail_description__l6wHC">React - 고차 컴퍼넌트를 이용한 컴퍼넌트의 재사용</p></section><section><h2 id="table-of-contents">Table of contents</h2>
<ol>
<li><a href="#%EA%B3%A0%EC%B0%A8-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8%EB%9E%80">고차 컴포넌트란?</a><ol>
<li><a href="#%EC%A0%95%EC%9D%98">정의</a></li>
</ol>
</li>
<li><a href="#%EA%B3%A0%EC%B0%A8-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0">고차 컴포넌트를 사용하는 이유</a></li>
<li><a href="#%EA%B3%A0%EC%B0%A8-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8-%EC%82%AC%EC%9A%A9%EB%B0%A9%EB%B2%95">고차 컴포넌트 사용방법</a><ol>
<li><a href="#sample">Sample</a></li>
</ol>
</li>
</ol>
<h2 id="고차-컴포넌트란">고차 컴포넌트란?</h2>
<p>컴포넌트를 이용한 웹개발은 재사용성을 확보하는데 아주 큰 의미가 있다. 일회성으로 사용되고 다시는 사용 할 수 없는 컴포넌트는 컴포넌트 그 자체의 의미를 잃어버리는 것이다.</p>
<h3 id="정의">정의</h3>
<p>고차 컴포넌트는 컴포넌트의 재사용을 위해 사용 할 수 있는 <code>패턴</code>으로 특정 컴포넌트가 가지고 있는 로직을 재사용할 수 있도록 돕는다.</p>
<p>고차 컴포넌트는 아래와 같이 컴포넌트를 함수의 인자로 받아 새로운 컴포넌트를 리턴하는 형식을 갖느다.</p>
<pre><code class="language-javascript">const EnhancedComponent = higherOrderComponent(WrappedComponent)
</code></pre>
<blockquote>
<p>고차 컴포넌트(HOC)는 React API의 일부가 아니며, React의 구성적 특성에서 나오는 패턴입니다. - <a href="https://ko.reactjs.org/docs/higher-order-components.html">React Docs</a></p>
</blockquote>
<h2 id="고차-컴포넌트를-사용하는-이유">고차 컴포넌트를 사용하는 이유</h2>
<p>서두에 이야기한 것 처럼 고차 컴포넌트는 <strong>컴포넌트가 가지고 있는 로직을 재사용</strong>하기 위해 사용한다. 간단히 말하면 재사용성을 확보한다는데 의미가 있으며 이를 통해 <strong>횡단 관심사</strong> 문제를 해결 할 수 있다.</p>
<blockquote>
<p>횡단 관심사 (Cross cutting concerns)</p>
<p>어떤 시스템의 본래 목적을 위한 기능들을 핵심 관심사라하며 핵심 관심사를 수행하기 위한 절차에 반복적으로 등장하는 기능이 횡단 관심사다.</p>
<p>핵심 관심사를 수행하기 위해 발생하는 클라이언트의 요청을 완료하기 까지 매번 발생하게 되는 <code>인증 확인</code>, <code>로그 생성</code>과 같은 것을 예로 들수있다.</p>
</blockquote>
<h2 id="고차-컴포넌트-사용방법">고차 컴포넌트 사용방법</h2>
<p>고차 컴포넌트를 사용하기 위해 아래의 몇가지 규칙을 따라야한다.</p>
<ul>
<li>고차 컴포넌트는 컴포넌트를 리턴해야한다.</li>
<li>일반적으로 고차 컴포넌트 생성 함수의 명칭은 <code>with___</code> 형태를 갖는다.</li>
<li>클래스 컴포넌트를 이용할 경우 고차 컴포넌트는 기존 컴포넌트의 static method를 갖지 않기 때문에 이를 복사해 줘야 한다.<ul>
<li><a href="https://github.com/mridgway/hoist-non-react-statics">hoist-non-react-statics</a>를 사용하여 이를 편히 해결 할 수 있다.</li>
</ul>
</li>
<li>클래스 컴포넌트를 이용할 경우 <code>render</code> 함수 내부에서 고차함수를 호출해선 안된다.<ul>
<li>render가 발생 할 때 마다 새로운 고차함수를 만들어내게 되고 그 결과 내부로 전달되었던 property와 컴포넌트가 가지고 있던 state가 손실되기 때문</li>
</ul>
</li>
<li>ref는 전달되지 않는다.<ul>
<li>ref는 React에서 일반적인 props와 동일하게 취급되지 않기 때문에 ref를 전달할 경우 내부 컴포넌트가 전달되는 것이 아닌 가장 바깥쪽 컨테이너 컴포넌트를 가르키게 된다.</li>
<li>이를 해결하기 위해서는 <a href="https://ko.reactjs.org/docs/forwarding-refs.html">React.forwardRef API</a>를 사용해야 합니다.</li>
</ul>
</li>
</ul>
<h3 id="sample">Sample</h3>
<p>다음 이야기를 기준으로 컴포넌트를 개발해 보도록 한다.</p>
<p>버튼을 클릭하면 클릭한 횟수를 표시하는 버튼 컴포넌트를 개발해야 한다.</p>
<pre><code class="language-javascript">// ClickCounterButton.jsx
const ClickCounterButton = () =&gt; {
  const [count, setCount] = useState(0)

  const increaseCount = () =&gt; {
    setCount(count + 1)
  }

  return &lt;button onClick={increaseCount}&gt;Click count: {count}&lt;/button&gt;
}

export default ClickCounterButton
</code></pre>
<p>버튼을 더블클릭하면 더블클릭한 횟수를 표시하는 버튼 컴포넌트를 개발해야 한다.</p>
<pre><code class="language-javascript">// DblClickCounterButton.jsx
const DblClickCounterButton = () =&gt; {
  const [count, setCount] = useState(0)

  const increaseCount = () =&gt; {
    setCount(count + 1)
  }

  return &lt;button onDblClick={increaseCount}&gt;Double click count: {count}&lt;/button&gt;
}

export default DblClickCounterButton
</code></pre>
<p>앞서 만든 두개의 컴포넌트가 상당부분 유사한 기능을 수행하고 있다는 것을 발견하고 이를 공통화 한다.</p>
<pre><code class="language-javascript">// withCounter.jsx
const withCounter = (WrappedComponent) =&gt; (props) =&gt; {
  const [count, setCount] = useState(0)

  const increaseCount = () =&gt; {
    setCount(count + 1)
  }

  return (
    &lt;WrappedComponent increaseCount={increaseCount} count={count} {...props} /&gt;
  )
}

export default withCounter
</code></pre>
<p>고차 컴포넌트를 생성하기 위한 함수를 만들었으니 기존에 만들었던 <code>ClickCounterButton</code>과 <code>DblClickCounterButton</code>의 공통된 내부 로직을 삭제하고 <code>withCounter</code>의 공통 로직을 전달 받도록 수정한다.</p>
<pre><code class="language-javascript">// ClickCounterButton.jsx
const ClickCounterButton = (props) =&gt; (
  &lt;button onClick={props.increaseCount}&gt;Click count: {props.count}&lt;/button&gt;
)

export default withCounter(ClickCounterButton)
</code></pre>
<pre><code class="language-javascript">// DblClickCounterButton.jsx
const DblClickCounterButton = (props) =&gt; (
  &lt;button onDblClick={increaseCount}&gt;Double click count: {props.count}&lt;/button&gt;
)

export default withCounter(DblClickCounterButton)
</code></pre>
<blockquote>
<p>주목할 부분은 <code>export</code> 구문에 있다. 기존의 정의한 컴포넌트를 리턴하는 것이 아닌 <code>withCounter</code>를 호출한 결과 생성된 컴포넌트를 리턴하는 것을 통해 고차 컴포넌트를 생성해야 한다.</p>
</blockquote>
<p><code>ClickCounterButton</code>의 버튼 메시지 <code>Click count:</code>를 <code>text</code>라는 명칭의 프로퍼티를 통해 외부에서 주입 받도록 수정해야한다면?</p>
<pre><code class="language-javascript">// ClickCounterButton.jsx
const ClickCounterButton = (props) =&gt; (
  &lt;button onClick={props.increaseCount}&gt;
    {props.text}: {props.count}
  &lt;/button&gt;
)

export default withCounter(ClickCounterButton)
</code></pre>
<p><code>DblClickCounterButton</code>의 버튼 메시지 <code>Double click count:</code> 또한 외부에서 주입 받도록 수정해야 하고 이번에는 <code>title</code>이라는 명칭의 프로퍼티를 통해야 한다면?</p>
<pre><code class="language-javascript">// DblClickCounterButton.jsx
const DblClickCounterButton = (props) =&gt; (
  &lt;button onDblClick={increaseCount}&gt;
    {props.title} {props.count}
  &lt;/button&gt;
)

export default withCounter(DblClickCounterButton)
</code></pre>
<p>이렇게 컴포넌트의 로컬 프로퍼티를 정의 했다고 하더라고 <code>HOC</code>를 통해 대상 프로퍼티의 값을 전달해 줄수 있다.</p>
<pre><code class="language-javascript">// withCounter.jsx
const withCounter = (WrappedComponent) =&gt; (props) =&gt; {
  const [count, setCount] = useState(0)

  const increaseCount = () =&gt; {
    setCount(count + 1)
  }

  return (
    &lt;WrappedComponent increaseCount={increaseCount} count={count} {...props} /&gt;
  )
}

export default withCounter
</code></pre>
<blockquote>
<p>앞서 정의한 <code>HOC</code>를 다시 살펴 보면 <code>withCounter</code>는 <code>WrappedComponent</code>를 전달 받고 바로 <code>(props) =&gt; JSX.Element</code> 형식의 함수를 리턴하게 된다 그 결과 <code>props</code> 변수를 통해 컴포넌트를 대상으로한 <code>props</code>를 전달 받을 수 있고 최종적으로 <code>{...props}</code>를 통해 대상 컴포넌트에 프로퍼티를 전달 할 수 있게 된다.</p>
</blockquote>
</section></article><section class="PostDetail_utterances__jZeOm"><h2>Comments</h2><div></div></section><div class="KakaoAdfitBanner_wrapper__WcRZO"><ins class="kakao_ad_area" style="display:none" data-ad-unit="DAN-77VcMo8qRv55JIat" data-ad-width="320" data-ad-height="100"></ins></div><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-7134579063537339" data-ad-slot="5391522351" data-ad-format="auto" data-full-width-responsive="true"></ins></main><aside><div class="KakaoAdfitBanner_wrapper__WcRZO"><ins class="kakao_ad_area" style="display:none" data-ad-unit="DAN-sspT2WysGuBsayRb" data-ad-width="160" data-ad-height="600"></ins></div><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-7134579063537339" data-ad-slot="8825787758" data-ad-format="auto" data-full-width-responsive="true"></ins></aside><footer class="Footer_footer__GLL0J"><p>ⓒ 2021. Jay Lee  all rights reserved.</p></footer></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"고차 컴퍼넌트 (HOC: Higher Order Component)","fileName":"hoc.md","description":"React - 고차 컴퍼넌트를 이용한 컴퍼넌트의 재사용","category":"react","published":true,"publishedAt":"2021-10-30","tags":["hoc","higher order component","고차 컴퍼넌트","react","리액트"],"thumbnailName":"hoc.jpg"},"content":"\u003ch2 id=\"table-of-contents\"\u003eTable of contents\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003e\u003ca href=\"#%EA%B3%A0%EC%B0%A8-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8%EB%9E%80\"\u003e고차 컴포넌트란?\u003c/a\u003e\u003col\u003e\n\u003cli\u003e\u003ca href=\"#%EC%A0%95%EC%9D%98\"\u003e정의\u003c/a\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#%EA%B3%A0%EC%B0%A8-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0\"\u003e고차 컴포넌트를 사용하는 이유\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#%EA%B3%A0%EC%B0%A8-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8-%EC%82%AC%EC%9A%A9%EB%B0%A9%EB%B2%95\"\u003e고차 컴포넌트 사용방법\u003c/a\u003e\u003col\u003e\n\u003cli\u003e\u003ca href=\"#sample\"\u003eSample\u003c/a\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2 id=\"고차-컴포넌트란\"\u003e고차 컴포넌트란?\u003c/h2\u003e\n\u003cp\u003e컴포넌트를 이용한 웹개발은 재사용성을 확보하는데 아주 큰 의미가 있다. 일회성으로 사용되고 다시는 사용 할 수 없는 컴포넌트는 컴포넌트 그 자체의 의미를 잃어버리는 것이다.\u003c/p\u003e\n\u003ch3 id=\"정의\"\u003e정의\u003c/h3\u003e\n\u003cp\u003e고차 컴포넌트는 컴포넌트의 재사용을 위해 사용 할 수 있는 \u003ccode\u003e패턴\u003c/code\u003e으로 특정 컴포넌트가 가지고 있는 로직을 재사용할 수 있도록 돕는다.\u003c/p\u003e\n\u003cp\u003e고차 컴포넌트는 아래와 같이 컴포넌트를 함수의 인자로 받아 새로운 컴포넌트를 리턴하는 형식을 갖느다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003econst EnhancedComponent = higherOrderComponent(WrappedComponent)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cblockquote\u003e\n\u003cp\u003e고차 컴포넌트(HOC)는 React API의 일부가 아니며, React의 구성적 특성에서 나오는 패턴입니다. - \u003ca href=\"https://ko.reactjs.org/docs/higher-order-components.html\"\u003eReact Docs\u003c/a\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch2 id=\"고차-컴포넌트를-사용하는-이유\"\u003e고차 컴포넌트를 사용하는 이유\u003c/h2\u003e\n\u003cp\u003e서두에 이야기한 것 처럼 고차 컴포넌트는 \u003cstrong\u003e컴포넌트가 가지고 있는 로직을 재사용\u003c/strong\u003e하기 위해 사용한다. 간단히 말하면 재사용성을 확보한다는데 의미가 있으며 이를 통해 \u003cstrong\u003e횡단 관심사\u003c/strong\u003e 문제를 해결 할 수 있다.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e횡단 관심사 (Cross cutting concerns)\u003c/p\u003e\n\u003cp\u003e어떤 시스템의 본래 목적을 위한 기능들을 핵심 관심사라하며 핵심 관심사를 수행하기 위한 절차에 반복적으로 등장하는 기능이 횡단 관심사다.\u003c/p\u003e\n\u003cp\u003e핵심 관심사를 수행하기 위해 발생하는 클라이언트의 요청을 완료하기 까지 매번 발생하게 되는 \u003ccode\u003e인증 확인\u003c/code\u003e, \u003ccode\u003e로그 생성\u003c/code\u003e과 같은 것을 예로 들수있다.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch2 id=\"고차-컴포넌트-사용방법\"\u003e고차 컴포넌트 사용방법\u003c/h2\u003e\n\u003cp\u003e고차 컴포넌트를 사용하기 위해 아래의 몇가지 규칙을 따라야한다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e고차 컴포넌트는 컴포넌트를 리턴해야한다.\u003c/li\u003e\n\u003cli\u003e일반적으로 고차 컴포넌트 생성 함수의 명칭은 \u003ccode\u003ewith___\u003c/code\u003e 형태를 갖는다.\u003c/li\u003e\n\u003cli\u003e클래스 컴포넌트를 이용할 경우 고차 컴포넌트는 기존 컴포넌트의 static method를 갖지 않기 때문에 이를 복사해 줘야 한다.\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/mridgway/hoist-non-react-statics\"\u003ehoist-non-react-statics\u003c/a\u003e를 사용하여 이를 편히 해결 할 수 있다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e클래스 컴포넌트를 이용할 경우 \u003ccode\u003erender\u003c/code\u003e 함수 내부에서 고차함수를 호출해선 안된다.\u003cul\u003e\n\u003cli\u003erender가 발생 할 때 마다 새로운 고차함수를 만들어내게 되고 그 결과 내부로 전달되었던 property와 컴포넌트가 가지고 있던 state가 손실되기 때문\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eref는 전달되지 않는다.\u003cul\u003e\n\u003cli\u003eref는 React에서 일반적인 props와 동일하게 취급되지 않기 때문에 ref를 전달할 경우 내부 컴포넌트가 전달되는 것이 아닌 가장 바깥쪽 컨테이너 컴포넌트를 가르키게 된다.\u003c/li\u003e\n\u003cli\u003e이를 해결하기 위해서는 \u003ca href=\"https://ko.reactjs.org/docs/forwarding-refs.html\"\u003eReact.forwardRef API\u003c/a\u003e를 사용해야 합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"sample\"\u003eSample\u003c/h3\u003e\n\u003cp\u003e다음 이야기를 기준으로 컴포넌트를 개발해 보도록 한다.\u003c/p\u003e\n\u003cp\u003e버튼을 클릭하면 클릭한 횟수를 표시하는 버튼 컴포넌트를 개발해야 한다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003e// ClickCounterButton.jsx\nconst ClickCounterButton = () =\u0026gt; {\n  const [count, setCount] = useState(0)\n\n  const increaseCount = () =\u0026gt; {\n    setCount(count + 1)\n  }\n\n  return \u0026lt;button onClick={increaseCount}\u0026gt;Click count: {count}\u0026lt;/button\u0026gt;\n}\n\nexport default ClickCounterButton\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e버튼을 더블클릭하면 더블클릭한 횟수를 표시하는 버튼 컴포넌트를 개발해야 한다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003e// DblClickCounterButton.jsx\nconst DblClickCounterButton = () =\u0026gt; {\n  const [count, setCount] = useState(0)\n\n  const increaseCount = () =\u0026gt; {\n    setCount(count + 1)\n  }\n\n  return \u0026lt;button onDblClick={increaseCount}\u0026gt;Double click count: {count}\u0026lt;/button\u0026gt;\n}\n\nexport default DblClickCounterButton\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e앞서 만든 두개의 컴포넌트가 상당부분 유사한 기능을 수행하고 있다는 것을 발견하고 이를 공통화 한다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003e// withCounter.jsx\nconst withCounter = (WrappedComponent) =\u0026gt; (props) =\u0026gt; {\n  const [count, setCount] = useState(0)\n\n  const increaseCount = () =\u0026gt; {\n    setCount(count + 1)\n  }\n\n  return (\n    \u0026lt;WrappedComponent increaseCount={increaseCount} count={count} {...props} /\u0026gt;\n  )\n}\n\nexport default withCounter\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e고차 컴포넌트를 생성하기 위한 함수를 만들었으니 기존에 만들었던 \u003ccode\u003eClickCounterButton\u003c/code\u003e과 \u003ccode\u003eDblClickCounterButton\u003c/code\u003e의 공통된 내부 로직을 삭제하고 \u003ccode\u003ewithCounter\u003c/code\u003e의 공통 로직을 전달 받도록 수정한다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003e// ClickCounterButton.jsx\nconst ClickCounterButton = (props) =\u0026gt; (\n  \u0026lt;button onClick={props.increaseCount}\u0026gt;Click count: {props.count}\u0026lt;/button\u0026gt;\n)\n\nexport default withCounter(ClickCounterButton)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003e// DblClickCounterButton.jsx\nconst DblClickCounterButton = (props) =\u0026gt; (\n  \u0026lt;button onDblClick={increaseCount}\u0026gt;Double click count: {props.count}\u0026lt;/button\u0026gt;\n)\n\nexport default withCounter(DblClickCounterButton)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cblockquote\u003e\n\u003cp\u003e주목할 부분은 \u003ccode\u003eexport\u003c/code\u003e 구문에 있다. 기존의 정의한 컴포넌트를 리턴하는 것이 아닌 \u003ccode\u003ewithCounter\u003c/code\u003e를 호출한 결과 생성된 컴포넌트를 리턴하는 것을 통해 고차 컴포넌트를 생성해야 한다.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e\u003ccode\u003eClickCounterButton\u003c/code\u003e의 버튼 메시지 \u003ccode\u003eClick count:\u003c/code\u003e를 \u003ccode\u003etext\u003c/code\u003e라는 명칭의 프로퍼티를 통해 외부에서 주입 받도록 수정해야한다면?\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003e// ClickCounterButton.jsx\nconst ClickCounterButton = (props) =\u0026gt; (\n  \u0026lt;button onClick={props.increaseCount}\u0026gt;\n    {props.text}: {props.count}\n  \u0026lt;/button\u0026gt;\n)\n\nexport default withCounter(ClickCounterButton)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003eDblClickCounterButton\u003c/code\u003e의 버튼 메시지 \u003ccode\u003eDouble click count:\u003c/code\u003e 또한 외부에서 주입 받도록 수정해야 하고 이번에는 \u003ccode\u003etitle\u003c/code\u003e이라는 명칭의 프로퍼티를 통해야 한다면?\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003e// DblClickCounterButton.jsx\nconst DblClickCounterButton = (props) =\u0026gt; (\n  \u0026lt;button onDblClick={increaseCount}\u0026gt;\n    {props.title} {props.count}\n  \u0026lt;/button\u0026gt;\n)\n\nexport default withCounter(DblClickCounterButton)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이렇게 컴포넌트의 로컬 프로퍼티를 정의 했다고 하더라고 \u003ccode\u003eHOC\u003c/code\u003e를 통해 대상 프로퍼티의 값을 전달해 줄수 있다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003e// withCounter.jsx\nconst withCounter = (WrappedComponent) =\u0026gt; (props) =\u0026gt; {\n  const [count, setCount] = useState(0)\n\n  const increaseCount = () =\u0026gt; {\n    setCount(count + 1)\n  }\n\n  return (\n    \u0026lt;WrappedComponent increaseCount={increaseCount} count={count} {...props} /\u0026gt;\n  )\n}\n\nexport default withCounter\n\u003c/code\u003e\u003c/pre\u003e\n\u003cblockquote\u003e\n\u003cp\u003e앞서 정의한 \u003ccode\u003eHOC\u003c/code\u003e를 다시 살펴 보면 \u003ccode\u003ewithCounter\u003c/code\u003e는 \u003ccode\u003eWrappedComponent\u003c/code\u003e를 전달 받고 바로 \u003ccode\u003e(props) =\u0026gt; JSX.Element\u003c/code\u003e 형식의 함수를 리턴하게 된다 그 결과 \u003ccode\u003eprops\u003c/code\u003e 변수를 통해 컴포넌트를 대상으로한 \u003ccode\u003eprops\u003c/code\u003e를 전달 받을 수 있고 최종적으로 \u003ccode\u003e{...props}\u003c/code\u003e를 통해 대상 컴포넌트에 프로퍼티를 전달 할 수 있게 된다.\u003c/p\u003e\n\u003c/blockquote\u003e\n"},"__N_SSG":true},"page":"/[title]","query":{"title":"고차-컴퍼넌트-(hoc:-higher-order-component)"},"buildId":"8kQfkTjKqXij2JEBq0puI","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>